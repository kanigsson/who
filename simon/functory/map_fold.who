(**************************************************************************)
(*                                                                        *)
(*  Functory: a distributed computing library for Ocaml                   *)
(*  Copyright (C) 2010 Jean-Christophe Filliatre and Kalyan Krishnamani   *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* ====================================
data struct
======================================= *)

(* ============ hash tables =========== *)
type hashtbl ['a 'b]
logic Hashtbl.add ['a 'b|r|] : ref(r, ('a, 'b) hashtbl) -> 'a -> 'b ->{r} unit
logic Hashtbl.create ['a 'b||] : int ->{} ('a, 'b) hashtbl
logic Hashtbl.mem ['a 'b] : ('a, 'b) hashtbl  -> 'a -> prop
logic Hashtbl.length ['a 'b] : ('a, 'b) hashtbl -> int
parameter Hashtbl.find ['a 'b||] (hshtbl : ('a, 'b) hashtbl) (x : 'a) : {} 'b =
  { Hashtbl.mem hshtbl x }
  {}
axiom hashtbl_empty_lengh ['a 'b|r|] :
  forall (n: int).
  [[]] (Hashtbl.create n : ('a, 'b) hashtbl) [[res : (Hashtbl.length res) = 0 /\ forall (x:'a). ~ (Hashtbl.mem res x)]]
(* adding an item to a hashtbl makes this item member of the later *)
axiom hashtbl_add ['a 'b|r|] :
  forall (x : 'a) (y : 'b) (hshtbl : ref(r, ('a, 'b) hashtbl)).
  [[]] Hashtbl.add hshtbl x y [[Hashtbl.mem !!hshtbl x]]
(* adding an item to a hastable increments its length *)
axiom hashtbl_add_length ['a 'b|r|] :
  forall (x : 'a) (y : 'b) (hshtbl : ref(r, ('a, 'b) hashtbl)).
  [[~ (Hashtbl.mem !!hshtbl x)]] Hashtbl.add hshtbl x y [[(Hashtbl.length !!hshtbl) = (Hashtbl.length !!hshtbl@old) +1]]


(* ============ lists ============= *)
logic List.mem ['a] : 'a -> 'a list -> prop
logic List.remove ['a] : 'a -> 'a list -> 'a list
logic List.map ['a 'b||'e] : ('a ->{'e} 'b) -> 'a list ->{'e} 'b list
logic List.length ['a] : 'a list -> int
logic List.append ['a] : 'a list -> 'a list -> 'a list
logic List.cons ['a] : 'a -> 'a list -> 'a list

axiom remove_does_remove ['a] :
  forall (x : 'a) (l : 'a list).
    ~ (List.mem x (List.remove x l))
axiom append_does_append ['a] :
  forall (l1 l2 : 'a list) (x : 'a).
    (List.mem x l1 -> List.mem x (List.append l1 l2)) /\
    (List.mem x l2 -> List.mem x (List.append l1 l2))
axiom list_mem_map ['a 'b||'e]:
  forall (x:'a) (l:'a list) (f:'a ->{'e} 'b).
  List.mem x l -> List.mem (f x) (List.map [{'e}] f l)
axiom list_length_map ['a 'b||'e]:
  forall (l:'a list) (f:'a ->{'e} 'b).
  List.length l = List.length (List.map [{'e}] f l)
axiom list_cons ['a]:
  forall (x:'a) (l:'a list).
  List.mem x (List.cons x l) /\
  (forall (y:'a). List.mem y l -> List.mem y (List.cons x l)) /\
  (List.length (List.cons x l) = List.length l + 1)

(* =========== refs ========== *)

logic incr [|r|] : ref(r, int) ->{r} unit
axiom incr_increments [|r|] :
  forall (s : ref(r, int)).
  [[]] incr s [[!!s = ((!!s@old) + 1)]]

(* ================== special data =================== *)
type map_or_fold ['a 'b] =
  | Map of 'a
  | Fold of 'b

logic is_map ['a 'b] : ('a, 'b) map_or_fold -> prop
logic is_fold ['a 'b] : ('a, 'b) map_or_fold -> prop
axiom is_map_map ['a 'b] :
  forall (x : 'a) (y : ('a, 'b) map_or_fold).
  y = Map x -> (is_map y /\ ~(is_fold y))
axiom is_not_map_fold ['a 'b] :
  forall (x : 'b) (y : ('a, 'b) map_or_fold).
  y = Fold x -> ((~ (is_map y)) /\ is_fold y)

logic fromMap ['a 'b] : (('a, 'b) map_or_fold) -> 'a
logic fromFold ['a 'b] : (('a, 'b) map_or_fold) -> 'b
axiom from_map ['a 'b] :
  forall (x : ('a, 'b) map_or_fold) (y : 'a).
  is_map x -> x = Map y -> (fromMap x = y)
axiom from_fold ['a 'b] :
  forall (x : ('a, 'b) map_or_fold) (y : 'b).
  is_fold x -> x = Fold y -> (fromFold x = y)



parameter map_fold_wrapper ['a 'b 'c 'd 'e]
  (map : ('a -> 'e))
  (fold : ('b -> 'c -> 'd))
  (truc : ('a, ('b * 'c)) map_or_fold) : {} ('e, 'd) map_or_fold =
  {}
  { res:
    ((is_map truc) -> res = Map (map (fromMap truc))) /\
    ((is_fold truc) -> res = Fold (fold (fst (fromFold truc)) (snd (fromFold truc))))
  }

parameter map_fold_wrapper2 ['a 'b 'c 'd 'e]
  (map : 'a -> 'd)
  (fold : 'b -> 'c -> 'd)
  (truc : ('a, ('b * 'c)) map_or_fold) : {} 'd =
  {}
  { res:
    (is_map truc -> res = map (fromMap truc)) /\
    (is_fold truc -> res = fold (fst (fromFold truc)) (snd (fromFold truc)))
  }

(*
let map_fold_wrapper map fold = function
  | Map x -> Map (map x)
  | Fold (x, y) -> Fold (fold x y)

let map_fold_wrapper2 map fold = function
  | Map x -> map x
  | Fold (x, y) -> fold x y
*)

(* =============================
master and worker specs
================================ *)

type a
type b
logic worker : a -> b
logic master ['c||'e] : (a * 'c) -> b ->{'e} (a *'c) list

(* relation *)
logic relat ['c||'e] : <'e> -> (a * 'c) list -> <'e> -> (a * 'c) list -> prop
axiom relat_init ['c||'e] : (* one step of worker does keep the invariant *)
  forall (l1 l2 : (a * 'c) list) (x : a) (y : 'c) (e1 e2 : <'e>).
    (List.mem (x, y) l1 /\
    [[ cur = e1 ]] master [{'e}] (x, y) (worker x) [[ l : cur = e2 /\ l2 = List.remove (x, y) (List.append l l1) ]] )
    -> relat [{'e}] e1 l1 e2 l2

(* transitive reflective closure *)
logic relat_trans ['c||'e] : <'e> -> (a * 'c) list -> <'e> -> (a * 'c) list -> prop
axiom relat_trans_reflex ['c||'e] :
  forall (e1 : <'e>) (l1 : (a * 'c) list).
    relat_trans [{'e}] e1 l1 e1 l1
axiom relat_trans_trans ['c||'e] :
  forall (e1 e2 e3 : <'e>) (l1 l2 l3 : (a * 'c) list).
    (relat_trans [{'e}] e1 l1 e2 l2  /\ relat [{'e}] e2 l2 e3 l3)
    -> relat_trans [{'e}] e1 l1 e3 l3


parameter X.compute ['c||'e]
  (inv : <'e> -> (a * 'c) list -> prop )
  (worker : (a -> 'b))
  (master : (a * 'c -> 'b ->{'e} (a * 'c) list))
  (l : (a * 'c) list)
  : {'e} unit =
  {
    inv cur l /\
    forall (e1 e2 : <'e>) (l1 l2 : (a * 'c) list). inv e1 l1 -> relat [{'e}] e1 l1 e2 l2 -> inv e2 l2
  }
  { r:
    relat_trans [{'e}] old l cur nil /\
    inv cur nil
  }





(* =====================================
computing strategies specifications
======================================== *)



(* =============== map ============ *)
let map (f : a -> b) (l : a list) =
  {}
  letregion r in
  let tasks = let i = ref {{r}} 0 in List.map [{r}] (fun (x:'a) -> {} incr i; x, !i {}) l in
  letregion r2 in
  let results = ref {{r2}} (Hashtbl.create 17) in
  let inv (s : <r r2>) (l1 : (a * int) list) = (* invariant *)
    (Hashtbl.length (!!results@s)) + List.length l1 = List.length l in
  X.compute [{r r2}]
    inv
    f
    (fun tuple r -> Hashtbl.add results (snd tuple) r; nil)
    tasks;
  List.map [{r2}]
    (fun (tuple : a*int) -> {} results := !results (* FIXME : dirty hack *); Hashtbl.find !results (snd tuple) {})
    tasks
  { res:
    (forall (x:a). (List.mem x l -> List.mem (f x) res
        /\ List.length res = List.length l)) /\
    (forall (x:a). (~ (List.mem x l) -> ~ (List.mem (f x) res))) (* redundant ? *)
  }


(* ============= map_local_fold ========= *)
logic logic_fold ['a 'b] : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b

axiom logic_fold_empty ['a 'b]:
  forall (f : 'a -> 'b -> 'b) (l : 'a list) (acc : 'b).
  l = nil -> logic_fold f l acc = acc
axiom logic_fold_basic ['a 'b]: (* recursion *)
  forall (x : 'a) (f : 'a -> 'b -> 'b) (l l2: 'a list) (acc : 'b).
  l = List.cons x l2 -> logic_fold f l acc = f x (logic_fold f l2 acc)



let map_local_fold ['c] (map : a -> b) (fold : 'c -> b -> 'c) (acc : 'c) (l : a list) =
  {}
  letregion r in
  let acc = ref{{r}} acc in
  let inv (s:<r>) (l1 : (a * unit) list) =
    True in (* TODO *)
  X.compute [{r}]
    inv
    map
    (fun _blah (r : b) -> {} acc := fold !acc r; (nil : (a*unit)list) {})
    (List.map [{}] (fun (x : a) -> x, ()) l);
  !acc
  { res:
  [[]] List.map map l [[l_map : res = logic_fold fold l_map acc]]
  }


(*

let map_remote_fold  ~(map : 'a -> 'b) ~(fold : 'c -> 'b -> 'c) acc l =
  let acc = ref (Some acc) in
  let pending = Stack.create () in
  X.compute
    ~worker:(map_fold_wrapper map fold)
    ~master:(fun _ r -> match r with
   | Map r -> begin match !acc with
       | None -> Stack.push r pending; []
       | Some v -> acc := None; [Fold (v, r), ()]
     end
   | Fold r ->
       assert (!acc = None);
       if not (Stack.is_empty pending) then
         [Fold (r, Stack.pop pending), ()]
       else begin
         acc := Some r;
         []
       end)
    (List.map (fun x -> Map x, ()) l);
  (* we are done; the accumulator must exist *)
  match !acc with
    | Some r -> r
    | None -> assert false

let map_fold_ac ~(map : 'a -> 'b) ~(fold : 'b -> 'b -> 'b) acc l =
  let acc = ref (Some acc) in
  X.compute
    ~worker:(map_fold_wrapper2 map fold)
    ~master:(fun _ r ->
   match !acc with
   | None ->
       acc := Some r; []
   | Some v ->
       acc := None;
       [Fold (v, r), ()])
    (List.map (fun x -> Map x, ()) l);
  (* we are done; the accumulator must exist *)
  match !acc with
    | Some r -> r
    | None -> assert false

let map_fold_a ~(map : 'a -> 'b) ~(fold : 'b -> 'b -> 'b) acc l =
  let tasks =
    let i = ref 0 in
    List.map (fun x -> incr i; Map x, (!i, !i)) l
  in
  (* results maps i and j to (i,j,r) for each completed reduction of
     the interval i..j with result r *)
  let results = Hashtbl.create 17 in
  let merge i j r =
    if Hashtbl.mem results (i-1) then begin
let l, h, x = Hashtbl.find results (i-1) in
assert (h = i-1);
Hashtbl.remove results l;
Hashtbl.remove results h;
[Fold (x, r), (l, j)]
    end else if Hashtbl.mem results (j+1) then begin
let l, h, x = Hashtbl.find results (j+1) in
assert (l = j+1);
Hashtbl.remove results h;
Hashtbl.remove results l;
[Fold (r, x), (i, h)]
    end else begin
Hashtbl.add results i (i,j,r);
Hashtbl.add results j (i,j,r);
[]
    end
  in
  X.compute
    ~worker:(map_fold_wrapper2 map fold)
    ~master:(fun x r -> match x with
   | Map _, (i, _) -> merge i i r
   | Fold _, (i, j) -> merge i j r)
    tasks;
  (* we are done; results must contain 2 mappings only, for 1 and n *)
  try let _,_,r = Hashtbl.find results 1 in r with Not_found -> acc


*)
