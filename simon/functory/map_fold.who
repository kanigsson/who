(**************************************************************************)
(*                                                                        *)
(*  Functory: a distributed computing library for Ocaml                   *)
(*  Copyright (C) 2010 Jean-Christophe Filliatre and Kalyan Krishnamani   *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

type map_or_fold ['a 'b] =
  | Map of 'a
  | Fold of 'b

type a
type b

logic worker : a -> b
logic master ['c||'e] : (a * 'c) -> b ->{'e} (a *'c) list

(* TODO : transformer ça en parameter avec spécifications
let map_fold_wrapper map fold = function
  | Map x -> Map (map x)
  | Fold (x, y) -> Fold (fold x y)

let map_fold_wrapper2 map fold = function
  | Map x -> map x
  | Fold (x, y) -> fold x y
*)

(* opérations sur les listes *)
logic mem ['a] : 'a -> 'a list -> prop
logic remove ['a] : 'a -> 'a list -> 'a list
axiom remove_does_remove ['a] :
  forall (x : 'a) (l : 'a list).
    ~ (mem x (remove x l))
logic append ['a] : 'a list -> 'a list -> 'a list
axiom append_does_append ['a] :
  forall (l1 l2 : 'a list) (x : 'a).
    (mem x l1 -> mem x (append l1 l2)) /\
    (mem x l2 -> mem x (append l1 l2))


logic relat ['c||'e] : <'e> -> (a * 'c) list -> <'e> -> (a * 'c) list -> prop
axiom relat_init ['c||'e] : (* une étape de master conserve l'invariant *)
  forall (l1 l2 : (a * 'c) list) (x : a) (y : 'c) (e1 e2 : <'e>).
    (mem (x, y) l1 /\
    [[ cur = e1 ]] master [{'e}] (x, y) (worker x) [[ l : cur = e2 /\ l2 = remove (x, y) (append l l1) ]] )
    -> relat [{'e}] e1 l1 e2 l2

logic relat_trans ['c||'e] : <'e> -> (a * 'c) list -> <'e> -> (a * 'c) list -> prop
axiom relat_trans_reflex ['c||'e] :
  forall (e1 : <'e>) (l1 : (a * 'c) list).
    relat_trans [{'e}] e1 l1 e1 l1
axiom relat_trans_trans ['c||'e] :
  forall (e1 e2 e3 : <'e>) (l1 l2 l3 : (a * 'c) list).
    (relat_trans [{'e}] e1 l1 e2 l2  /\ relat [{'e}] e2 l2 e3 l3)
    -> relat_trans [{'e}] e1 l1 e3 l3


parameter X.compute ['c||'e]
  (inv : <'e> -> (a * 'c) list -> prop )
  (worker : (a -> 'b))
  (master : (a * 'c -> 'b ->{'e} (a * 'c) list))
  (l : (a * 'c) list)
  : {'e} unit =
  {
    inv cur l /\
    forall (e1 e2 : <'e>) (l1 l2 : (a * 'c) list). inv e1 l1 -> relat [{'e}] e1 l1 e2 l2 -> inv e2 l2
  }
  { r:
    relat_trans [{'e}] old l cur nil /\
    inv cur nil
  }



(* structures de données *)
type hashtbl ['a 'b]
logic Hashtbl.add ['a 'b|r|] : ref(r, ('a, 'b) hashtbl) -> 'a -> 'b ->{r} unit
logic Hashtbl.create ['a 'b||] : int ->{} ('a, 'b) hashtbl
logic Hashtbl.mem ['a 'b] : ('a, 'b) hashtbl  -> 'a -> prop
logic Hashtbl.length ['a 'b] : ('a, 'b) hashtbl -> int
parameter Hashtbl.find ['a 'b||] (hshtbl : ('a, 'b) hashtbl) (x : 'a) : {} 'b =
  { Hashtbl.mem hshtbl x }
  {}

axiom hashtbl_empty_lengh ['a 'b|r|] : 
  forall (n: int).
  [[]] Hashtbl.create n [[res : (Hashtbl.length res) = 0 /\ forall (x:'a). ~ (Hashtbl.mem res x)]] 
(* adding an item to a hashtbl makes this item member of the later *)
axiom hashtbl_add ['a 'b|r|] :
  forall (x : 'a) (y : 'b) (hshtbl : ref(r, ('a, 'b) hashtbl)).
  [[]] Hashtbl.add hshtbl x y [[Hashtbl.mem !!hshtbl x]]
(* adding an item to a hastable increments its length *)
axiom hashtbl_add_length ['a 'b|r|] :
  forall (x : 'a) (y : 'b) (hshtbl : ref(r, ('a, 'b) hashtbl)).
  [[~ (Hashtbl.mem !!hshtbl x)]] Hashtbl.add hshtbl x y [[(Hashtbl.length !!hshtbl) = (Hashtbl.length !!hshtbl@old) +1]]

logic List.map ['a 'b||'e] : ('a ->{'e} 'b) -> 'a list ->{'e} 'b list
logic List.length ['a] : 'a list -> int

logic incr [|r|] : ref(r, int) ->{r} unit
axiom incr_increments [|r|] :
  forall (s : ref(r, int)).
  [[]] incr s [[!!s = ((!!s@old) + 1)]]


(* specifications des stratégies de calcul *)
let map (f : a -> b) (l : a list) = 
  {}
  letregion r in 
  let tasks = let i = ref {{r}} 0 in List.map [{r}] (fun x -> incr i; x, !i) l in
  letregion r2 in 
  let results = ref {{r2}} (Hashtbl.create 17) in
  let inv (s : <r r2>) (l1 : (a * int) list) = (* invariant *)
    (Hashtbl.length (!!results@s)) + List.length l1 = List.length l in
  X.compute [{r r2}]
    inv
    f
    (fun tuple r -> Hashtbl.add results (snd tuple) r; nil)
    tasks;
  List.map [{}] (fun tuple -> Hashtbl.find !results (snd tuple)) tasks
  {
  }


(*
let map_local_fold ~(map : 'a -> 'b) ~(fold : 'c -> 'b -> 'c) acc l =
  let acc = ref acc in
  X.compute
    ~worker:map
    ~master:(fun _ r -> acc := fold !acc r; [])
    (List.map (fun x -> x, ()) l);
  !acc

let map_remote_fold  ~(map : 'a -> 'b) ~(fold : 'c -> 'b -> 'c) acc l =
  let acc = ref (Some acc) in
  let pending = Stack.create () in
  X.compute
    ~worker:(map_fold_wrapper map fold)
    ~master:(fun _ r -> match r with
   | Map r -> begin match !acc with
       | None -> Stack.push r pending; []
       | Some v -> acc := None; [Fold (v, r), ()]
     end
   | Fold r ->
       assert (!acc = None);
       if not (Stack.is_empty pending) then
         [Fold (r, Stack.pop pending), ()]
       else begin
         acc := Some r;
         []
       end)
    (List.map (fun x -> Map x, ()) l);
  (* we are done; the accumulator must exist *)
  match !acc with
    | Some r -> r
    | None -> assert false

let map_fold_ac ~(map : 'a -> 'b) ~(fold : 'b -> 'b -> 'b) acc l =
  let acc = ref (Some acc) in
  X.compute
    ~worker:(map_fold_wrapper2 map fold)
    ~master:(fun _ r ->
   match !acc with
   | None ->
       acc := Some r; []
   | Some v ->
       acc := None;
       [Fold (v, r), ()])
    (List.map (fun x -> Map x, ()) l);
  (* we are done; the accumulator must exist *)
  match !acc with
    | Some r -> r
    | None -> assert false

let map_fold_a ~(map : 'a -> 'b) ~(fold : 'b -> 'b -> 'b) acc l =
  let tasks =
    let i = ref 0 in
    List.map (fun x -> incr i; Map x, (!i, !i)) l
  in
  (* results maps i and j to (i,j,r) for each completed reduction of
     the interval i..j with result r *)
  let results = Hashtbl.create 17 in
  let merge i j r =
    if Hashtbl.mem results (i-1) then begin
let l, h, x = Hashtbl.find results (i-1) in
assert (h = i-1);
Hashtbl.remove results l;
Hashtbl.remove results h;
[Fold (x, r), (l, j)]
    end else if Hashtbl.mem results (j+1) then begin
let l, h, x = Hashtbl.find results (j+1) in
assert (l = j+1);
Hashtbl.remove results h;
Hashtbl.remove results l;
[Fold (r, x), (i, h)]
    end else begin
Hashtbl.add results i (i,j,r);
Hashtbl.add results j (i,j,r);
[]
    end
  in
  X.compute
    ~worker:(map_fold_wrapper2 map fold)
    ~master:(fun x r -> match x with
   | Map _, (i, _) -> merge i i r
   | Fold _, (i, j) -> merge i j r)
    tasks;
  (* we are done; results must contain 2 mappings only, for 1 and n *)
  try let _,_,r = Hashtbl.find results 1 in r with Not_found -> acc


*)
