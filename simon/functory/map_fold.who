(**************************************************************************)
(*                                                                        *)
(*  Functory: a distributed computing library for Ocaml                   *)
(*  Copyright (C) 2010 Jean-Christophe Filliatre and Kalyan Krishnamani   *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(* ====================================
data struct (* TODO *)
======================================= *)

(* ============ hash tables =========== *)
type hashtbl ['a 'b]
logic Hashtbl.add ['a 'b|r|] : ref(r, ('a, 'b) hashtbl) -> 'a -> 'b ->{r} unit
logic Hashtbl.create ['a 'b||] : int ->{} ('a, 'b) hashtbl
logic Hashtbl.mem ['a 'b] : ('a, 'b) hashtbl  -> 'a -> prop
logic Hashtbl.length ['a 'b] : ('a, 'b) hashtbl -> int
parameter Hashtbl.find ['a 'b||] (hshtbl : ('a, 'b) hashtbl) (x : 'a) : {} 'b =
  { Hashtbl.mem hshtbl x }
  {}

axiom hashtbl_empty_lengh ['a 'b|r|] :
  forall (n: int).
  [[]] (Hashtbl.create n : ('a, 'b) hashtbl) [[res : (Hashtbl.length res) = 0 /\ forall (x:'a). ~ (Hashtbl.mem res x)]]
(* adding an item to a hashtbl makes this item member of the later *)
axiom hashtbl_add ['a 'b|r|] :
  forall (x : 'a) (y : 'b) (hshtbl : ref(r, ('a, 'b) hashtbl)).
  [[]] Hashtbl.add hshtbl x y [[Hashtbl.mem !!hshtbl x]]
(* adding an item to a hastable increments its length *)
axiom hashtbl_add_length ['a 'b|r|] :
  forall (x : 'a) (y : 'b) (hshtbl : ref(r, ('a, 'b) hashtbl)).
  [[~ (Hashtbl.mem !!hshtbl x)]] Hashtbl.add hshtbl x y [[(Hashtbl.length !!hshtbl) = (Hashtbl.length !!hshtbl@old) +1]]
axiom hashtbl_add_find ['a 'b|r|] :
  forall (x : 'a) (y : 'b) (hshtbl : ref(r,('a, 'b) hashtbl)).
  [[]] Hashtbl.add hshtbl x y  [[ [[]] Hashtbl.find !hshtbl x [[ r: r = y ]] ]]


(* ============ lists ============= *)
logic List.mem ['a] : 'a -> 'a list -> prop
logic List.remove ['a] : 'a -> 'a list -> 'a list
logic List.length ['a] : 'a list -> int
logic List.append ['a] : 'a list -> 'a list -> 'a list
logic List.index ['a] : int -> 'a list -> 'a
logic List.head ['a] : 'a list -> 'a
logic List.tail ['a] : 'a list -> 'a list

logic fromCons ['a] : 'a list -> ('a * 'a list)
axiom from_cons_normal ['a] :
  forall (l l2 : 'a list) (x : 'a).
  l = Cons x l2 -> fromCons l = (x, l2)
axiom list_head ['a] :
  forall (l l2: 'a list) (x: 'a).
  l = Cons x l2 -> List.head l = x
axiom list_tail ['a] :
  forall (l l2: 'a list) (x: 'a).
  l = Cons x l2 -> List.tail l = l2

(*parameter fromCons ['a] (l : 'a list) : {} ('a * 'a list) =
  { ~ (l = Nil) }
  { res:
    exists (x : 'a) (l2 : 'a list).
    l = List.cons x l2 /\ res = (x, l2)
  }*)

(* spec of List.map. It takes a relationship rel in arg, which describe a bound between
the arg list, the state before call, the state after call and the result list *)
parameter List.map ['a 'b||'e] (rel : 'a list -> <'e> -> <'e> -> 'b list -> prop) (f : 'a ->{'e} 'b) (l : 'a list) : {'e} 'b list =
  {
    (~ (l = Nil) -> pre f (List.head l) cur) /\ (* precondition of f on head of list *)
    (forall (x2 : 'a) (l1 l2 : 'a list) (res_l2 : 'b list) (s0 s1 s2:<'e>). l1 = Cons x2 l2 ->
      [[cur = s0 /\ rel l2 s1 s2 res_l2]] f x2 [[res : cur = s1 -> rel l1 s0 s2 (Cons res res_l2)]]) (* propagate relationship *)
  }
  { res:
    (l = Nil -> res = Nil /\ cur = old) /\ (* terminal case *)
    (~ (l=Nil) -> (~ (res = Nil))) /\
    rel l old cur res
      (* [[cur = s1 /\ rel l2 s2 s3 (List.tail res)]] f x [[r : r = List.head res /\ (cur = s2 -> rel l old s3 res)]]) TODO delete *)
    (* this means, roughly : rel (List.map f (tail l)) -> rel (List.map f l) *)
  }
(*
  l =             [x]--------------->l2
  states : s1=old         s2               s3
              \          / \               /
               \-> f x -/   \-> map f l2 -/

                            `------------'
                            rel l2 s1 s2 (tail res)
====>
              `--------------------------'
                  rel l old s2 res
*)

axiom remove_does_remove ['a] :
  forall (x : 'a) (l l2 : 'a list).
  l = Cons x l2 -> List.remove x l = l2
axiom append_does_append ['a] :
  forall (l1 l2 : 'a list) (x : 'a).
  (List.mem x l1 -> List.mem x (List.append l1 l2)) /\
  (List.mem x l2 -> List.mem x (List.append l1 l2))
axiom append_cons_list ['a] :
  forall (x:'a) (l1 l2: 'a list).
  l1 = Cons x Nil -> List.append l1 l2 = Cons x l2
axiom append_list_list ['a] :
  forall (x:'a) (l1 l2 l3: 'a list).
  l1 = Cons x l2 -> List.append l1 l3 = Cons x (List.append l2 l3)
axiom list_length_map ['a 'b||'e]:
  forall (l:'a list) (f:'a ->{'e} 'b) (rel: 'a list -> <'e> -> <'e> -> 'b list -> prop).
  [[]] List.map [{'e}] rel f l [[res : List.length l = List.length res]]
(* (map f l)[i] = f l[i] *)
axiom list_index_map ['a 'b||'e] :
  forall (x:'a) (l:'a list) (i:int) (f:'a ->{'e} 'b) (rel: 'a list -> <'e> -> <'e> -> 'b list -> prop).
  i >= 0 /\ i < List.length l ->
  [[]] List.map [{'e}] rel f l [[res: [[]] f (List.index i l)[[r : r = List.index i res]] ]]
axiom list_not_empty_is_cons ['a]:
  forall (l:'a list).
  ~ (l=Nil) -> exists (x:'a) (l2:'a list).
    (l = Cons x l2)
axiom list_cons_mem ['a]:
  forall (x:'a) (l:'a list).
  List.mem x (Cons x l)
axiom list_cons_mem_tail ['a]:
  forall (x:'a) (l:'a list).
  (forall (y:'a). List.mem y l -> List.mem y (Cons x l))
axiom list_cons_length_tail ['a]:
  forall (x:'a) (l:'a list).
  (List.length (Cons x l) = List.length l + 1)
axiom list_index ['a]:
  forall (i : int) (x : 'a) (l l2: 'a list).
  i = 0 -> l = Cons x l2 -> List.index i l = x
axiom list_index_rec ['a]:
  forall (i : int) (x : 'a) (l l2: 'a list).
  i > 0 /\ i < List.length l -> l = Cons x l2 -> List.index i l = List.index (i-1) l2




(* =========== refs ========== *)

logic incr [|r|] : ref(r, int) ->{r} unit
axiom incr_increments [|r|] :
  forall (s : ref(r, int)).
  [[]] incr s [[!!s = ((!!s@old) + 1)]]

(* ================== special data =================== *)
type map_or_fold ['a 'b] =
  | Map of 'a
  | Fold of 'b

logic is_map ['a 'b] : ('a, 'b) map_or_fold -> prop
logic is_fold ['a 'b] : ('a, 'b) map_or_fold -> prop
axiom is_map_map ['a 'b] :
  forall (x : 'a) (y : ('a, 'b) map_or_fold).
  y = Map x -> (is_map y /\ ~(is_fold y))
axiom is_not_map_fold ['a 'b] :
  forall (x : 'b) (y : ('a, 'b) map_or_fold).
  y = Fold x -> ((~ (is_map y)) /\ is_fold y)

logic fromMap ['a 'b] : (('a, 'b) map_or_fold) -> 'a
logic fromFold ['a 'b] : (('a, 'b) map_or_fold) -> 'b
axiom from_map ['a 'b] :
  forall (x : ('a, 'b) map_or_fold) (y : 'a).
  is_map x -> x = Map y -> (fromMap x = y)
axiom from_fold ['a 'b] :
  forall (x : ('a, 'b) map_or_fold) (y : 'b).
  is_fold x -> x = Fold y -> (fromFold x = y)



parameter map_fold_wrapper ['a 'b 'c 'd 'e]
  (map : ('a -> 'e))
  (fold : ('b -> 'c -> 'd))
  (truc : ('a, ('b * 'c)) map_or_fold) : {} ('e, 'd) map_or_fold =
  {}
  { res:
    ((is_map truc) -> res = Map (map (fromMap truc))) /\
    ((is_fold truc) -> res = Fold (fold (fst (fromFold truc)) (snd (fromFold truc))))
  }

parameter map_fold_wrapper2 ['a 'b 'c 'd 'e]
  (map : 'a -> 'd)
  (fold : 'b -> 'c -> 'd)
  (truc : ('a, ('b * 'c)) map_or_fold) : {} 'd =
  {}
  { res:
    (is_map truc -> res = map (fromMap truc)) /\
    (is_fold truc -> res = fold (fst (fromFold truc)) (snd (fromFold truc)))
  }

(*
let map_fold_wrapper map fold = function
  | Map x -> Map (map x)
  | Fold (x, y) -> Fold (fold x y)

let map_fold_wrapper2 map fold = function
  | Map x -> map x
  | Fold (x, y) -> fold x y
*)

(* =============================
master and worker specs
================================ *)

type a
type b
logic worker : a ->{} b
logic master ['c||'e] : (a * 'c) -> b ->{'e} (a *'c) list

(* relation *)
logic relat ['c||'e] : <'e> -> (a * 'c) list -> <'e> -> (a * 'c) list -> prop
axiom relat_init ['c||'e] : (* one step of worker does keep the invariant *)
  forall (l1 l2 : (a * 'c) list) (x : a) (y : 'c) (e1 e2 : <'e>).
  (List.mem (x, y) l1 /\
  [[ cur = e1 ]] master [{'e}] (x, y) (worker x) [[ l : cur = e2 /\ l2 = List.remove (x, y) (List.append l l1) ]] )
  -> relat [{'e}] e1 l1 e2 l2

(* transitive reflective closure *)
logic relat_trans ['c||'e] : <'e> -> (a * 'c) list -> <'e> -> (a * 'c) list -> prop
axiom relat_trans_reflex ['c||'e] :
  forall (e1 : <'e>) (l1 : (a * 'c) list).
    relat_trans [{'e}] e1 l1 e1 l1
axiom relat_trans_trans ['c||'e] :
  forall (e1 e2 e3 : <'e>) (l1 l2 l3 : (a * 'c) list).
    (relat_trans [{'e}] e1 l1 e2 l2  /\ relat [{'e}] e2 l2 e3 l3)
    -> relat_trans [{'e}] e1 l1 e3 l3


parameter X.compute ['c||'e]
  (inv : <'e> -> (a * 'c) list -> prop )
  (worker : (a -> 'b))
  (master : (a * 'c -> 'b ->{'e} (a * 'c) list))
  (l : (a * 'c) list)
  : {'e} unit =
  {
    inv cur l /\
    forall (e1 e2 : <'e>) (l1 l2 : (a * 'c) list). inv e1 l1 -> relat [{'e}] e1 l1 e2 l2 -> inv e2 l2
  }
  { r:
    relat_trans [{'e}] old l cur Nil /\
    inv cur Nil
  }


(* =============================
tests
================================ *)

let test1 (f : int -> b) (l : int list) =
  {
    exists (l2 : int list). l = Cons 1 l2
  }
  letregion t in
  let r = ref (t) 0 in
  let rel (l_old : int list) (s1:<t>) (s2:<t>) (l_res : b list) =
    (List.length l_old + !!r@s1 = List.length l_res + !!r@s2 /\
    !!r@s2 = !!r@s1 + 1 /\ !!r@s2 = List.length l_res+1) in
  let answer = List.map [{t}] rel (fun (x:int) ->{} incr r; f x {}) l in
  (answer, !r)
  {res:
    (*snd res = List.length l+1 /\*)
    exists (l2 : int list). l = Cons 1 l2 ->
      let rel (l_old : int list) (s1:< >) (s2:< >) (l_res : b list) = True in
      [[]] List.map [{}] rel (fun (x:int) ->{} f x {}) l2 [[r: (fst res) = Cons (f 1) r]]
  }
(*
let test2 (l : int list) =
  {}
  letregion t in
  let r = ref(t) 0 in
  let rel (l_old : int list) (s1:<t>) (s2:<t>) (l_res : int list) =
    List.length l_old + !!r@s1 = List.length l_res + !!r@s2 in
  List.map [{t}] rel (fun (x:int) ->{} r := !r + 1; !r {}) l
  { res:
    forall (j:int).
    0 <= j /\ j < List.length l -> List.index j res = j+1
  }
*)
(* =====================================
computing strategies specifications
======================================== *)

(*

(* =============== map ============ *)
let map (f : a -> b) (l : a list) =
  {}
  letregion r in
  let tasks =
    let i = ref (r) 0 in
    let inv (s:<r>) (ll:a list) = !!i@s + List.length ll = List.length l in
    List.map [{r}] inv (fun (x:'a) -> {} incr i; x, !i {}) l in
  letregion r2 in
  let results = ref (r2) (Hashtbl.create 17) in
  let inv (s : <r2>) (l1 : (a * int) list) = (* invariant *)
    (Hashtbl.length (!!results@s)) + List.length l1 = List.length l /\
    (forall (i:int).
      [[Hashtbl.mem !!results@s i]] Hashtbl.find !results i [[res : res = f (List.index (i-1) l) ]])
  in
  X.compute [{r2}]
    inv
    f
    (fun (tuple : (a*int)) (r : b) ->{} Hashtbl.add results (snd tuple) r; Nil {})
    tasks;
  List.map [{r2}]
    (fun (s:<r2>) (ll:(a*int) list) -> (~(ll=Nil) -> (snd (fst (fromCons ll))) + List.length ll = List.length l + 1))
    (fun (tuple : a*int) -> {} results := !results; (* FIXME : dirty hack *) Hashtbl.find !results (snd tuple) {})
    tasks
  { res:
    List.length res = List.length l /\
    [[]] List.map [{}] (fun (s:< >)(ll:a list) -> True) (fun (x:a) ->{} f x {}) l [[ r : r = res ]] /\
    (forall (x:a). [[List.mem x l]] f x [[r : List.mem r res]])
  }

(* ============= map_local_fold ========= *)
logic logic_fold ['a 'b] : ('b -> 'a -> 'b) -> 'b -> 'a list -> 'b

axiom logic_fold_empty ['a 'b]:
  forall (f : 'b -> 'a -> 'b) (l : 'a list) (acc : 'b).
  l = Nil -> logic_fold f acc l = acc
axiom logic_fold_basic ['a 'b]: (* recursion *)
  forall (x : 'a) (f : 'b -> 'a -> 'b) (l l2: 'a list) (acc : 'b).
  l = Cons x l2 -> logic_fold f acc l = f (logic_fold f acc l2) x



let map_local_fold ['c] (map : a -> b) (fold : 'c -> b -> 'c) (acc : 'c) (l : a list) =
  {}
  letregion r in
  let acc = ref (r) acc in
  let inv (s:<r>) (l1 : (a * unit) list) =
    True in (* TODO *)
  X.compute [{r}]
    inv
    map
    (fun (_ : (a*unit)) (r : b) -> {} acc := (fold !acc r); Nil {})
    (List.map [{}] (fun (x : a) -> {} x, () {}) l);
  !acc
  { res:
  [[]] List.map [{}] map l [[l_map : res = logic_fold fold acc l_map]]
  }




let map_remote_fold  ~(map : 'a -> 'b) ~(fold : 'c -> 'b -> 'c) acc l =
  let acc = ref (Some acc) in
  let pending = Stack.create () in
  X.compute
    ~worker:(map_fold_wrapper map fold)
    ~master:(fun _ r -> match r with
   | Map r -> begin match !acc with
       | None -> Stack.push r pending; []
       | Some v -> acc := None; [Fold (v, r), ()]
     end
   | Fold r ->
       assert (!acc = None);
       if not (Stack.is_empty pending) then
         [Fold (r, Stack.pop pending), ()]
       else begin
         acc := Some r;
         []
       end)
    (List.map (fun x -> Map x, ()) l);
  (* we are done; the accumulator must exist *)
  match !acc with
    | Some r -> r
    | None -> assert false

let map_fold_ac ~(map : 'a -> 'b) ~(fold : 'b -> 'b -> 'b) acc l =
  let acc = ref (Some acc) in
  X.compute
    ~worker:(map_fold_wrapper2 map fold)
    ~master:(fun _ r ->
   match !acc with
   | None ->
       acc := Some r; []
   | Some v ->
       acc := None;
       [Fold (v, r), ()])
    (List.map (fun x -> Map x, ()) l);
  (* we are done; the accumulator must exist *)
  match !acc with
    | Some r -> r
    | None -> assert false

let map_fold_a ~(map : 'a -> 'b) ~(fold : 'b -> 'b -> 'b) acc l =
  let tasks =
    let i = ref 0 in
    List.map (fun x -> incr i; Map x, (!i, !i)) l
  in
  (* results maps i and j to (i,j,r) for each completed reduction of
     the interval i..j with result r *)
  let results = Hashtbl.create 17 in
  let merge i j r =
    if Hashtbl.mem results (i-1) then begin
let l, h, x = Hashtbl.find results (i-1) in
assert (h = i-1);
Hashtbl.remove results l;
Hashtbl.remove results h;
[Fold (x, r), (l, j)]
    end else if Hashtbl.mem results (j+1) then begin
let l, h, x = Hashtbl.find results (j+1) in
assert (l = j+1);
Hashtbl.remove results h;
Hashtbl.remove results l;
[Fold (r, x), (i, h)]
    end else begin
Hashtbl.add results i (i,j,r);
Hashtbl.add results j (i,j,r);
[]
    end
  in
  X.compute
    ~worker:(map_fold_wrapper2 map fold)
    ~master:(fun x r -> match x with
   | Map _, (i, _) -> merge i i r
   | Fold _, (i, j) -> merge i j r)
    tasks;
  (* we are done; results must contain 2 mappings only, for 1 and n *)
  try let _,_,r = Hashtbl.find results 1 in r with Not_found -> acc


*)
