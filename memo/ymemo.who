type ('a,'b) map
logic mem : forall ('a, 'b) . 'a -> ('a,'b) map -> bool
logic get : forall ('a, 'b) . 'a -> ('a,'b) map -> 'b
logic set : forall ('a, 'b) . 'a -> 'b -> ('a,'b) map -> ('a,'b) map

use (table : (int,int) map)

logic stores : (int -> int) -> <table> -> prop
logic realizes : 
  (int -> int) -> 
  (int -> <table> -> prop) * (int -> <table> -> <table> -> int -> prop) ->
  prop

let ymemo (f0 : int -> int) (ff : (int ->{table} int) ->{} int ->{table} int) = 
  { 
    forall 
      (k r : (int -> <table> -> prop) * (int -> <table> -> <table> -> int -> prop)).
      realizes f0 k -> (pre ff k /\ (post ff k r -> realizes f0 r))}
  let rec f (x : int) : int ->{table} int =
    { stores f0 cur }
    if mem [|int,int|] x !table then get [|int,int|] x !table
    else
      let z = ff f x in
      let () = table := set [|int,int|] x z !table in
      z
    {r : r = f0 x /\ stores f0 cur}
  in
  f
  { rf : realizes f0 rf }
      
logic Fib : int -> int
axiom fib_zero : forall (n:int). n <= 1 -> Fib n = 1
axiom fib_succ : forall (n:int). 1 < n -> Fib n = Fib (n-1) + Fib (n-2)

logic arg : int

let main () = 
  { stores Fib cur }
  ymemo Fib
  (fun (f : int ->{table} int) (n : int) ->
    { stores Fib cur /\ realizes Fib f }
    if n <= 1 then 1 else f (n-1) + f (n-2)
    {r : r = Fib n /\ stores Fib cur}
  ) arg
  {r : r = Fib arg}
  
