(*
let map f a =
  let l = length a in
  if l = 0 then [||] else begin
    let r = create l (f(unsafe_get a 0)) in
    for i = 1 to l - 1 do
      unsafe_set r i (f(unsafe_get a i))
    done;
    r
  end

*)

logic sub ['a||] : 'a array -> int -> 'a array

axiom sub_equal ['a||] : 
  forall (i k : int) (a : 'a array).
    0 <= k  /\ k < i /\
    0 <= k /\ k < len a ->
    get k (sub a i) = get k a

axiom sub_length_1 ['a||] : 
  forall (i : int) (a : 'a array).
    0 <= i /\ i <= len a -> len (sub a i) = i
    
axiom sub_length_2 ['a||] : 
  forall (i : int) (a : 'a array).
    i > len a -> len (sub a i) = len a

axiom sub_ident ['a||] :
  forall (a : 'a array).  sub a (len a) = a

axiom set_equal ['a] :
  forall (a : 'a array) (i l : int) (k : 'a).
    0 <= i -> i < l -> get i a = k -> set i k a = a

let map ['a 'b|in_ out|'e] 
  (inv : <in_ 'e> -> 'a array -> int -> prop) 
  (ar : ref(in_, 'a array)) (f : 'a ->{in_ 'e} 'a)  = allocates out
  { 
    inv cur|{in_ 'e} ar_empty 0 /\
     [[ ]] f (get 0 !ar) [[ k : forall (r : 'a array). inv cur (sub (set 0 k r) 1) 1 ]] /\
    forall (k : 'a array) (i:int).
      1 <= i -> i < len !!ar ->
    [[ inv cur (sub k i) i ]] f (get i !ar) [[ r: inv cur (sub (set i r k) (i+1)) (i+1) ]]
  }
  let l = len !ar in
  if l == 0 then ref{{out}} ar_empty
  else
    let k = f (get 0 !ar) in
    let r = ref{{out}} (create l k) in
    assert ( !r = set 0 k !r);
    assert ( sub !r 1 = sub (set 0 k !r) 1);
    (for i = 1 to l - 1 do 
      { inv cur|{in_ 'e} (sub !!r i) i /\ len !!r = l }
      r := set i (f (get i !ar)) !r
    done) ;
    r
  {r : inv cur|{in_ 'e} !!r (len !!ar|old) }


(*
predicate inv (k : int, a : int farray, b : int farray) =
  forall i : int. 0 < i <= k -> sumarray(a,i) = access(b,i-1)

let _ = 
  let s = ref 0 in
  Array.map 
    (fun s i -> inv k a|s ??  )
    (fun x -> 
      {} 
      s := !s + x; !s
      {r : !s = !s|old + x /\ r = !s }) a
  {}

  *)
