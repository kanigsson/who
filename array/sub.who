type 'a array

logic get : forall 'a. int -> 'a array -> 'a
logic set : forall 'a. int -> 'a -> 'a array -> 'a array
logic length : forall 'a. 'a array -> int
logic create : forall 'a. int -> 'a array

axiom update_length : 
  forall 'a. forall (t : 'a array) (i : int) (z : 'a).
    length [| 'a|] t = length [|'a|] (set [|'a|] i z t)

axiom get_set_eq : 
  forall 'a. forall (t : 'a array) (i : int) (z : 'a).
    i < length [|'a|] t -> get [|'a|] i (set [|'a|] i z t) = z

axiom get_set_neq : 
  forall 'a. forall (t : 'a array) (i : int) (j : int) (z : 'a).
    i < length [|'a|] t -> j < length [|'a|] t -> i <> j -> 
    get [|'a|] i (set [|'a|] j z t) = get [|'a|] i t

axiom length_nonnegative : 
  forall 'a. forall (t : 'a array).  0 <= length [|'a|] t

axiom length_create : 
  forall 'a. forall (l : int). 0 <= l -> length [|'a|] (create [|'a|] l) = l

predicate identical ['a] (x y : 'a array) = 
  length [|'a|] x = length [|'a|] y /\ 
    forall (k : int).
      0 <= k -> k < length [|'a|] x -> get [|'a|] k x = get [|'a|] k y

let sub [|'a|(x : 'a array) (out : 'a array)] cap(out) 
             (ar : ref(x)) (ofs len : int) =
  { 0 <= ofs /\ 0 <= len /\ ofs + len <= length [|'a|] ar }
  let res = ref{out} (create [|'a|] len) in
  let oldar = !ar in
  let () = 
    for i = 0 to len - 1 do
      {identical [|'a|] oldar ar /\ length [|'a|] res = len /\
        forall (k:int). 0 <= k -> k < i -> 
                          get [|'a|] k res = get [|'a|] (ofs + k) ar }
      res := set [|'a|] i (get [|'a|] (ofs + i) !ar) !res
    done in
  res
  {identical [|'a|] ar|old ar /\ length [|'a|] out = len /\
        forall (k:int). 0 <= k -> k < len -> 
                          get [|'a|] k out = get [|'a|] (ofs + k) ar }

(* let sub a ofs len =
  if ofs < 0 || len < 0 || ofs > length a - len then invalid_arg "Array.sub"
  else if len = 0 then [||]
  else begin
    let r = create len (unsafe_get a ofs) in
    for i = 1 to len - 1 do unsafe_set r i (unsafe_get a (ofs + i)) done;
    r
  end *)
