let iter ['a|r|'e] 
  (inv : <r 'e> -> int ->  prop) 
  (ar : ref(r, 'a array)) (f : 'a ->{r 'e} unit)  =
  { inv cur 0 /\ 
    forall (i:int). 0 <= i /\ i < len (!!ar) ->
    forall (m : <r 'e>). 
      inv m i -> pre f (get i !!ar|m) m /\
    forall (n : <r 'e>).  
      post f (get i !!ar|m) m n () -> inv n (i+1)
  }
  for i = 0 to len !ar - 1 do 
    { inv cur i }
    f (get i !ar)
  done
  {inv cur (len !!ar|old) }

logic sum_array : int -> int array -> int
axiom sum_array_none : 
  forall (t : int array). sum_array 0 t = 0
axiom sum_array_step : 
  forall (t : int array) (i : int). 
    0 <= i -> i < len t ->
    sum_array (i+1) t = sum_array i t + get i t

region ar
parameter arr : ref(ar,int array)

let main (z : unit) =
  {}
  letregion r in
  let sum = ref{{r}} 0 in
  let arrcur = !arr in
  iter 
    (fun (s : <ar r>) (k : int) -> 
        !!sum|s = sum_array k !!arr|s /\ !!arr|s = arrcur)
    arr
    (fun (z : int) -> {} sum := !sum + z { !!sum = !!sum|old + z})
    ;
  !sum
  {r : r = sum_array (len !!arr) !!arr /\ !!arr = !!arr|old  }
