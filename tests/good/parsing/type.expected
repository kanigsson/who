section basiclogic Coq 
 let /\ = logic Prop -> Prop -> Prop in
 let \/ = logic Prop -> Prop -> Prop in
 let -> = logic Prop -> Prop -> Prop in
 let ~ = logic Prop -> Prop in
 let = [a||]= logic a -> a -> Prop in
 let <> [a1||]= logic a1 -> a1 -> Prop in
 let fst [a2 b||]= logic (a2 * b) -> a2 in
 let snd [a3 b1||]= logic (a3 * b1) -> b1 in
 let , [a4 b2||]= logic a4 -> b2 -> a4 * b2 in end
  section arith Coq WhoArith
   let + = logic int -> int -> int in
   let - = logic int -> int -> int in
   let * = logic int -> int -> int in
   let < = logic int -> int -> Prop in
   let <= = logic int -> int -> Prop in
   let > = logic int -> int -> Prop in
   let >= = logic int -> int -> Prop in
   let << = logic int -> int -> bool in
   let <<= = logic int -> int -> bool in
   let >> = logic int -> int -> bool in
   let >>= = logic int -> int -> bool in
   let max = logic int -> int -> int in
   let min = logic int -> int -> int in
   let mod = logic int -> int -> int in end
    let == [a5||]= logic a5 -> a5 -> bool in
    let != [a6||]= logic a6 -> a6 -> bool in
    section Whoref Coq WhoMap
     let !! [a7|r|e]= logic ref a7 r -> <{|e }> -> a7 in
     let
     ! [a8|r1|]=
                (λ(x:ref a8 r1) -->  param(a8,{r1 |})
                { r2 : ((!! x cur) = r2) /\ ((!! x old) = (!! x cur))})
     in
     let
     := [a9|r3|]=
                 (λ(x1:ref a9 r3) ->
                 (λ(v:a9) -->  param(unit,{r3 |}) {(!! x1 cur1) = v}))
     in
     let
     ref [a10|r4|]=
                   (λ(v1:a10) -->  param(ref a10 r4,{r4 ||r4 })
                   { x2 : (!! x2 cur2) = v1})
     in
     let combine [||e1 e2]= logic <{|e1 }> -> <{|e2 }> -> <{|e1 e2 }> in
     let restrict [||e11 e21]= logic <{|e11 }> -> <{|e21 }> in
     let empty = logic <{|}> in type kmap =  in type key =  in
     let kcombine [||e12 e22]= logic (kmap) -> (kmap) -> kmap in
     let krestrict [||e13 e23]= logic (kmap) -> kmap in
     let kset [a11||]= logic (key) -> a11 -> (kmap) -> kmap in
     let kget [a12|r5|]= logic ref a12 r5 -> (kmap) -> a12 in
     let kempty = logic kmap in
     let pre [a13 b3||]= (λ(x3:a13 * b3) -> fst x3) in
     let post [a14 b4||]= (λ(x4:a14 * b4) -> snd x4) in end
      let
      forto [||e1]=
                   (λ(inv:int -> <{|e1 }> -> Prop) ->
                   (λ(start:int) ->
                   (λ(end_:int) ->
                   (λ(f:int --> unit) -->
                   {(inv start cur3) /\
                    (forall (i:int),
                     ((start <= i) /\ (i <= end_)) ->
                     (forall (m:<{|e1 }>),
                      (inv i m) ->
                      ((pre f i m) /\
                       (forall (n:<{|e1 }>),
                        (post f i m n tt) -> (inv (i + 1) n)))))}
                   param(unit,{|e1 }) {inv (max start (end_ + 1)) cur4}))))
      in
      let
      fordownto [||e2]=
                       (λ(inv1:int -> <{|e2 }> -> Prop) ->
                       (λ(start1:int) ->
                       (λ(end_1:int) ->
                       (λ(f1:int --> unit) -->
                       {(inv1 start1 cur5) /\
                        (forall (i1:int),
                         ((start1 <= i1) /\ (i1 <= end_1)) ->
                         (forall (m1:<{|e2 }>),
                          (inv1 i1 m1) ->
                          ((pre f1 i1 m1) /\
                           (forall (n1:<{|e2 }>),
                            (post f1 i1 m1 n1 tt) -> (inv1 (i1 - 1) n1)))))}
                       param(unit,{|e2 })
                       {inv1 (min start1 (end_1 - 1)) cur6}))))
      in
      section Array Coq WhoArray type array[a15||] =  in
      let get [a16||]= logic int -> (array a16) -> a16 in
      let set [a17||]= logic int -> a17 -> (array a17) -> array a17 in
      let len [a18||]= logic (array a18) -> int in
      let
      update_length [a19||]=
                            axiom forall (t:array a19),
                                  forall (i2:int),
                                  forall (z:a19),
                                  (len t) = (len (set i2 z t))
      in
      let
      get_set_eq [a20||]=
                         axiom forall (t1:array a20),
                               forall (i3:int),
                               forall (z1:a20),
                               (i3 < (len t1)) ->
                               ((get i3 (set i3 z1 t1)) = z1)
      in
      let
      get_set_neq [a21||]=
                          axiom forall (t2:array a21),
                                forall (i4:int),
                                forall (j:int),
                                forall (z2:a21),
                                (i4 < (len t2)) ->
                                ((j < (len t2)) ->
                                 ((i4 <> j) ->
                                  ((get i4 (set j z2 t2)) = (get i4 t2))))
      in
      let
      length_nonnegative [a22||]= axiom forall (t3:array a22), 0 <= (len t3)
      in end
       section List Coq WhoList type list[a23||] =  in
       let nil [a24||]= logic list a24 in
       let cons [a25||]= logic a25 -> (list a25) -> list a25 in
       let is_nil [a26||]= logic (list a26) -> bool in
       let l_in [a27||]= logic a27 -> (list a27) -> Prop in end
        type list1[a28||] =  in tt     
