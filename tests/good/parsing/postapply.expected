type unit
logic tt  : unit
logic = ['a||] : a -> a -> prop
logic fst ['a 'b||] : (a * b) -> a
logic snd ['a 'b||] : (a * b) -> b
logic !! ['a|r|'e] : ref(r,a) -> <r 'e> -> a
let
  := ['a|r|] = (fun (x:ref(r,a)) ->
               (fun (v:a) -> {(fun (cur:<r >) -> True)}
               parameter(unit,{ } + {r })
               {(fun (old:<r >) ->
                (fun (cur:<r >) ->
                (fun (anon:unit) -> (!! [a| r| { }] x cur) =[a||] v)))})) 
let apply ['a
  'b||'e] = (fun (f:a ->{{ } + { 'e}} b) ->
            (fun (x:a) ->
            {(fun (cur:< 'e>) ->
             fst [a -> < 'e> -> prop,a -> < 'e> -> < 'e> -> b -> prop||] f x
             cur)}
            f x
            {(fun (old:< 'e>) ->
             (fun (cur:< 'e>) ->
             (fun (k:b) ->
             snd [a -> < 'e> -> prop,a -> < 'e> -> < 'e> -> b -> prop||] f x
             old cur k)))})) 
let
  main [|r|] = (fun (x:ref(r,int)) -> {(fun (cur:<r >) -> True)}
               apply [unit,unit|| {r }]
               (fun (z:unit) -> {(fun (cur:<r >) -> True)} x :=[int| r|] 0
               {(fun (old:<r >) ->
                (fun (cur:<r >) ->
                (fun (anon:unit) -> (!! [int| r| { }] x cur) =[int||] 0)))})
               tt
               {(fun (old:<r >) ->
                (fun (cur:<r >) ->
                (fun (anon:unit) -> (!! [int| r| { }] x cur) =[int||] 0)))}) 
