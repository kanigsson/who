type unit
logic tt  : unit
logic = ['a||] : a -> a -> prop
logic fst ['a1 'b||] : (a1 * b) -> a1
logic snd ['a2 'b1||] : (a2 * b1) -> b1
logic !! ['a3|r|'e] : ref(r,a3) -> <r 'e> -> a3
let
  := ['a4|r1|] = (fun (x:ref(r1,a4)) ->
                 (fun (v:a4) -> {(fun (cur:<r1 >) -> True)}
                 parameter(unit,{r1 })
                 {(fun (old:<r1 >) ->
                  (fun (cur1:<r1 >) ->
                  (fun (anon:unit) -> (!! [a4| r1| { }] x cur1) =[a4||] v)))})) 
let apply ['a5
  'b2||'e1] = (fun (f:a5 ->{{ 'e1}} b2) ->
              (fun (x1:a5) ->
              {(fun (cur2:< 'e1>) ->
               fst [a5 -> < 'e1> -> prop,a5 -> < 'e1> -> < 'e1> -> b2 ->
               prop||] f x1 cur2)}
              f x1
              {(fun (old1:< 'e1>) ->
               (fun (cur3:< 'e1>) ->
               (fun (k:b2) ->
               snd [a5 -> < 'e1> -> prop,a5 -> < 'e1> -> < 'e1> -> b2 ->
               prop||] f x1 old1 cur3 k)))})) 
let
  main [|r2|] = (fun (x2:ref(r2,int)) -> {(fun (cur4:<r2 >) -> True)}
                apply [unit,unit|| {r2 }]
                (fun (z:unit) -> {(fun (cur5:<r2 >) -> True)}
                x2 :=[int| r2|] 0
                {(fun (old2:<r2 >) ->
                 (fun (cur6:<r2 >) ->
                 (fun (anon1:unit) -> (!! [int| r2| { }] x2 cur6) =[int||] 0)))})
                tt
                {(fun (old3:<r2 >) ->
                 (fun (cur7:<r2 >) ->
                 (fun (anon2:unit) -> (!! [int| r2| { }] x2 cur7) =[int||] 0)))}) 
