section boolean coq predefined
  pangoline takeover type bool
  logic true  : bool
  logic false  : bool end
section unit coq predefined
  pangoline takeover type unit
  logic tt  : unit end
section basiclogic coq predefined
  pangoline predefined
   logic /\  : prop -> prop -> prop
  logic \/  : prop -> prop -> prop
  logic ->  : prop -> prop -> prop
  logic ~  : prop -> prop
  logic = ['a||] : a -> a -> prop end
section encoding coq takeover
  pangoline takeover
   type region['u||]
  type refty['reg 'ty||]
  logic ref_get ['reg 'u||] : region[reg] -> refty[reg,u] -> u end
section tuples coq predefined
  pangoline predefined
   logic mk_2tuple ['a 'b||] : a -> b -> a * b
  logic mk_3tuple ['a 'b 'c||] : a -> b -> c -> a * b * c
  logic mk_4tuple ['a 'b 'c 'd||] : a -> b -> c -> d -> a * b * c * d
  logic mk_5tuple ['a 'b 'c 'd 'e||] : a -> b -> c -> d -> e -> a * b * c *
    d * e
  logic mk_6tuple ['a 'b 'c 'd 'e 'f||] : a -> b -> c -> d -> e -> f -> a *
    b * c * d * e * f
  logic mk_7tuple ['a 'b 'c 'd 'e 'f 'g||] : a -> b -> c -> d -> e -> f ->
    g -> a * b * c * d * e * f * g
  logic get_2_1_tuple ['a 'b||] : (a * b) -> a
  logic get_2_2_tuple ['a 'b||] : (a * b) -> b
  logic get_3_1_tuple ['a 'b 'c||] : (a * b * c) -> a
  logic get_3_2_tuple ['a 'b 'c||] : (a * b * c) -> b
  logic get_3_3_tuple ['a 'b 'c||] : (a * b * c) -> c
  logic get_4_1_tuple ['a 'b 'c 'd||] : (a * b * c * d) -> a
  logic get_4_2_tuple ['a 'b 'c 'd||] : (a * b * c * d) -> b
  logic get_4_3_tuple ['a 'b 'c 'd||] : (a * b * c * d) -> c
  logic get_4_4_tuple ['a 'b 'c 'd||] : (a * b * c * d) -> d
  logic get_5_1_tuple ['a 'b 'c 'd 'e||] : (a * b * c * d * e) -> a
  logic get_5_2_tuple ['a 'b 'c 'd 'e||] : (a * b * c * d * e) -> b
  logic get_5_3_tuple ['a 'b 'c 'd 'e||] : (a * b * c * d * e) -> c
  logic get_5_4_tuple ['a 'b 'c 'd 'e||] : (a * b * c * d * e) -> d
  logic get_5_5_tuple ['a 'b 'c 'd 'e||] : (a * b * c * d * e) -> e
  logic get_6_1_tuple ['a 'b 'c 'd 'e 'f||] : (a * b * c * d * e * f) -> a
  logic get_6_2_tuple ['a 'b 'c 'd 'e 'f||] : (a * b * c * d * e * f) -> b
  logic get_6_3_tuple ['a 'b 'c 'd 'e 'f||] : (a * b * c * d * e * f) -> c
  logic get_6_4_tuple ['a 'b 'c 'd 'e 'f||] : (a * b * c * d * e * f) -> d
  logic get_6_5_tuple ['a 'b 'c 'd 'e 'f||] : (a * b * c * d * e * f) -> e
  logic get_6_6_tuple ['a 'b 'c 'd 'e 'f||] : (a * b * c * d * e * f) -> f
  logic get_7_1_tuple ['a 'b 'c 'd 'e 'f 'g||] : (a * b * c * d * e * f *
    g) -> a
  logic get_7_2_tuple ['a 'b 'c 'd 'e 'f 'g||] : (a * b * c * d * e * f *
    g) -> b
  logic get_7_3_tuple ['a 'b 'c 'd 'e 'f 'g||] : (a * b * c * d * e * f *
    g) -> c
  logic get_7_4_tuple ['a 'b 'c 'd 'e 'f 'g||] : (a * b * c * d * e * f *
    g) -> d
  logic get_7_5_tuple ['a 'b 'c 'd 'e 'f 'g||] : (a * b * c * d * e * f *
    g) -> e
  logic get_7_6_tuple ['a 'b 'c 'd 'e 'f 'g||] : (a * b * c * d * e * f *
    g) -> f
  logic get_7_7_tuple ['a 'b 'c 'd 'e 'f 'g||] : (a * b * c * d * e * f *
    g) -> g
  logic fst ['a 'b||] : (a * b) -> a
  logic snd ['a 'b||] : (a * b) -> b end
section arith coq "WhoArith"
  pangoline takeover
   logic +  : int -> int -> int
  logic -  : int -> int -> int
  logic *  : int -> int -> int
  logic <  : int -> int -> prop
  logic <=  : int -> int -> prop
  logic >  : int -> int -> prop
  logic >=  : int -> int -> prop
  logic <<  : int -> int -> bool
  logic <<=  : int -> int -> bool
  logic >>  : int -> int -> bool
  logic >>=  : int -> int -> bool
  logic <> ['a||] : a -> a -> prop
  logic int_max  : int -> int -> int
  logic int_min  : int -> int -> int
  logic band  : bool -> bool -> bool
  logic bor  : bool -> bool -> bool
  axiom int_max_is_ge : forall (x:int).
                        forall (y:int).
                        ((int_max x y) >= x) /\ ((int_max x y) >= y)
  axiom int_max_is_some : forall (x:int).
                          forall (y:int).
                          ((int_max x y) =[int||] x) \/
                          ((int_max x y) =[int||] y)
  axiom int_min_is_le : forall (x:int).
                        forall (y:int).
                        ((int_min x y) <= x) /\ ((int_min x y) <= y)
  axiom int_min_is_some : forall (x:int).
                          forall (y:int).
                          ((int_min x y) =[int||] x) \/
                          ((int_min x y) =[int||] y) end
section beq coq predefined
  pangoline takeover
   logic == ['a||] : a -> a -> bool
  logic != ['a||] : a -> a -> bool end
section Whoref coq "WhoMap"
  pangoline predefined
   logic !! ['a|r|'e] : ref(r,a) -> <r 'e> -> a
  let
    ! ['a|r|] = (fun (x:ref(r,a)) -> {(fun (cur:<r >) -> True)}
                parameter(a,{r })
                {(fun (old:<r >) ->
                 (fun (cur:<r >) ->
                 (fun (r1:a) ->
                 ((!! [a| r| { }] x cur) =[a||] r1) /\
                 ((!! [a| r| { }] x old) =[a||] (!! [a| r| { }] x cur)))))}) 
  let
    := ['a|r|] = (fun (x:ref(r,a)) ->
                 (fun (v:a) -> {(fun (cur:<r >) -> True)}
                 parameter(unit,{r })
                 {(fun (old:<r >) ->
                  (fun (cur:<r >) ->
                  (fun (anon:unit) -> (!! [a| r| { }] x cur) =[a||] v)))})) 
  let
    ref ['a|r|] = (fun (v:a) ->allocates r {(fun (cur:<r >) -> True)}
                  parameter(ref(r,a),{r })
                  {(fun (old:<r >) ->
                   (fun (cur:<r >) ->
                   (fun (x:ref(r,a)) -> (!! [a| r| { }] x cur) =[a||] v)))}) 
  logic combine [||'e 'e1 'e2] : < 'e 'e1> -> < 'e1 'e2> -> < 'e 'e1 'e2>
  logic restrict [||'e 'e1] : < 'e 'e1> -> < 'e1>
  logic empty  : < >
  let pre ['a 'b||] = (fun (x:a * b) -> fst [a,b||] x) 
  let post ['a 'b||] = (fun (x:a * b) -> snd [a,b||] x)  end
let
  forto [||'e] = (fun (inv:int -> < 'e> -> prop) ->
                 (fun (start:int) ->
                 (fun (end_:int) ->
                 (fun (f:int ->{ 'e} unit) ->
                 {(fun (cur:< 'e>) ->
                  (inv start cur) /\
                  (forall (i:int).
                   ((start <= i) /\ (i <= end_)) ->
                   (forall (m:< 'e>).
                    (inv i m) ->
                    ((pre [int -> < 'e> -> prop,int -> < 'e> -> < 'e> ->
                      unit -> prop||] f i m)
                     /\
                     (forall (n:< 'e>).
                      (post [int -> < 'e> -> prop,int -> < 'e> -> < 'e> ->
                       unit -> prop||] f i m n tt)
                      -> (inv (i + 1) n))))))}
                 parameter(unit,{ 'e})
                 {(fun (old:< 'e>) ->
                  (fun (cur:< 'e>) ->
                  (fun (anon:unit) -> inv (int_max start (end_ + 1)) cur)))})))) 
let
  fordownto [||'e] = (fun (inv:int -> < 'e> -> prop) ->
                     (fun (start:int) ->
                     (fun (end_:int) ->
                     (fun (f:int ->{ 'e} unit) ->
                     {(fun (cur:< 'e>) ->
                      (inv start cur) /\
                      (forall (i:int).
                       ((end_ <= i) /\ (i <= start)) ->
                       (forall (m:< 'e>).
                        (inv i m) ->
                        ((pre [int -> < 'e> -> prop,int -> < 'e> -> < 'e> ->
                          unit -> prop||] f i m)
                         /\
                         (forall (n:< 'e>).
                          (post [int -> < 'e> -> prop,int -> < 'e> ->
                           < 'e> -> unit -> prop||] f i m n tt)
                          -> (inv (i - 1) n))))))}
                     parameter(unit,{ 'e})
                     {(fun (old:< 'e>) ->
                      (fun (cur:< 'e>) ->
                      (fun (anon:unit) -> inv (int_min start (end_ - 1)) cur)))})))) 
section Array coq "WhoArray"
  pangoline takeover
   type array['a||]
  logic ar_empty ['a||] : array[a]
  logic get ['a||] : int -> array[a] -> a
  logic set ['a||] : int -> a -> array[a] -> array[a]
  logic len ['a||] : array[a] -> int
  logic create ['a||] : int -> a -> array[a]
  axiom update_length : forall ['a||]. forall (t:array[a]).
                                       forall (i:int).
                                       forall (z:a).
                                       ((0 <= i) /\ (i < (len [a||] t))) ->
                                       ((len [a||] t) =[int||]
                                        (len [a||] (set [a||] i z t)))
  axiom get_set_eq : forall ['a||]. forall (t:array[a]).
                                    forall (i:int).
                                    forall (z:a).
                                    ((0 <= i) /\ (i < (len [a||] t))) ->
                                    ((get [a||] i (set [a||] i z t)) =[a||] z)
  axiom length_empty : forall ['a||]. (len [a||] ar_empty [a||]) =[int||] 0
  axiom get_set_neq : forall ['a||]. forall (t:array[a]).
                                     forall (i:int).
                                     forall (j:int).
                                     forall (z:a).
                                     ((0 <= i) /\ (i < (len [a||] t))) ->
                                     (((0 <= j) /\ (j < (len [a||] t))) ->
                                      ((i <>[int||] j) ->
                                       ((get [a||] i (set [a||] j z t))
                                        =[a||] (get [a||] i t))))
  axiom length_nonnegative : forall ['a||]. forall (t:array[a]).
                                            0 <= (len [a||] t)
  axiom length_create : forall ['a||]. forall (l:int).
                                       forall (v:a).
                                       (0 <= l) ->
                                       ((len [a||] (create [a||] l v))
                                        =[int||] l)
  axiom create_access : forall ['a||]. forall (i:int).
                                       forall (l:int).
                                       forall (v:a).
                                       (0 <= i) ->
                                       ((i < l) ->
                                        ((get [a||] i (create [a||] l v))
                                         =[a||] v)) end
section List coq "WhoList"
  pangoline takeover
   type list['a||]
  logic nil ['a||] : list[a]
  logic cons ['a||] : a -> list[a] -> list[a]
  logic is_nil ['a||] : list[a] -> bool
  logic l_in ['a||] : a -> list[a] -> prop end
type t = int * int * int
let x  = mk_3tuple [int,int,int||] 1 2 3 
let y  = mk_3tuple [bool,int,int -> int||] true 5 (fun (x1:int) -> x1 + 1) 
let g  = get_3_1_tuple [int,int,int||] x 
