type unit
logic tt  : unit
logic = ['a||] : (a) -> (a) -> prop
logic /\  : prop -> prop -> prop
logic ->  : prop -> prop -> prop
logic !! ['a1|r|'e] : ref(r,a1) -> <r  'e > -> a1
let
  ! ['a2|r1|] = (fun (x:ref(r1,a2)) ->  parameter(a2,{r1  })
                { r2 : ((!! x cur) = r2) /\ ((!! x old) = (!! x cur))}) 
logic fst ['a3 'b||] : ((a3) * (b)) -> a3
logic snd ['a4 'b1||] : ((a4) * (b1)) -> b1
let pre ['a5 'b2||] = (fun (x1:(a5) * (b2)) -> fst x1) 
let post ['a6 'b3||] = (fun (x2:(a6) * (b3)) -> snd x2) 
logic <=  : int -> int -> prop
logic <  : int -> int -> prop
logic +  : int -> int -> int
logic *  : int -> int -> int
logic int_max  : int -> int -> int
let
  := ['a7|r3|] = (fun (x3:ref(r3,a7)) ->
                 (fun (v:a7) ->  parameter(unit,{r3  }) {(!! x3 cur1) = v})) 
let
  forto [||'e1] = (fun (inv:int -> < 'e1 > -> prop) ->
                  (fun (start:int) ->
                  (fun (end_:int) ->
                  (fun (f:int ->{ 'e1 } unit) ->
                  {(inv start cur2) /\
                   (forall (i:int).
                    ((start <= i) /\ (i <= end_)) ->
                    (forall (m:< 'e1 >).
                     (inv i m) ->
                     ((pre f i m) /\
                      (forall (n:< 'e1 >).
                       (post f i m n tt) -> (inv (i + 1) n)))))}
                  parameter(unit,{ 'e1 })
                  {inv (int_max start (end_ + 1)) cur3})))) 
let
  f1 [|r4|] = (fun (b4:unit) ->
              (fun (x4:ref(r4,int)) -> 
              let __start = 1 in
              let __end = 5 in
              forto ({(!! x4 cur4) < (i1 * 10)}) __start __end (x4 :=
                                                                ((! x4) + i1))
              )) 
