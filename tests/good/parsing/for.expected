type unit
logic tt  : unit
logic = ['a||] : a -> a -> prop
logic /\  : prop -> prop -> prop
logic ->  : prop -> prop -> prop
logic ~  : prop -> prop
logic !! ['a|r|'e] : ref(r,a) -> <r 'e> -> a
let
  ! ['a|r|] = (fun (x:ref(r,a)) -> {(fun (cur:<r >) -> True)}
              parameter(a,{r } + {r })
              {(fun (old:<r >) ->
               (fun (cur:<r >) ->
               (fun (r1:a) ->
               ((!! [a| r| { }] x cur) =[a||] r1) /\
               ((!! [a| r| { }] x old) =[a||] (!! [a| r| { }] x cur)))))}) 
logic fst ['a 'b||] : (a * b) -> a
logic snd ['a 'b||] : (a * b) -> b
let pre ['a 'b||] = (fun (x:a * b) -> fst [a,b||] x) 
let post ['a 'b||] = (fun (x:a * b) -> snd [a,b||] x) 
logic <=  : int -> int -> prop
logic <  : int -> int -> prop
logic +  : int -> int -> int
logic *  : int -> int -> int
logic int_max  : int -> int -> int
let
  := ['a|r|] = (fun (x:ref(r,a)) ->
               (fun (v:a) -> {(fun (cur:<r >) -> True)}
               parameter(unit,{r } + {r })
               {(fun (old:<r >) ->
                (fun (cur:<r >) ->
                (fun (anon:unit) -> (!! [a| r| { }] x cur) =[a||] v)))})) 
logic combine [||'e 'e1 'e2] : < 'e 'e1> -> < 'e1 'e2> -> < 'e 'e1 'e2>
let
  forto [||'e] = (fun (inv:int -> < 'e> -> prop) ->
                 (fun (start:int) ->
                 (fun (end_:int) ->
                 (fun (f:int ->{{ 'e} + { 'e}} unit) ->
                 {(fun (cur:< 'e>) ->
                  (inv start cur) /\
                  (forall (i:int).
                   ((start <= i) /\ (i <= end_)) ->
                   (forall (m:< 'e>).
                    (inv i m) ->
                    ((pre [int -> < 'e> -> prop,int -> < 'e> -> < 'e> ->
                      unit -> prop||] f i m)
                     /\
                     (forall (n:< 'e>).
                      (post [int -> < 'e> -> prop,int -> < 'e> -> < 'e> ->
                       unit -> prop||] f i m n tt)
                      -> (inv (i + 1) n))))))}
                 parameter(unit,{ 'e} + { 'e})
                 {(fun (old:< 'e>) ->
                  (fun (cur:< 'e>) ->
                  (fun (anon:unit) -> inv (int_max start (end_ + 1)) cur)))})))) 
let
  f [|r|] = (fun (b:unit) ->
            (fun (x:ref(r,int)) -> {(fun (cur:<r >) -> True)}
            let __start = 1 in
            let __end = 5 in
            forto [|| {r }]
            (fun (i:int) ->
            (fun (cur:<r >) -> (!! [int| r| { }] x cur) < (i * 10))) __start
            __end
            (fun (i:int) ->
            {(fun (cur:<r >) ->
             ((__start <= i) /\ (i <= __end)) /\
             ((!! [int| r| { }] x cur) < (i * 10)))}
            x :=[int| r|] ((! [int| r|] x) + i)
            {(fun (anon:<r >) ->
             (fun (cur:<r >) ->
             (fun (anon1:unit) -> (!! [int| r| { }] x cur) < ((i + 1) * 10))))})
            {(fun (old:<r >) ->
             (fun (cur:<r >) -> (fun (anon:unit) -> True)))})) 
