section basiclogic coq predefined
  pangoline predefined
   logic /\  : Prop -> Prop -> Prop
  logic \/  : Prop -> Prop -> Prop
  logic ->  : Prop -> Prop -> Prop
  logic ~  : Prop -> Prop
  logic = ['a||] : 'a -> 'a -> Prop
  logic <> ['a1||] : 'a1 -> 'a1 -> Prop
  logic fst ['a2 'b||] : ('a2 * 'b) -> 'a2
  logic snd ['a3 'b1||] : ('a3 * 'b1) -> 'b1
  logic , ['a4 'b2||] : 'a4 -> 'b2 -> 'a4 * 'b2 end
section arith coq "WhoArith"
  pangoline predefined
   logic +  : int -> int -> int
  logic -  : int -> int -> int
  logic *  : int -> int -> int
  logic <  : int -> int -> Prop
  logic <=  : int -> int -> Prop
  logic >  : int -> int -> Prop
  logic >=  : int -> int -> Prop
  logic <<  : int -> int -> bool
  logic <<=  : int -> int -> bool
  logic >>  : int -> int -> bool
  logic >>=  : int -> int -> bool
  logic max  : int -> int -> int
  logic min  : int -> int -> int
  logic mod  : int -> int -> int
  logic band  : bool -> bool -> bool
  logic bor  : bool -> bool -> bool end
logic == ['a5||] : 'a5 -> 'a5 -> bool
logic != ['a6||] : 'a6 -> 'a6 -> bool
section Whoref coq "WhoMap"
  pangoline predefined
   logic !! ['a7|r|'e] : ref(r,'a7) -> < 'e > -> 'a7
  let
    ! ['a8|r1|] = (fun (x:ref(r1,'a8)) ->  parameter('a8,{r1  })
                  { r2 : ((!! x cur) = r2) /\ ((!! x old) = (!! x cur))}) 
  let
    := ['a9|r3|] = (fun (x1:ref(r3,'a9)) ->
                   (fun (v:'a9) ->  parameter(unit,{r3  })
                   {(!! x1 cur1) = v})) 
  let
    ref ['a10|r4|] = (fun (v1:'a10) ->cap r4  parameter(ref(r4,'a10),{r4  })
                     { x2 : (!! x2 cur2) = v1}) 
  logic combine [||'e1] : < 'e1 > -> < 'e1 > -> < 'e1 >
  logic restrict [||'e1 'e2] : < 'e1 > -> < 'e2 >
  logic empty  : < >
  type kmap
  type key
  logic kcombine [||'e11 'e21] : (kmap) -> (kmap) -> kmap
  logic krestrict [||'e12 'e22] : (kmap) -> kmap
  logic kset ['a11||] : (key) -> 'a11 -> (kmap) -> kmap
  logic kget ['a12|r5|] : ref(r5,'a12) -> (kmap) -> 'a12
  logic kempty  : kmap
  let pre ['a13 'b3||] = (fun (x3:'a13 * 'b3) -> fst x3) 
  let post ['a14 'b4||] = (fun (x4:'a14 * 'b4) -> snd x4)  end
let
  forto [||'e2] = (fun (inv:int -> < 'e2 > -> Prop) ->
                  (fun (start:int) ->
                  (fun (end_:int) ->
                  (fun (f:int ->{ 'e2 } unit) ->
                  {(inv start cur3) /\
                   (forall (i:int).
                    ((start <= i) /\ (i <= end_)) ->
                    (forall (m:< 'e2 >).
                     (inv i m) ->
                     ((pre f i m) /\
                      (forall (n:< 'e2 >).
                       (post f i m n tt) -> (inv (i + 1) n)))))}
                  parameter(unit,{ 'e2 }) {inv (max start (end_ + 1)) cur4})))) 
let
  fordownto [||'e3] = (fun (inv1:int -> < 'e3 > -> Prop) ->
                      (fun (start1:int) ->
                      (fun (end_1:int) ->
                      (fun (f1:int ->{ 'e3 } unit) ->
                      {(inv1 start1 cur5) /\
                       (forall (i1:int).
                        ((end_1 <= i1) /\ (i1 <= start1)) ->
                        (forall (m1:< 'e3 >).
                         (inv1 i1 m1) ->
                         ((pre f1 i1 m1) /\
                          (forall (n1:< 'e3 >).
                           (post f1 i1 m1 n1 tt) -> (inv1 (i1 - 1) n1)))))}
                      parameter(unit,{ 'e3 })
                      {inv1 (min start1 (end_1 - 1)) cur6})))) 
section Array coq "WhoArray"
  pangoline takeover
   type array['a15||]
  logic ar_empty ['a16||] : array['a16||]
  logic get ['a17||] : int -> (array['a17||]) -> 'a17
  logic set ['a18||] : int -> 'a18 -> (array['a18||]) -> array['a18||]
  logic len ['a19||] : (array['a19||]) -> int
  logic create ['a20||] : int -> 'a20 -> array['a20||]
  axiom update_length : forall ['a21||]. forall (t:array['a21||]).
                                         forall (i2:int).
                                         forall (z:'a21).
                                         (len t) = (len (set i2 z t))
  axiom get_set_eq : forall ['a22||]. forall (t1:array['a22||]).
                                      forall (i3:int).
                                      forall (z1:'a22).
                                      (i3 < (len t1)) ->
                                      ((get i3 (set i3 z1 t1)) = z1)
  axiom length_empty : forall ['a23||]. (len (ar_empty : array['a23||])) = 0
  axiom get_set_neq : forall ['a24||]. forall (t2:array['a24||]).
                                       forall (i4:int).
                                       forall (j:int).
                                       forall (z2:'a24).
                                       (i4 < (len t2)) ->
                                       ((j < (len t2)) ->
                                        ((i4 <> j) ->
                                         ((get i4 (set j z2 t2)) =
                                          (get i4 t2))))
  axiom length_nonnegative : forall ['a25||]. forall (t3:array['a25||]).
                                              0 <= (len t3)
  axiom length_create : forall ['a26||]. forall (l:int).
                                         forall (v2:'a26).
                                         (0 <= l) ->
                                         ((len (create l v2)) = l)
  axiom length_access : forall ['a27||]. forall (i5:int).
                                         forall (l1:int).
                                         forall (v3:'a27).
                                         (0 <= i5) ->
                                         ((i5 <= l1) ->
                                          ((get i5 (create l1 v3)) = v3)) end
section List coq "WhoList"
  pangoline takeover
   type list['a28||]
  logic nil ['a29||] : list['a29||]
  logic cons ['a30||] : 'a30 -> (list['a30||]) -> list['a30||]
  logic is_nil ['a31||] : (list['a31||]) -> bool
  logic l_in ['a32||] : 'a32 -> (list['a32||]) -> Prop end
let
  seq [||'e4] = (fun (f2:unit ->{ 'e4 } unit) ->
                (fun (g:unit ->{ 'e4 } unit) ->
                {(fst f2 tt cur7) /\
                 (forall (i6:< 'e4 >).
                  (True /\ (snd f2 tt cur7 i6 tt)) -> (fst g tt i6))}
                let x5 = f2 tt in g tt
                {exists i7:< 'e4 >.
                 (snd f2 tt old1 i7 tt) /\ (snd g tt i7 cur8 tt)})) 
let
  z3 [|r6|] = (fun (x6:ref(r6,int)) -> 
              seq (fun (z4:unit) ->  x6 := 0 {(!! x6 cur9) = 0})
              (fun (z5:unit) ->  x6 := 1 {(!! x6 cur10) = 1})
              {(!! x6 cur11) = 1}) 
