let /\ = logic prop -> prop -> prop in
let -> = logic prop -> prop -> prop in
let ~ = logic prop -> prop in
let = ['a||]= logic 'a -> 'a -> prop in
let <> ['a1||]= logic 'a1 -> 'a1 -> prop in
let fst ['a2 'b||]= logic ('a2 * 'b) -> 'a2 in
let snd ['a3 'b1||]= logic ('a3 * 'b1) -> 'b1 in
let , ['a4 'b2||]= logic 'a4 -> 'b2 -> 'a4 * 'b2 in
let == ['a5||]= logic 'a5 -> 'a5 -> bool in
let != ['a6||]= logic 'a6 -> 'a6 -> bool in
let !! ['a7|r|e]= logic ref(r,'a7) -> map{|e } -> 'a7 in
let
! ['a8|r1|]=
            (λ(x:ref(r1,'a8)) -->  param('a8,{r1 |})
            { r2 : ((!! x cur) = r2) /\ ((!! x old) = (!! x cur))})
in
let
:= ['a9|r3|]=
             (λ(x1:ref(r3,'a9)) ->
             (λ(v:'a9) -->  param(unit,{r3 |}) {(!! x1 cur1) = v}))
in
let
ref ['a10|r4|]=
               (λ(v1:'a10) -->  param(ref(r4,'a10),{r4 ||r4 })
               { x2 : (!! x2 cur2) = v1})
in
let + = logic nat -> nat -> nat in
let - = logic nat -> nat -> nat in
let * = logic nat -> nat -> nat in
let < = logic nat -> nat -> prop in
let <= = logic nat -> nat -> prop in
let > = logic nat -> nat -> prop in
let >= = logic nat -> nat -> prop in
let max = logic nat -> nat -> nat in
let min = logic nat -> nat -> nat in
let pre ['a11 'b3||]= (λ(x3:'a11 * 'b3) -> fst x3) in
let post ['a12 'b4||]= (λ(x4:'a12 * 'b4) -> snd x4) in
let combine [||e1 e2]= logic map{|e1 } -> map{|e2 } -> map{|e1 e2 } in
let restrict [||e11 e21]= logic map{|e11 } -> map{|e21 } in
let
forto [||e1]=
             (λ(inv:nat -> map{|e1 } -> prop) ->
             (λ(start:nat) ->
             (λ(end_:nat) ->
             (λ(f:nat ->{|e1 } unit) -->
             {(inv start cur3) /\
              (forall (i:nat).
               ((start <= i) /\ (i <= end_)) ->
               (forall (m:map{|e1 }).
                (inv i m) ->
                ((pre f i m) /\
                 (forall (n:map{|e1 }). (post f i m n ()) -> (inv (i + 1) n)))))}
             param(unit,{|e1 }) {inv (max start (end_ + 1)) cur4}))))
in
let
fordownto [||e2]=
                 (λ(inv1:nat -> map{|e2 } -> prop) ->
                 (λ(start1:nat) ->
                 (λ(end_1:nat) ->
                 (λ(f1:nat ->{|e2 } unit) -->
                 {(inv1 start1 cur5) /\
                  (forall (i1:nat).
                   ((start1 <= i1) /\ (i1 <= end_1)) ->
                   (forall (m1:map{|e2 }).
                    (inv1 i1 m1) ->
                    ((pre f1 i1 m1) /\
                     (forall (n1:map{|e2 }).
                      (post f1 i1 m1 n1 ()) -> (inv1 (i1 - 1) n1)))))}
                 param(unit,{|e2 }) {inv1 (min start1 (end_1 - 1)) cur6}))))
in type array['a13||] =  in
let get ['a14||]= logic nat -> (array['a14||]) -> 'a14 in
let set ['a15||]= logic nat -> 'a15 -> (array['a15||]) -> array['a15||] in
let length ['a16||]= logic (array['a16||]) -> nat in
let create ['a17||]= logic nat -> array['a17||] in
let
update_length ['a18||]=
                       axiom forall (t:array['a18||]).
                             forall (i2:nat).
                             forall (z:'a18).
                             (length t) = (length (set i2 z t))
in
let
get_set_eq ['a19||]=
                    axiom forall (t1:array['a19||]).
                          forall (i3:nat).
                          forall (z1:'a19).
                          (i3 < (length t1)) ->
                          ((get i3 (set i3 z1 t1)) = z1)
in
let
get_set_neq ['a20||]=
                     axiom forall (t2:array['a20||]).
                           forall (i4:nat).
                           forall (j:nat).
                           forall (z2:'a20).
                           (i4 < (length t2)) ->
                           ((j < (length t2)) ->
                            ((i4 <> j) ->
                             ((get i4 (set j z2 t2)) = (get i4 t2))))
in
let
length_nonnegative ['a21||]=
                            axiom forall (t3:array['a21||]). 0 <= (length t3)
in
let
length_create ['a22||]=
                       axiom forall (l:nat).
                             (0 <= l) ->
                             ((length (create l : array['a22||])) = l)
in
let fact = logic nat -> nat in
let fact_zero = axiom (fact 0) = 1 in
let
fact_step =
           axiom forall (n2:nat).
                 (0 <= n2) -> ((fact (n2 + 1)) = (n2 * (fact n2)))
in
let
rec(nat ->{|} nat) f2 =
                       (λ(x5:nat) --> {0 <= x5}
                       if x5 == 0 then 1 else x5 * (f2 (x5 - 1))
                       { r5 : r5 = (fact x5)})
in ()
