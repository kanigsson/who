section basiclogic coq predefined
  pangoline predefined
   logic /\  : prop -> prop -> prop
  logic \/  : prop -> prop -> prop
  logic ->  : prop -> prop -> prop
  logic ~  : prop -> prop
  logic = ['a||] : (a) -> (a) -> prop
  logic , ['a1 'b||] : (a1) -> (b) -> (a1) * (b) end
section pairs coq predefined
  pangoline takeover
   logic fst ['a2 'b1||] : ((a2) * (b1)) -> a2
  logic snd ['a3 'b2||] : ((a3) * (b2)) -> b2 end
section boolean coq predefined
  pangoline takeover type bool
  logic true  : bool
  logic false  : bool end
section arith coq "WhoArith"
  pangoline takeover
   logic +  : int -> int -> int
  logic -  : int -> int -> int
  logic *  : int -> int -> int
  logic <  : int -> int -> prop
  logic <=  : int -> int -> prop
  logic >  : int -> int -> prop
  logic >=  : int -> int -> prop
  logic <<  : int -> int -> bool
  logic <<=  : int -> int -> bool
  logic >>  : int -> int -> bool
  logic >>=  : int -> int -> bool
  logic <> ['a4||] : (a4) -> (a4) -> prop
  logic int_max  : int -> int -> int
  logic int_min  : int -> int -> int
  logic mod_int  : int -> int -> int
  logic band  : (bool) -> (bool) -> bool
  logic bor  : (bool) -> (bool) -> bool
  axiom int_max_is_ge : forall (x:int).
                        forall (y:int).
                        ((int_max x y) >= x) /\ ((int_max x y) >= y)
  axiom int_max_is_some : forall (x1:int).
                          forall (y1:int).
                          ((int_max x1 y1) =[int||] x1) \/
                          ((int_max x1 y1) =[int||] y1)
  axiom int_min_is_le : forall (x2:int).
                        forall (y2:int).
                        ((int_min x2 y2) <= x2) /\ ((int_min x2 y2) <= y2)
  axiom int_min_is_some : forall (x3:int).
                          forall (y3:int).
                          ((int_min x3 y3) =[int||] x3) \/
                          ((int_min x3 y3) =[int||] y3) end
logic == ['a5||] : (a5) -> (a5) -> bool
logic != ['a6||] : (a6) -> (a6) -> bool
section Whoref coq "WhoMap"
  pangoline predefined
   logic !! ['a7|r|'e] : ref(r,a7) -> <r  'e > -> a7
  let
    ! ['a8|r1|] = (fun (x4:ref(r1,a8)) -> {(fun (cur:<r1  >) -> True)}
                  parameter(a8,{r1  })
                  {(fun (old:<r1  >) ->
                   (fun (cur1:<r1  >) ->
                   (fun (r2:a8) ->
                   ((!! [a8| r1| { }] x4 cur1) =[a8||] r2) /\
                   ((!! [a8| r1| { }] x4 old) =[a8||]
                    (!! [a8| r1| { }] x4 cur1)))))}) 
  let
    := ['a9|r3|] = (fun (x5:ref(r3,a9)) ->
                   (fun (v:a9) -> {(fun (cur2:<r3  >) -> True)}
                   parameter(unit,{r3  })
                   {(fun (old1:<r3  >) ->
                    (fun (cur3:<r3  >) ->
                    (fun (anon:unit) -> (!! [a9| r3| { }] x5 cur3) =[a9||] v)))})) 
  let
    ref ['a10|r4|] = (fun (v1:a10) ->cap r4 {(fun (cur4:<r4  >) -> True)}
                     parameter(ref(r4,a10),{r4  })
                     {(fun (old2:<r4  >) ->
                      (fun (cur5:<r4  >) ->
                      (fun (x6:ref(r4,a10)) ->
                      (!! [a10| r4| { }] x6 cur5) =[a10||] v1)))}) 
  logic combine [||'e1 'e2 'e3] : < 'e1 'e2 > -> < 'e2 'e3 > -> < 'e1 'e2 'e3
    >
  logic restrict [||'e11 'e21] : < 'e11 'e21 > -> < 'e21 >
  logic empty  : < >
  let pre ['a11 'b3||] = (fun (x7:(a11) * (b3)) -> fst [a11,b3||] x7) 
  let post ['a12 'b4||] = (fun (x8:(a12) * (b4)) -> snd [a12,b4||] x8)  end
let
  forto [||'e1] = (fun (inv:int -> < 'e1 > -> prop) ->
                  (fun (start:int) ->
                  (fun (end_:int) ->
                  (fun (f:int ->{ 'e1 } unit) ->
                  {(fun (cur6:< 'e1 >) ->
                   (inv start cur6) /\
                   (forall (i:int).
                    ((start <= i) /\ (i <= end_)) ->
                    (forall (m:< 'e1 >).
                     (inv i m) ->
                     ((pre [int -> < 'e1 > -> prop,int -> < 'e1 > -> < 'e1
                       > -> unit -> prop||] f i m)
                      /\
                      (forall (n:< 'e1 >).
                       (post [int -> < 'e1 > -> prop,int -> < 'e1 > -> < 'e1
                        > -> unit -> prop||] f i m n ())
                       -> (inv (i + 1) n))))))}
                  parameter(unit,{ 'e1 })
                  {(fun (old3:< 'e1 >) ->
                   (fun (cur7:< 'e1 >) ->
                   (fun (anon1:unit) -> inv (int_max start (end_ + 1)) cur7)))})))) 
let
  fordownto [||'e2] = (fun (inv1:int -> < 'e2 > -> prop) ->
                      (fun (start1:int) ->
                      (fun (end_1:int) ->
                      (fun (f1:int ->{ 'e2 } unit) ->
                      {(fun (cur8:< 'e2 >) ->
                       (inv1 start1 cur8) /\
                       (forall (i1:int).
                        ((end_1 <= i1) /\ (i1 <= start1)) ->
                        (forall (m1:< 'e2 >).
                         (inv1 i1 m1) ->
                         ((pre [int -> < 'e2 > -> prop,int -> < 'e2 > ->
                           < 'e2 > -> unit -> prop||] f1 i1 m1)
                          /\
                          (forall (n1:< 'e2 >).
                           (post [int -> < 'e2 > -> prop,int -> < 'e2 > ->
                            < 'e2 > -> unit -> prop||] f1 i1 m1 n1 ())
                           -> (inv1 (i1 - 1) n1))))))}
                      parameter(unit,{ 'e2 })
                      {(fun (old4:< 'e2 >) ->
                       (fun (cur9:< 'e2 >) ->
                       (fun (anon2:unit) ->
                       inv1 (int_min start1 (end_1 - 1)) cur9)))})))) 
section Array coq "WhoArray"
  pangoline takeover
   type array['a13||]
  logic ar_empty ['a14||] : array[(a14)||]
  logic get ['a15||] : int -> (array[(a15)||]) -> a15
  logic set ['a16||] : int -> (a16) -> (array[(a16)||]) -> array[(a16)||]
  logic len ['a17||] : (array[(a17)||]) -> int
  logic create ['a18||] : int -> (a18) -> array[(a18)||]
  axiom update_length : forall ['a19||]. forall (t:array[(a19)||]).
                                         forall (i2:int).
                                         forall (z:a19).
                                         (len [a19||] t) =[int||]
                                         (len [a19||] (set [a19||] i2 z t))
  axiom get_set_eq : forall ['a20||]. forall (t1:array[(a20)||]).
                                      forall (i3:int).
                                      forall (z1:a20).
                                      (i3 < (len [a20||] t1)) ->
                                      ((get [a20||] i3 (set [a20||] i3 z1 t1))
                                       =[a20||] z1)
  axiom length_empty : forall ['a21||]. (len [a21||]
                                         (ar_empty [a21||] : array[(a21)||]))
                                        =[int||] 0
  axiom get_set_neq : forall ['a22||]. forall (t2:array[(a22)||]).
                                       forall (i4:int).
                                       forall (j:int).
                                       forall (z2:a22).
                                       (i4 < (len [a22||] t2)) ->
                                       ((j < (len [a22||] t2)) ->
                                        ((i4 <>[int||] j) ->
                                         ((get [a22||] i4
                                           (set [a22||] j z2 t2))
                                          =[a22||] (get [a22||] i4 t2))))
  axiom length_nonnegative : forall ['a23||]. forall (t3:array[(a23)||]).
                                              0 <= (len [a23||] t3)
  axiom length_create : forall ['a24||]. forall (l:int).
                                         forall (v2:a24).
                                         (0 <= l) ->
                                         ((len [a24||] (create [a24||] l v2))
                                          =[int||] l)
  axiom length_access : forall ['a25||]. forall (i5:int).
                                         forall (l1:int).
                                         forall (v3:a25).
                                         (0 <= i5) ->
                                         ((i5 <= l1) ->
                                          ((get [a25||] i5
                                            (create [a25||] l1 v3))
                                           =[a25||] v3)) end
section List coq "WhoList"
  pangoline takeover
   type list['a26||]
  logic nil ['a27||] : list[(a27)||]
  logic cons ['a28||] : (a28) -> (list[(a28)||]) -> list[(a28)||]
  logic is_nil ['a29||] : (list[(a29)||]) -> bool
  logic l_in ['a30||] : (a30) -> (list[(a30)||]) -> prop end
logic = ['a31||] : (a31) -> (a31) -> prop
logic /\  : prop -> prop -> prop
logic ->  : prop -> prop -> prop
logic fst ['a32 'b5||] : ((a32) * (b5)) -> a32
logic snd ['a33 'b6||] : ((a33) * (b6)) -> b6
logic !! ['a34|r5|'e3] : ref(r5,a34) -> <r5  'e3 > -> a34
let
  !1 ['a35|r6|] = (fun (x9:ref(r6,a35)) -> {(fun (cur10:<r6  >) -> True)}
                  parameter(a35,{r6  })
                  {(fun (old5:<r6  >) ->
                   (fun (cur11:<r6  >) ->
                   (fun (r7:a35) ->
                   ((!! [a35| r6| { }] x9 cur11) =[a35||] r7) /\
                   ((!! [a35| r6| { }] x9 old5) =[a35||]
                    (!! [a35| r6| { }] x9 cur11)))))}) 
let pre1 ['a36 'b7||] = (fun (x10:(a36) * (b7)) -> fst [a36,b7||] x10) 
let post1 ['a37 'b8||] = (fun (x11:(a37) * (b8)) -> snd [a37,b8||] x11) 
logic <=  : int -> int -> prop
logic <  : int -> int -> prop
logic +  : int -> int -> int
logic -  : int -> int -> int
logic int_max1  : int -> int -> int
type array1['a38||]
logic len1 ['a39||] : (array1[(a39)||]) -> int
logic get1 ['a40||] : int -> (array1[(a40)||]) -> a40
let
  forto1 [||'e4] = (fun (inv2:int -> < 'e4 > -> prop) ->
                   (fun (start2:int) ->
                   (fun (end_2:int) ->
                   (fun (f2:int ->{ 'e4 } unit) ->
                   {(fun (cur12:< 'e4 >) ->
                    (inv2 start2 cur12) /\
                    (forall (i6:int).
                     ((start2 <= i6) /\ (i6 <= end_2)) ->
                     (forall (m2:< 'e4 >).
                      (inv2 i6 m2) ->
                      ((pre1 [int -> < 'e4 > -> prop,int -> < 'e4 > -> < 'e4
                        > -> unit -> prop||] f2 i6 m2)
                       /\
                       (forall (n2:< 'e4 >).
                        (post1 [int -> < 'e4 > -> prop,int -> < 'e4 > ->
                         < 'e4 > -> unit -> prop||] f2 i6 m2 n2 ())
                        -> (inv2 (i6 + 1) n2))))))}
                   parameter(unit,{ 'e4 })
                   {(fun (old6:< 'e4 >) ->
                    (fun (cur13:< 'e4 >) ->
                    (fun (anon3:unit) ->
                    inv2 (int_max1 start2 (end_2 + 1)) cur13)))})))) 
let
  iter ['a41|t4|'e5] = (fun (inv3:<t4  'e5 > -> int -> prop) ->
                       (fun (ar:ref(t4,array1[(a41)||])) ->
                       (fun (f3:(a41) ->{t4  'e5 } unit) ->
                       {(fun (cur14:<t4  'e5 >) ->
                        (inv3 cur14 0) /\
                        (forall (i7:int).
                         ((0 <= i7) /\
                          (i7 <
                           (len1 [a41||]
                            (!! [array1[(a41)||]| t4| { 'e5 }] ar cur14))))
                         ->
                         (forall (anon4:<t4  'e5 >).
                          forall (anon5:<t4  'e5 >).
                          ((inv3 anon4 i7) ->
                           (fst [(a41) -> <t4  'e5 > -> prop,(a41) -> <t4
                             'e5 > -> <t4  'e5 > -> unit -> prop||] f3
                            (get1 [a41||] i7
                             (!! [array1[(a41)||]| t4| { 'e5 }] ar cur14))
                            anon4))
                          /\
                          ((snd [(a41) -> <t4  'e5 > -> prop,(a41) -> <t4
                             'e5 > -> <t4  'e5 > -> unit -> prop||] f3
                            (get1 [a41||] i7
                             (!! [array1[(a41)||]| t4| { 'e5 }] ar cur14))
                            anon4 anon5 ())
                           -> (inv3 anon5 (i7 + 1))))))}
                       let __start = 0 in
                       let
                       __end =
                              (len1 [a41||] (!1 [array1[(a41)||]| t4|] ar)) -
                              1
                       in
                       forto1 [|| {t4  'e5 }]
                       (fun (i8:int) ->
                       (fun (cur15:<t4  'e5 >) -> inv3 cur15 i8)) __start
                       __end
                       (fun (i8:int) ->
                       {(fun (cur15:<t4  'e5 >) ->
                        ((__start <= i8) /\ (i8 <= __end)) /\ (inv3 cur15 i8))}
                       f3 (get1 [a41||] i8 (!1 [array1[(a41)||]| t4|] ar))
                       {(fun (anon6:<t4  'e5 >) ->
                        (fun (cur15:<t4  'e5 >) ->
                        (fun (anon7:unit) -> inv3 cur15 (i8 + 1))))})
                       {(fun (old7:<t4  'e5 >) ->
                        (fun (cur16:<t4  'e5 >) ->
                        (fun (anon8:unit) ->
                        inv3 cur16
                        (len1 [a41||]
                         (!! [array1[(a41)||]| t4| { 'e5 }] ar old7)))))}))) 
