section basiclogic coq predefined
  pangoline predefined
   logic /\  : prop -> prop -> prop
  logic \/  : prop -> prop -> prop
  logic ->  : prop -> prop -> prop
  logic ~  : prop -> prop
  logic = ['a||] : a -> a -> prop end
section tuples coq predefined
  pangoline predefined
   logic mk_2tuple ['a1 'b||] : a1 -> b -> a1 * b
  logic mk_3tuple ['a2 'b1 'c||] : a2 -> b1 -> c -> a2 * b1 * c
  logic mk_4tuple ['a3 'b2 'c1 'd||] : a3 -> b2 -> c1 -> d -> a3 * b2 * c1 *
    d
  logic mk_5tuple ['a4 'b3 'c2 'd1 'e||] : a4 -> b3 -> c2 -> d1 -> e -> a4 *
    b3 * c2 * d1 * e
  logic mk_6tuple ['a5 'b4 'c3 'd2 'e1 'f||] : a5 -> b4 -> c3 -> d2 -> e1 ->
    f -> a5 * b4 * c3 * d2 * e1 * f
  logic mk_7tuple ['a6 'b5 'c4 'd3 'e2 'f1 'g||] : a6 -> b5 -> c4 -> d3 ->
    e2 -> f1 -> g -> a6 * b5 * c4 * d3 * e2 * f1 * g
  logic get_2_1_tuple ['a7 'b6||] : (a7 * b6) -> a7
  logic get_2_2_tuple ['a8 'b7||] : (a8 * b7) -> b7
  logic get_3_1_tuple ['a9 'b8 'c5||] : (a9 * b8 * c5) -> a9
  logic get_3_2_tuple ['a10 'b9 'c6||] : (a10 * b9 * c6) -> b9
  logic get_3_3_tuple ['a11 'b10 'c7||] : (a11 * b10 * c7) -> c7
  logic get_4_1_tuple ['a12 'b11 'c8 'd4||] : (a12 * b11 * c8 * d4) -> a12
  logic get_4_2_tuple ['a13 'b12 'c9 'd5||] : (a13 * b12 * c9 * d5) -> b12
  logic get_4_3_tuple ['a14 'b13 'c10 'd6||] : (a14 * b13 * c10 * d6) -> c10
  logic get_4_4_tuple ['a15 'b14 'c11 'd7||] : (a15 * b14 * c11 * d7) -> d7
  logic get_5_1_tuple ['a16 'b15 'c12 'd8 'e3||] : (a16 * b15 * c12 * d8 *
    e3) -> a16
  logic get_5_2_tuple ['a17 'b16 'c13 'd9 'e4||] : (a17 * b16 * c13 * d9 *
    e4) -> b16
  logic get_5_3_tuple ['a18 'b17 'c14 'd10 'e5||] : (a18 * b17 * c14 * d10 *
    e5) -> c14
  logic get_5_4_tuple ['a19 'b18 'c15 'd11 'e6||] : (a19 * b18 * c15 * d11 *
    e6) -> d11
  logic get_5_5_tuple ['a20 'b19 'c16 'd12 'e7||] : (a20 * b19 * c16 * d12 *
    e7) -> e7
  logic get_6_1_tuple ['a21 'b20 'c17 'd13 'e8 'f2||] : (a21 * b20 * c17 *
    d13 * e8 * f2) -> a21
  logic get_6_2_tuple ['a22 'b21 'c18 'd14 'e9 'f3||] : (a22 * b21 * c18 *
    d14 * e9 * f3) -> b21
  logic get_6_3_tuple ['a23 'b22 'c19 'd15 'e10 'f4||] : (a23 * b22 * c19 *
    d15 * e10 * f4) -> c19
  logic get_6_4_tuple ['a24 'b23 'c20 'd16 'e11 'f5||] : (a24 * b23 * c20 *
    d16 * e11 * f5) -> d16
  logic get_6_5_tuple ['a25 'b24 'c21 'd17 'e12 'f6||] : (a25 * b24 * c21 *
    d17 * e12 * f6) -> e12
  logic get_6_6_tuple ['a26 'b25 'c22 'd18 'e13 'f7||] : (a26 * b25 * c22 *
    d18 * e13 * f7) -> f7
  logic get_7_1_tuple ['a27 'b26 'c23 'd19 'e14 'f8 'g1||] : (a27 * b26 *
    c23 * d19 * e14 * f8 * g1) -> a27
  logic get_7_2_tuple ['a28 'b27 'c24 'd20 'e15 'f9 'g2||] : (a28 * b27 *
    c24 * d20 * e15 * f9 * g2) -> b27
  logic get_7_3_tuple ['a29 'b28 'c25 'd21 'e16 'f10 'g3||] : (a29 * b28 *
    c25 * d21 * e16 * f10 * g3) -> c25
  logic get_7_4_tuple ['a30 'b29 'c26 'd22 'e17 'f11 'g4||] : (a30 * b29 *
    c26 * d22 * e17 * f11 * g4) -> d22
  logic get_7_5_tuple ['a31 'b30 'c27 'd23 'e18 'f12 'g5||] : (a31 * b30 *
    c27 * d23 * e18 * f12 * g5) -> e18
  logic get_7_6_tuple ['a32 'b31 'c28 'd24 'e19 'f13 'g6||] : (a32 * b31 *
    c28 * d24 * e19 * f13 * g6) -> f13
  logic get_7_7_tuple ['a33 'b32 'c29 'd25 'e20 'f14 'g7||] : (a33 * b32 *
    c29 * d25 * e20 * f14 * g7) -> g7
  logic fst ['a34 'b33||] : (a34 * b33) -> a34
  logic snd ['a35 'b34||] : (a35 * b34) -> b34 end
section boolean coq predefined
  pangoline takeover type bool
  logic true  : bool
  logic false  : bool end
section unit coq predefined
  pangoline takeover type unit
  logic tt  : unit end
section arith coq "WhoArith"
  pangoline takeover
   logic +  : int -> int -> int
  logic -  : int -> int -> int
  logic *  : int -> int -> int
  logic <  : int -> int -> prop
  logic <=  : int -> int -> prop
  logic >  : int -> int -> prop
  logic >=  : int -> int -> prop
  logic <<  : int -> int -> bool
  logic <<=  : int -> int -> bool
  logic >>  : int -> int -> bool
  logic >>=  : int -> int -> bool
  logic <> ['a36||] : a36 -> a36 -> prop
  logic int_max  : int -> int -> int
  logic int_min  : int -> int -> int
  logic band  : bool -> bool -> bool
  logic bor  : bool -> bool -> bool
  axiom int_max_is_ge : forall (x:int).
                        forall (y:int).
                        ((int_max x y) >= x) /\ ((int_max x y) >= y)
  axiom int_max_is_some : forall (x1:int).
                          forall (y1:int).
                          ((int_max x1 y1) =[int||] x1) \/
                          ((int_max x1 y1) =[int||] y1)
  axiom int_min_is_le : forall (x2:int).
                        forall (y2:int).
                        ((int_min x2 y2) <= x2) /\ ((int_min x2 y2) <= y2)
  axiom int_min_is_some : forall (x3:int).
                          forall (y3:int).
                          ((int_min x3 y3) =[int||] x3) \/
                          ((int_min x3 y3) =[int||] y3) end
section beq coq predefined
  pangoline takeover
   logic == ['a37||] : a37 -> a37 -> bool
  logic != ['a38||] : a38 -> a38 -> bool end
section Whoref coq "WhoMap"
  pangoline predefined
   logic !! ['a39|r|'e21] : ref(r,a39) -> <r  'e21 > -> a39
  let
    ! ['a40|r1|] = (fun (x4:ref(r1,a40)) -> {(fun (cur:<r1  >) -> True)}
                   parameter(a40,{r1  })
                   {(fun (old:<r1  >) ->
                    (fun (cur1:<r1  >) ->
                    (fun (r2:a40) ->
                    ((!! [a40| r1| { }] x4 cur1) =[a40||] r2) /\
                    ((!! [a40| r1| { }] x4 old) =[a40||]
                     (!! [a40| r1| { }] x4 cur1)))))}) 
  let
    := ['a41|r3|] = (fun (x5:ref(r3,a41)) ->
                    (fun (v:a41) -> {(fun (cur2:<r3  >) -> True)}
                    parameter(unit,{r3  })
                    {(fun (old1:<r3  >) ->
                     (fun (cur3:<r3  >) ->
                     (fun (anon:unit) ->
                     (!! [a41| r3| { }] x5 cur3) =[a41||] v)))})) 
  let
    ref ['a42|r4|] = (fun (v1:a42) ->allocates r4
                     {(fun (cur4:<r4  >) -> True)} parameter(ref(r4,a42),{r4
                      })
                     {(fun (old2:<r4  >) ->
                      (fun (cur5:<r4  >) ->
                      (fun (x6:ref(r4,a42)) ->
                      (!! [a42| r4| { }] x6 cur5) =[a42||] v1)))}) 
  logic combine [||'e22 'e23 'e24] : < 'e22 'e23 > -> < 'e23 'e24 > -> < 'e22
    'e23 'e24 >
  logic restrict [||'e25 'e26] : < 'e25 'e26 > -> < 'e26 >
  logic empty  : < >
  let pre ['a43 'b35||] = (fun (x7:a43 * b35) -> fst [a43,b35||] x7) 
  let post ['a44 'b36||] = (fun (x8:a44 * b36) -> snd [a44,b36||] x8)  end
let
  forto [||'e27] = (fun (inv:int -> < 'e27 > -> prop) ->
                   (fun (start:int) ->
                   (fun (end_:int) ->
                   (fun (f15:int ->{ 'e27 } unit) ->
                   {(fun (cur6:< 'e27 >) ->
                    (inv start cur6) /\
                    (forall (i:int).
                     ((start <= i) /\ (i <= end_)) ->
                     (forall (m:< 'e27 >).
                      (inv i m) ->
                      ((pre [int -> < 'e27 > -> prop,int -> < 'e27 > ->
                        < 'e27 > -> unit -> prop||] f15 i m)
                       /\
                       (forall (n:< 'e27 >).
                        (post [int -> < 'e27 > -> prop,int -> < 'e27 > ->
                         < 'e27 > -> unit -> prop||] f15 i m n tt)
                        -> (inv (i + 1) n))))))}
                   parameter(unit,{ 'e27 })
                   {(fun (old3:< 'e27 >) ->
                    (fun (cur7:< 'e27 >) ->
                    (fun (anon1:unit) -> inv (int_max start (end_ + 1)) cur7)))})))) 
let
  fordownto [||'e28] = (fun (inv1:int -> < 'e28 > -> prop) ->
                       (fun (start1:int) ->
                       (fun (end_1:int) ->
                       (fun (f16:int ->{ 'e28 } unit) ->
                       {(fun (cur8:< 'e28 >) ->
                        (inv1 start1 cur8) /\
                        (forall (i1:int).
                         ((end_1 <= i1) /\ (i1 <= start1)) ->
                         (forall (m1:< 'e28 >).
                          (inv1 i1 m1) ->
                          ((pre [int -> < 'e28 > -> prop,int -> < 'e28 > ->
                            < 'e28 > -> unit -> prop||] f16 i1 m1)
                           /\
                           (forall (n1:< 'e28 >).
                            (post [int -> < 'e28 > -> prop,int -> < 'e28 > ->
                             < 'e28 > -> unit -> prop||] f16 i1 m1 n1 tt)
                            -> (inv1 (i1 - 1) n1))))))}
                       parameter(unit,{ 'e28 })
                       {(fun (old4:< 'e28 >) ->
                        (fun (cur9:< 'e28 >) ->
                        (fun (anon2:unit) ->
                        inv1 (int_min start1 (end_1 - 1)) cur9)))})))) 
section Array coq "WhoArray"
  pangoline takeover
   type array['a45||]
  logic ar_empty ['a46||] : array[a46||]
  logic get ['a47||] : int -> array[a47||] -> a47
  logic set ['a48||] : int -> a48 -> array[a48||] -> array[a48||]
  logic len ['a49||] : array[a49||] -> int
  logic create ['a50||] : int -> a50 -> array[a50||]
  axiom update_length : forall ['a51||]. forall (t:array[a51||]).
                                         forall (i2:int).
                                         forall (z:a51).
                                         ((0 <= i2) /\ (i2 < (len [a51||] t)))
                                         ->
                                         ((len [a51||] t) =[int||]
                                          (len [a51||] (set [a51||] i2 z t)))
  axiom get_set_eq : forall ['a52||]. forall (t1:array[a52||]).
                                      forall (i3:int).
                                      forall (z1:a52).
                                      ((0 <= i3) /\ (i3 < (len [a52||] t1)))
                                      ->
                                      ((get [a52||] i3 (set [a52||] i3 z1 t1))
                                       =[a52||] z1)
  axiom length_empty : forall ['a53||]. (len [a53||]
                                         (ar_empty [a53||] : array[a53||]))
                                        =[int||] 0
  axiom get_set_neq : forall ['a54||]. forall (t2:array[a54||]).
                                       forall (i4:int).
                                       forall (j:int).
                                       forall (z2:a54).
                                       ((0 <= i4) /\ (i4 < (len [a54||] t2)))
                                       ->
                                       (((0 <= j) /\ (j < (len [a54||] t2)))
                                        ->
                                        ((i4 <>[int||] j) ->
                                         ((get [a54||] i4
                                           (set [a54||] j z2 t2))
                                          =[a54||] (get [a54||] i4 t2))))
  axiom length_nonnegative : forall ['a55||]. forall (t3:array[a55||]).
                                              0 <= (len [a55||] t3)
  axiom length_create : forall ['a56||]. forall (l:int).
                                         forall (v2:a56).
                                         (0 <= l) ->
                                         ((len [a56||] (create [a56||] l v2))
                                          =[int||] l)
  axiom create_access : forall ['a57||]. forall (i5:int).
                                         forall (l1:int).
                                         forall (v3:a57).
                                         (0 <= i5) ->
                                         ((i5 < l1) ->
                                          ((get [a57||] i5
                                            (create [a57||] l1 v3))
                                           =[a57||] v3)) end
section List coq "WhoList"
  pangoline takeover
   type list['a58||]
  logic nil ['a59||] : list[a59||]
  logic cons ['a60||] : a60 -> list[a60||] -> list[a60||]
  logic is_nil ['a61||] : list[a61||] -> bool
  logic l_in ['a62||] : a62 -> list[a62||] -> prop end
type unit
logic tt1  : unit
logic =1 ['a63||] : a63 -> a63 -> prop
logic /\1  : prop -> prop -> prop
logic ->1  : prop -> prop -> prop
logic fst1 ['a64 'b37||] : (a64 * b37) -> a64
logic snd1 ['a65 'b38||] : (a65 * b38) -> b38
logic !!1 ['a66|r5|'e29] : ref(r5,a66) -> <r5  'e29 > -> a66
let
  !1 ['a67|r6|] = (fun (x9:ref(r6,a67)) -> {(fun (cur10:<r6  >) -> True)}
                  parameter(a67,{r6  })
                  {(fun (old5:<r6  >) ->
                   (fun (cur11:<r6  >) ->
                   (fun (r7:a67) ->
                   ((!!1 [a67| r6| { }] x9 cur11) =1[a67||] r7) /\1
                   ((!!1 [a67| r6| { }] x9 old5) =1[a67||]
                    (!!1 [a67| r6| { }] x9 cur11)))))}) 
let pre1 ['a68 'b39||] = (fun (x10:a68 * b39) -> fst1 [a68,b39||] x10) 
let post1 ['a69 'b40||] = (fun (x11:a69 * b40) -> snd1 [a69,b40||] x11) 
logic <=1  : int -> int -> prop
logic <1  : int -> int -> prop
logic +1  : int -> int -> int
logic -1  : int -> int -> int
logic int_max1  : int -> int -> int
type array1['a70||]
logic len1 ['a71||] : array1[a71||] -> int
logic get1 ['a72||] : int -> array1[a72||] -> a72
let
  forto1 [||'e30] = (fun (inv2:int -> < 'e30 > -> prop) ->
                    (fun (start2:int) ->
                    (fun (end_2:int) ->
                    (fun (f17:int ->{ 'e30 } unit) ->
                    {(fun (cur12:< 'e30 >) ->
                     (inv2 start2 cur12) /\1
                     (forall (i6:int).
                      ((start2 <=1 i6) /\1 (i6 <=1 end_2)) ->1
                      (forall (m2:< 'e30 >).
                       (inv2 i6 m2) ->1
                       ((pre1 [int -> < 'e30 > -> prop,int -> < 'e30 > ->
                         < 'e30 > -> unit -> prop||] f17 i6 m2)
                        /\1
                        (forall (n2:< 'e30 >).
                         (post1 [int -> < 'e30 > -> prop,int -> < 'e30 > ->
                          < 'e30 > -> unit -> prop||] f17 i6 m2 n2 tt1)
                         ->1 (inv2 (i6 +1 1) n2))))))}
                    parameter(unit,{ 'e30 })
                    {(fun (old6:< 'e30 >) ->
                     (fun (cur13:< 'e30 >) ->
                     (fun (anon3:unit) ->
                     inv2 (int_max1 start2 (end_2 +1 1)) cur13)))})))) 
let
  iter ['a73|t4|'e31] = (fun (inv3:<t4  'e31 > -> int -> prop) ->
                        (fun (ar:ref(t4,array1[a73||])) ->
                        (fun (f18:a73 ->{t4  'e31 } unit) ->
                        {(fun (cur14:<t4  'e31 >) ->
                         (inv3 cur14 0) /\1
                         (forall (i7:int).
                          ((0 <=1 i7) /\1
                           (i7 <1
                            (len1 [a73||]
                             (!!1 [array1[a73||]| t4| { 'e31 }] ar cur14))))
                          ->1
                          ([[(fun (cur15:<t4  'e31 >) -> inv3 cur15 i7)]]
                          f18 (get1 [a73||] i7 (!1 [array1[a73||]| t4|] ar))[[
                          (fun (old7:<t4  'e31 >) ->
                          (fun (cur16:<t4  'e31 >) ->
                          (fun (anon4:unit) -> inv3 cur16 (i7 +1 1))))]])))}
                        let __start = 0 in
                        let
                        __end =
                               (len1 [a73||] (!1 [array1[a73||]| t4|] ar)) -1
                               1
                        in
                        forto1 [|| {t4  'e31 }]
                        (fun (i8:int) ->
                        (fun (cur17:<t4  'e31 >) -> inv3 cur17 i8)) __start
                        __end
                        (fun (i8:int) ->
                        {(fun (cur17:<t4  'e31 >) ->
                         ((__start <= i8) /\ (i8 <= __end)) /\
                         (inv3 cur17 i8))}
                        f18 (get1 [a73||] i8 (!1 [array1[a73||]| t4|] ar))
                        {(fun (anon5:<t4  'e31 >) ->
                         (fun (cur17:<t4  'e31 >) ->
                         (fun (anon6:unit) -> inv3 cur17 (i8 + 1))))})
                        {(fun (old8:<t4  'e31 >) ->
                         (fun (cur18:<t4  'e31 >) ->
                         (fun (anon7:unit) ->
                         inv3 cur18
                         (len1 [a73||]
                          (!!1 [array1[a73||]| t4| { 'e31 }] ar old8)))))}))) 
