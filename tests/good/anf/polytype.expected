let /\ = logic prop -> prop -> prop in
let -> = logic prop -> prop -> prop in
let = ['a||]= logic 'a -> 'a -> prop in
let <> ['a1||]= logic 'a1 -> 'a1 -> prop in
let == ['a2||]= logic 'a2 -> 'a2 -> bool in
let != ['a3||]= logic 'a3 -> 'a3 -> bool in
let !! ['a4|r|e]= logic ref(r,'a4) -> map{|e } -> 'a4 in
let
! ['a5|r1|]=
            (λ(x:ref(r1,'a5)) -->  param('a5,{r1 |})
            {(λ(old:map{r1 |}) ->
             (λ(cur:map{r1 |}) ->
             (λ(r2:'a5) ->
             ((!! ['a5|r1|{r1 |}] x cur) = ['a5||] r2) /\
             ((!! ['a5|r1|{r1 |}] x old) = ['a5||] (!! ['a5|r1|{r1 |}] x cur)))))})
in
let
:= ['a6|r3|]=
             (λ(x1:ref(r3,'a6)) ->
             (λ(v:'a6) -->  param(unit,{r3 |})
             {(λ(old1:map{r3 |}) ->
              (λ(cur1:map{r3 |}) ->
              (λ(anon:unit) -> (!! ['a6|r3|{r3 |}] x1 cur1) = ['a6||] v)))}))
in
let
ref ['a7|r4|]=
              (λ(v1:'a7) -->  param(ref(r4,'a7),{r4 ||r4 })
              {(λ(old2:map{r4 ||r4 }) ->
               (λ(cur2:map{r4 ||r4 }) ->
               (λ(x2:ref(r4,'a7)) ->
               (!! ['a7|r4|{r4 ||r4 }] x2 cur2) = ['a7||] v1)))})
in
let fst ['b 'a8||]= logic (('a8 * 'b)) -> 'a8 in
let snd ['b1 'a9||]= logic (('a9 * 'b1)) -> 'b1 in
let , ['b2 'a10||]= logic 'a10 -> 'b2 -> ('a10 * 'b2) in
let + = logic nat -> nat -> nat in
let - = logic nat -> nat -> nat in
let * = logic nat -> nat -> nat in
let < = logic nat -> nat -> prop in
let <= = logic nat -> nat -> prop in
let > = logic nat -> nat -> prop in
let >= = logic nat -> nat -> prop in
let max = logic nat -> nat -> nat in
let min = logic nat -> nat -> nat in
let pre ['b3 'a11||]= (λ(x3:('a11 * 'b3)) -> fst ['b3,'a11||] x3) in
let post ['b4 'a12||]= (λ(x4:('a12 * 'b4)) -> snd ['b4,'a12||] x4) in
let
forto [||e1]=
             (λ(inv:nat -> map{|e1 } -> prop) ->
             (λ(start:nat) ->
             (λ(end_:nat) ->
             (λ(f:nat ->{|e1 } unit) -->
             {(λ(cur3:map{|e1 }) ->
              (inv start cur3) /\
              (forall (i:nat).
               ((start <= i) /\ (i <= end_)) ->
               (forall (m:map{|e1 }).
                (inv i m) ->
                ((pre [nat -> map{|e1 } -> map{|e1 } -> unit -> prop,nat ->
                  map{|e1 } -> prop||] f i m)
                 /\
                 (forall (n:map{|e1 }).
                  (post [nat -> map{|e1 } -> map{|e1 } -> unit -> prop,nat ->
                   map{|e1 } -> prop||] f i m n ())
                  -> (inv (i + 1) n))))))}
             param(unit,{|e1 })
             {(λ(old3:map{|e1 }) ->
              (λ(cur4:map{|e1 }) ->
              (λ(anon1:unit) -> inv (max start (end_ + 1)) cur4)))}))))
in
let
fordownto [||e2]=
                 (λ(inv1:nat -> map{|e2 } -> prop) ->
                 (λ(start1:nat) ->
                 (λ(end_1:nat) ->
                 (λ(f1:nat ->{|e2 } unit) -->
                 {(λ(cur5:map{|e2 }) ->
                  (inv1 start1 cur5) /\
                  (forall (i1:nat).
                   ((start1 <= i1) /\ (i1 <= end_1)) ->
                   (forall (m1:map{|e2 }).
                    (inv1 i1 m1) ->
                    ((pre [nat -> map{|e2 } -> map{|e2 } -> unit ->
                      prop,nat -> map{|e2 } -> prop||] f1 i1 m1)
                     /\
                     (forall (n1:map{|e2 }).
                      (post [nat -> map{|e2 } -> map{|e2 } -> unit ->
                       prop,nat -> map{|e2 } -> prop||] f1 i1 m1 n1 ())
                      -> (inv1 (i1 - 1) n1))))))}
                 param(unit,{|e2 })
                 {(λ(old4:map{|e2 }) ->
                  (λ(cur6:map{|e2 }) ->
                  (λ(anon2:unit) -> inv1 (min start1 (end_1 - 1)) cur6)))}))))
in type array['a13||] =  in
let get ['a14||]= logic (array['a14||]) -> nat -> 'a14 in ()
