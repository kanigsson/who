type unit
logic tt  : unit
logic = ['a||] : a -> a -> prop
logic /\  : prop -> prop -> prop
logic ->  : prop -> prop -> prop
logic fst ['a 'b||] : (a * b) -> a
logic snd ['a 'b||] : (a * b) -> b
logic !! ['a|r|'e] : ref(r,a) -> <r 'e> -> a
let
  ! ['a|r|] = (fun (x:ref(r,a)) -> {(fun (cur:<r >) -> True)}
              parameter(a,{ } + {r })
              {(fun (old:<r >) ->
               (fun (cur:<r >) ->
               (fun (r1:a) ->
               (r1 =[a||] (!! [a| r| { }] x cur)) /\
               ((!! [a| r| { }] x old) =[a||] (!! [a| r| { }] x cur)))))}) 
let pre ['a 'b||] = (fun (x:a * b) -> fst [a,b||] x) 
let post ['a 'b||] = (fun (x:a * b) -> snd [a,b||] x) 
logic <=  : int -> int -> prop
logic <  : int -> int -> prop
logic +  : int -> int -> int
logic -  : int -> int -> int
logic int_max  : int -> int -> int
type array['a||]
logic len ['a||] : array[a] -> int
logic get ['a||] : int -> array[a] -> a
let
  forto [||'e] = (fun (inv:int -> < 'e> -> prop) ->
                 (fun (start:int) ->
                 (fun (end_:int) ->
                 (fun (f:int ->{{ } + { 'e}} unit) ->
                 {(fun (cur:< 'e>) ->
                  (inv start cur) /\
                  (forall (i:int).
                   (start <= i) ->
                   ((i <= end_) ->
                    (forall (m:< 'e>).
                     (inv i m) ->
                     ((pre [int -> < 'e> -> prop,int -> < 'e> -> < 'e> ->
                       unit -> prop||] f i m)
                      /\
                      (forall (n:< 'e>).
                       (post [int -> < 'e> -> prop,int -> < 'e> -> < 'e> ->
                        unit -> prop||] f i m n tt)
                       -> (inv (i + 1) n)))))))}
                 parameter(unit,{ } + { 'e})
                 {(fun (old:< 'e>) ->
                  (fun (cur:< 'e>) ->
                  (fun (anon:unit) -> inv (int_max start (end_ + 1)) cur)))})))) 
type array1['a||]
logic len1 ['a||] : array1[a] -> int
logic get1 ['a||] : int -> array1[a] -> a
let
  iter ['a|t|'e] = (fun (inv:<t 'e> -> int -> prop) ->
                   (fun (ar:ref(t,array1[a])) ->
                   (fun (f:a ->{{ } + {t 'e}} unit) ->
                   {(fun (cur:<t 'e>) ->
                    (inv cur 0) /\
                    (forall (i:int).
                     (0 <= i) ->
                     ((i < (len1 [a||] (!! [array1[a]| t| { 'e}] ar cur))) ->
                      ([[(fun (cur1:<t 'e>) -> inv cur1 i)]]let
                                                            anf =
                                                                 ! [array1[a]|
                                                                 t|] ar
                                                            in
                                                            f
                                                            (get1 [a||] i anf)[[
                      (fun (old:<t 'e>) ->
                      (fun (cur1:<t 'e>) ->
                      (fun (anon:unit) -> inv cur1 (i + 1))))]]))))}
                   let __start = 0 in
                   let anf = ! [array1[a]| t|] ar in
                   let __end = (len1 [a||] anf) - 1 in
                   forto [|| {t 'e}]
                   (fun (i:int) -> (fun (cur:<t 'e>) -> inv cur i)) __start
                   __end
                   (fun (i:int) ->
                   {(fun (cur:<t 'e>) ->
                    ((__start <= i) /\ (i <= __end)) /\ (inv cur i))}
                   let anf1 = ! [array1[a]| t|] ar in f (get1 [a||] i anf1)
                   {(fun (anon:<t 'e>) ->
                    (fun (cur:<t 'e>) ->
                    (fun (anon1:unit) -> inv cur (i + 1))))})
                   {(fun (old:<t 'e>) ->
                    (fun (cur:<t 'e>) ->
                    (fun (anon:unit) ->
                    inv cur (len1 [a||] (!! [array1[a]| t| { 'e}] ar old)))))}))) 
