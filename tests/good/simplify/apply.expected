section basiclogic Coq 
 let /\ = logic Prop -> Prop -> Prop in
 let \/ = logic Prop -> Prop -> Prop in
 let -> = logic Prop -> Prop -> Prop in
 let ~ = logic Prop -> Prop in
 let = [a||]= logic a -> a -> Prop in
 let <> [a1||]= logic a1 -> a1 -> Prop in
 let fst [a2 b||]= logic (a2 * b) -> a2 in
 let snd [a3 b1||]= logic (a3 * b1) -> b1 in
 let , [a4 b2||]= logic a4 -> b2 -> a4 * b2 in end
  section arith Coq WhoArith
   let + = logic int -> int -> int in
   let - = logic int -> int -> int in
   let * = logic int -> int -> int in
   let < = logic int -> int -> Prop in
   let <= = logic int -> int -> Prop in
   let > = logic int -> int -> Prop in
   let >= = logic int -> int -> Prop in
   let << = logic int -> int -> bool in
   let <<= = logic int -> int -> bool in
   let >> = logic int -> int -> bool in
   let >>= = logic int -> int -> bool in
   let max = logic int -> int -> int in
   let min = logic int -> int -> int in
   let mod = logic int -> int -> int in end
    let == [a5||]= logic a5 -> a5 -> bool in
    let != [a6||]= logic a6 -> a6 -> bool in
    section Whoref Coq WhoMap
     let !! [a7 e||]= logic ref(r,a7) -> e -> a7 in
     let combine [e1 e2||]= logic e1 -> e2 -> kmap in
     let restrict [e11 e21||]= logic e11 -> kmap in
     let empty = logic kmap in type kmap =  in type key =  in
     let kcombine [e12 e22||]= logic (kmap) -> (kmap) -> kmap in
     let krestrict [e13 e23||]= logic (kmap) -> kmap in
     let kset [a8||]= logic (key) -> a8 -> (kmap) -> kmap in
     let kget [a9||]= logic ref(r1,a9) -> (kmap) -> a9 in
     let kempty = logic kmap in end
      section Array Coq WhoArray type array[a10||] =  in
      let get [a11||]= logic int -> (array[a11||]) -> a11 in
      let set [a12||]= logic int -> a12 -> (array[a12||]) -> array[a12||] in
      let len [a13||]= logic (array[a13||]) -> int in
      let create [a14||]= logic int -> a14 -> array[a14||] in
      let
      update_length [a15||]=
                            axiom forall (t:array[a15||]),
                                  forall (i:int),
                                  forall (z:a15),
                                  (len [a15||] t) =[int||]
                                  (len [a15||] (set [a15||] i z t))
      in
      let
      get_set_eq [a16||]=
                         axiom forall (t1:array[a16||]),
                               forall (i1:int),
                               forall (z1:a16),
                               (i1 < (len [a16||] t1)) ->
                               ((get [a16||] i1 (set [a16||] i1 z1 t1))
                                =[a16||] z1)
      in
      let
      get_set_neq [a17||]=
                          axiom forall (t2:array[a17||]),
                                forall (i2:int),
                                forall (j:int),
                                forall (z2:a17),
                                (i2 < (len [a17||] t2)) ->
                                ((j < (len [a17||] t2)) ->
                                 ((i2 <>[int||] j) ->
                                  ((get [a17||] i2 (set [a17||] j z2 t2))
                                   =[a17||] (get [a17||] i2 t2))))
      in
      let
      length_nonnegative [a18||]=
                                 axiom forall (t3:array[a18||]),
                                       0 <= (len [a18||] t3)
      in
      let
      length_create [a19||]=
                            axiom forall (l:int),
                                  forall (v:a19),
                                  (0 <= l) ->
                                  ((len [a19||] (create [a19||] l v))
                                   =[int||] l)
      in
      let
      length_access [a20||]=
                            axiom forall (i3:int),
                                  forall (l1:int),
                                  forall (v1:a20),
                                  (0 <= i3) ->
                                  ((i3 <= l1) ->
                                   ((get [a20||] i3 (create [a20||] l1 v1))
                                    =[a20||] v1))
      in end
       section List Coq WhoList type list[a21||] =  in
       let nil [a22||]= logic list[a22||] in
       let cons [a23||]= logic a23 -> (list[a23||]) -> list[a23||] in
       let is_nil [a24||]= logic (list[a24||]) -> bool in
       let l_in [a25||]= logic a25 -> (list[a25||]) -> Prop in end
        forall [a26 b3
       e1||], forall (f:(a26 -> e1 -> Prop) * (a26 -> e1 -> e1 -> b3 ->
              Prop)),
              forall (e2:e1),
              forall (x:a26),
              fst [a26 -> e1 -> Prop,a26 -> e1 -> e1 -> b3 -> Prop||] f x e2     
