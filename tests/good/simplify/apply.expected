section basiclogic Coq predefined
Pangoline predefined
 let /\ = logic Prop -> Prop -> Prop in
 let \/ = logic Prop -> Prop -> Prop in
 let -> = logic Prop -> Prop -> Prop in
 let ~ = logic Prop -> Prop in
 let = [a||]= logic a -> a -> Prop in
 let <> [a1||]= logic a1 -> a1 -> Prop in
 let fst [a2 b||]= logic (a2 * b) -> a2 in
 let snd [a3 b1||]= logic (a3 * b1) -> b1 in
 let , [a4 b2||]= logic a4 -> b2 -> a4 * b2 in end
  section arith Coq WhoArith
  Pangoline predefined
   let + = logic int -> int -> int in
   let - = logic int -> int -> int in
   let * = logic int -> int -> int in
   let < = logic int -> int -> Prop in
   let <= = logic int -> int -> Prop in
   let > = logic int -> int -> Prop in
   let >= = logic int -> int -> Prop in
   let << = logic int -> int -> bool in
   let <<= = logic int -> int -> bool in
   let >> = logic int -> int -> bool in
   let >>= = logic int -> int -> bool in
   let max = logic int -> int -> int in
   let min = logic int -> int -> int in
   let mod = logic int -> int -> int in
   let band = logic bool -> bool -> bool in
   let bor = logic bool -> bool -> bool in end
    let == [a5||]= logic a5 -> a5 -> bool in
    let != [a6||]= logic a6 -> a6 -> bool in
    section Whoref Coq WhoMap
    Pangoline predefined
     let !! [a7 e||]= logic ref(r,a7) -> e -> a7 in
     let combine [e1 e2||]= logic e1 -> e2 -> kmap in
     let restrict [e11 e21||]= logic e11 -> kmap in
     let empty = logic kmap in type kmap =  in type key =  in
     let kcombine [e12 e22||]= logic (kmap) -> (kmap) -> kmap in
     let krestrict [e13 e23||]= logic (kmap) -> kmap in
     let kset [a8||]= logic (key) -> a8 -> (kmap) -> kmap in
     let kget [a9||]= logic ref(r1,a9) -> (kmap) -> a9 in
     let kempty = logic kmap in end
      section Array Coq WhoArray
      Pangoline takeover type array[a10||] =  in
      let ar_empty [a11||]= logic array[a11||] in
      let get [a12||]= logic int -> (array[a12||]) -> a12 in
      let set [a13||]= logic int -> a13 -> (array[a13||]) -> array[a13||] in
      let len [a14||]= logic (array[a14||]) -> int in
      let create [a15||]= logic int -> a15 -> array[a15||] in
      let
      update_length [a16||]=
                            axiom forall (t:array[a16||]).
                                  forall (i:int).
                                  forall (z:a16).
                                  (len [a16||] t) =[int||]
                                  (len [a16||] (set [a16||] i z t))
      in
      let
      get_set_eq [a17||]=
                         axiom forall (t1:array[a17||]).
                               forall (i1:int).
                               forall (z1:a17).
                               (i1 < (len [a17||] t1)) ->
                               ((get [a17||] i1 (set [a17||] i1 z1 t1))
                                =[a17||] z1)
      in
      let
      length_empty [a18||]=
                           axiom (len [a18||]
                                  (ar_empty [a18||] : array[a18||]))
                                 =[int||] 0
      in
      let
      get_set_neq [a19||]=
                          axiom forall (t2:array[a19||]).
                                forall (i2:int).
                                forall (j:int).
                                forall (z2:a19).
                                (i2 < (len [a19||] t2)) ->
                                ((j < (len [a19||] t2)) ->
                                 ((i2 <>[int||] j) ->
                                  ((get [a19||] i2 (set [a19||] j z2 t2))
                                   =[a19||] (get [a19||] i2 t2))))
      in
      let
      length_nonnegative [a20||]=
                                 axiom forall (t3:array[a20||]).
                                       0 <= (len [a20||] t3)
      in
      let
      length_create [a21||]=
                            axiom forall (l:int).
                                  forall (v:a21).
                                  (0 <= l) ->
                                  ((len [a21||] (create [a21||] l v))
                                   =[int||] l)
      in
      let
      length_access [a22||]=
                            axiom forall (i3:int).
                                  forall (l1:int).
                                  forall (v1:a22).
                                  (0 <= i3) ->
                                  ((i3 <= l1) ->
                                   ((get [a22||] i3 (create [a22||] l1 v1))
                                    =[a22||] v1))
      in end
       section List Coq WhoList
       Pangoline takeover type list[a23||] =  in
       let nil [a24||]= logic list[a24||] in
       let cons [a25||]= logic a25 -> (list[a25||]) -> list[a25||] in
       let is_nil [a26||]= logic (list[a26||]) -> bool in
       let l_in [a27||]= logic a27 -> (list[a27||]) -> Prop in end
        forall [a28 b3
       e1||]. forall (f:(a28 -> e1 -> Prop) * (a28 -> e1 -> e1 -> b3 ->
              Prop)).
              forall (e2:e1).
              forall (x:a28).
              fst [a28 -> e1 -> Prop,a28 -> e1 -> e1 -> b3 -> Prop||] f x e2     
