section basiclogic Coq 
 let /\ = logic Prop -> Prop -> Prop in
 let \/ = logic Prop -> Prop -> Prop in
 let -> = logic Prop -> Prop -> Prop in
 let ~ = logic Prop -> Prop in
 let = [a||]= logic a -> a -> Prop in
 let <> [a1||]= logic a1 -> a1 -> Prop in
 let fst [a2 b||]= logic (a2 * b) -> a2 in
 let snd [a3 b1||]= logic (a3 * b1) -> b1 in
 let , [a4 b2||]= logic a4 -> b2 -> a4 * b2 in end
  section arith Coq WhoArith
   let + = logic int -> int -> int in
   let - = logic int -> int -> int in
   let * = logic int -> int -> int in
   let < = logic int -> int -> Prop in
   let <= = logic int -> int -> Prop in
   let > = logic int -> int -> Prop in
   let >= = logic int -> int -> Prop in
   let << = logic int -> int -> bool in
   let <<= = logic int -> int -> bool in
   let >> = logic int -> int -> bool in
   let >>= = logic int -> int -> bool in
   let max = logic int -> int -> int in
   let min = logic int -> int -> int in
   let mod = logic int -> int -> int in end
    let == [a5||]= logic a5 -> a5 -> bool in
    let != [a6||]= logic a6 -> a6 -> bool in
    section Whoref Coq WhoMap
     let !! [a7 e||]= logic ref(r,a7) -> e -> a7 in
     let combine [e1 e2||]= logic e1 -> e2 -> kmap in
     let restrict [e11 e21||]= logic e11 -> kmap in
     let empty = logic kmap in type kmap =  in type key =  in
     let kcombine [e12 e22||]= logic (kmap) -> (kmap) -> kmap in
     let krestrict [e13 e23||]= logic (kmap) -> kmap in
     let kset [a8||]= logic (key) -> a8 -> (kmap) -> kmap in
     let kget [a9||]= logic ref(r1,a9) -> (kmap) -> a9 in
     let kempty = logic kmap in end
      section Array Coq WhoArray type array[a10||] =  in
      let get [a11||]= logic int -> (array[a11||]) -> a11 in
      let set [a12||]= logic int -> a12 -> (array[a12||]) -> array[a12||] in
      let len [a13||]= logic (array[a13||]) -> int in
      let create [a14||]= logic int -> a14 -> array[a14||] in
      let
      update_length [a15||]=
                            axiom forall (t:array[a15||]),
                                  forall (i:int),
                                  forall (z:a15),
                                  (len [a15||] t) =
                                  (len [a15||] (set [a15||] i z t))
      in
      let
      get_set_eq [a16||]=
                         axiom forall (t1:array[a16||]),
                               forall (i1:int),
                               forall (z1:a16),
                               (i1 < (len [a16||] t1)) ->
                               ((get [a16||] i1 (set [a16||] i1 z1 t1)) = z1)
      in
      let
      get_set_neq [a17||]=
                          axiom forall (t2:array[a17||]),
                                forall (i2:int),
                                forall (j:int),
                                forall (z2:a17),
                                (i2 < (len [a17||] t2)) ->
                                ((j < (len [a17||] t2)) ->
                                 ((i2 <> j) ->
                                  ((get [a17||] i2 (set [a17||] j z2 t2)) =
                                   (get [a17||] i2 t2))))
      in
      let
      length_nonnegative [a18||]=
                                 axiom forall (t3:array[a18||]),
                                       0 <= (len [a18||] t3)
      in
      let
      length_create [a19||]=
                            axiom forall (l:int),
                                  forall (v:a19),
                                  (0 <= l) ->
                                  ((len [a19||] (create [a19||] l v)) = l)
      in
      let
      length_access [a20||]=
                            axiom forall (i3:int),
                                  forall (l1:int),
                                  forall (v1:a20),
                                  (0 <= i3) ->
                                  ((i3 <= l1) ->
                                   ((get [a20||] i3 (create [a20||] l1 v1)) =
                                    v1))
      in end
       section List Coq WhoList type list[a21||] =  in
       let nil [a22||]= logic list[a22||] in
       let cons [a23||]= logic a23 -> (list[a23||]) -> list[a23||] in
       let is_nil [a24||]= logic (list[a24||]) -> bool in
       let l_in [a25||]= logic a25 -> (list[a25||]) -> Prop in end
        forall , forall (r2:key),
                 forall (r3:int),
                 forall (x:ref(r4,int)),
                 (forall (r5:int),
                  forall (i4:int),
                  (1 <= i4) ->
                  ((i4 <= 5) ->
                   ((r5 < (i4 * 10)) -> ((r5 + i4) < ((i4 + 1) * 10)))))
                 /\
                 ((r3 < (1 * 10)) /\
                  (forall (i5:int),
                   (1 <= i5) ->
                   ((i5 <= 5) ->
                    (forall (r6:int),
                     (r6 < (i5 * 10)) ->
                     (((1 <= i5) /\ (i5 <= 5)) /\ (r6 < (i5 * 10)))))))     
