firstsimpl
=============
section basiclogic Coq 
 let /\ = logic Prop -> Prop -> Prop in
 let \/ = logic Prop -> Prop -> Prop in
 let -> = logic Prop -> Prop -> Prop in
 let ~ = logic Prop -> Prop in
 let = [a||]= logic a -> a -> Prop in
 let <> [a1||]= logic a1 -> a1 -> Prop in
 let fst [a2 b||]= logic (a2 * b) -> a2 in
 let snd [a3 b1||]= logic (a3 * b1) -> b1 in
 let , [a4 b2||]= logic a4 -> b2 -> a4 * b2 in end
  section arith Coq WhoArith
   let + = logic int -> int -> int in
   let - = logic int -> int -> int in
   let * = logic int -> int -> int in
   let < = logic int -> int -> Prop in
   let <= = logic int -> int -> Prop in
   let > = logic int -> int -> Prop in
   let >= = logic int -> int -> Prop in
   let << = logic int -> int -> bool in
   let <<= = logic int -> int -> bool in
   let >> = logic int -> int -> bool in
   let >>= = logic int -> int -> bool in
   let max = logic int -> int -> int in
   let min = logic int -> int -> int in
   let mod = logic int -> int -> int in end
    let == [a5||]= logic a5 -> a5 -> bool in
    let != [a6||]= logic a6 -> a6 -> bool in
    section Whoref Coq WhoMap
     let !! [a7|r|e]= logic ref(r,a7) -> <{|e }> -> a7 in
     let combine [||e1 e2]= logic <{|e1 }> -> <{|e2 }> -> <{|e1 e2 }> in
     let restrict [||e11 e21]= logic <{|e11 }> -> <{|e21 }> in
     let empty = logic <{|}> in type kmap =  in type key =  in
     let kcombine [||e12 e22]= logic (kmap) -> (kmap) -> kmap in
     let krestrict [||e13 e23]= logic (kmap) -> kmap in
     let kset [a8||]= logic (key) -> a8 -> (kmap) -> kmap in
     let kget [a9|r1|]= logic ref(r1,a9) -> (kmap) -> a9 in
     let kempty = logic kmap in end
      section Array Coq WhoArray type array[a10||] =  in
      let get [a11||]= logic int -> (array[a11||]) -> a11 in
      let set [a12||]= logic int -> a12 -> (array[a12||]) -> array[a12||] in
      let len [a13||]= logic (array[a13||]) -> int in
      let
      update_length [a14||]=
                            axiom forall (t:array[a14||]),
                                  forall (i:int),
                                  forall (z:a14),
                                  (len [a14||] t) =
                                  (len [a14||] (set [a14||] i z t))
      in
      let
      get_set_eq [a15||]=
                         axiom forall (t1:array[a15||]),
                               forall (i1:int),
                               forall (z1:a15),
                               (i1 < (len [a15||] t1)) ->
                               ((get [a15||] i1 (set [a15||] i1 z1 t1)) = z1)
      in
      let
      get_set_neq [a16||]=
                          axiom forall (t2:array[a16||]),
                                forall (i2:int),
                                forall (j:int),
                                forall (z2:a16),
                                (i2 < (len [a16||] t2)) ->
                                ((j < (len [a16||] t2)) ->
                                 ((i2 <> j) ->
                                  ((get [a16||] i2 (set [a16||] j z2 t2)) =
                                   (get [a16||] i2 t2))))
      in
      let
      length_nonnegative [a17||]=
                                 axiom forall (t3:array[a17||]),
                                       0 <= (len [a17||] t3)
      in end
       section List Coq WhoList type list[a18||] =  in
       let nil [a19||]= logic list[a19||] in
       let cons [a20||]= logic a20 -> (list[a20||]) -> list[a20||] in
       let is_nil [a21||]= logic (list[a21||]) -> bool in
       let l_in [a22||]= logic a22 -> (list[a22||]) -> Prop in end
        forall [a23 b3 c||e14
       e24], forall (f:(a23 -> <{|e14 }> -> Prop) * (a23 -> <{|e14 }> ->
             <{|e14 }> -> b3 -> Prop)),
             forall (g:(b3 -> <{|e24 }> -> Prop) * (b3 -> <{|e24 }> -> <{|e24
             }> -> c -> Prop)),
             forall (s:<{|e14 e24 }>),
             forall (x:a23),
             (fst [a23 -> <{|e14 }> -> Prop,a23 -> <{|e14 }> -> <{|e14 }> ->
              b3 -> Prop||] f x (restrict [||{|e14 e24 },{|e14 }] s))
             /\
             (forall (s1:<{|e14 }>),
              forall (anon:b3),
              (snd [a23 -> <{|e14 }> -> Prop,a23 -> <{|e14 }> -> <{|e14 }> ->
               b3 -> Prop||] f x (restrict [||{|e14 e24 },{|e14 }] s) s1 anon)
              ->
              (fst [b3 -> <{|e24 }> -> Prop,b3 -> <{|e24 }> -> <{|e24 }> ->
               c -> Prop||] g anon
               (restrict [||{|e14 e24 },{|e24 }]
                (combine [||{|e14 e24 },{|e14 }] s s1))))     
=================
