let /\ = logic Prop -> Prop -> Prop in
let -> = logic Prop -> Prop -> Prop in
let ~ = logic Prop -> Prop in
let = [a||]= logic a -> a -> Prop in
let <> [a1||]= logic a1 -> a1 -> Prop in
let fst [a2 b||]= logic (a2 * b) -> a2 in
let snd [a3 b1||]= logic (a3 * b1) -> b1 in
let , [a4 b2||]= logic a4 -> b2 -> a4 * b2 in
let == [a5||]= logic a5 -> a5 -> bool in
let != [a6||]= logic a6 -> a6 -> bool in
let !! [a7|r|e]= logic ref(r,a7) -> kmap{|e } -> a7 in
let + = logic Z -> Z -> Z in
let - = logic Z -> Z -> Z in
let * = logic Z -> Z -> Z in
let < = logic Z -> Z -> Prop in
let <= = logic Z -> Z -> Prop in
let > = logic Z -> Z -> Prop in
let >= = logic Z -> Z -> Prop in
let << = logic Z -> Z -> bool in
let <<= = logic Z -> Z -> bool in
let >> = logic Z -> Z -> bool in
let >>= = logic Z -> Z -> bool in
let max = logic Z -> Z -> Z in
let min = logic Z -> Z -> Z in
let combine [||e1 e2]= logic kmap{|e1 } -> kmap{|e2 } -> kmap{|e1 e2 } in
let restrict [||e11 e21]= logic kmap{|e11 } -> kmap{|e21 } in
let empty = logic kmap{|} in type array[a8||] =  in
let get [a9||]= logic Z -> (array[a9||]) -> a9 in
let set [a10||]= logic Z -> a10 -> (array[a10||]) -> array[a10||] in
let length [a11||]= logic (array[a11||]) -> Z in
let
update_length [a12||]=
                      axiom forall (t:array[a12||]),
                            forall (i:Z),
                            forall (z:a12),
                            (length [a12||] t) =
                            (length [a12||] (set [a12||] i z t))
in
let
get_set_eq [a13||]=
                   axiom forall (t1:array[a13||]),
                         forall (i1:Z),
                         forall (z1:a13),
                         (i1 < (length [a13||] t1)) ->
                         ((get [a13||] i1 (set [a13||] i1 z1 t1)) = z1)
in
let
get_set_neq [a14||]=
                    axiom forall (t2:array[a14||]),
                          forall (i2:Z),
                          forall (j:Z),
                          forall (z2:a14),
                          (i2 < (length [a14||] t2)) ->
                          ((j < (length [a14||] t2)) ->
                           ((i2 <> j) ->
                            ((get [a14||] i2 (set [a14||] j z2 t2)) =
                             (get [a14||] i2 t2))))
in
let
length_nonnegative [a15||]=
                           axiom forall (t3:array[a15||]),
                                 0 <= (length [a15||] t3)
in
(forall [||e1], forall (f:(unit -> kmap{|e1 } -> Prop) * (unit -> kmap{|e1
                } -> kmap{|e1 } -> unit -> Prop)),
                forall (s:kmap{|e1 }),
                forall (g:(unit -> kmap{|e1 } -> Prop) * (unit -> kmap{|e1
                } -> kmap{|e1 } -> unit -> Prop)),
                (fst [unit -> kmap{|e1 } -> Prop,unit -> kmap{|e1 } ->
                 kmap{|e1 } -> unit -> Prop||] f tt s)
                ->
                ((forall (i3:kmap{|e1 }),
                  (snd [unit -> kmap{|e1 } -> Prop,unit -> kmap{|e1 } ->
                   kmap{|e1 } -> unit -> Prop||] f tt s i3 tt)
                  ->
                  (fst [unit -> kmap{|e1 } -> Prop,unit -> kmap{|e1 } ->
                   kmap{|e1 } -> unit -> Prop||] g tt i3))
                 ->
                 ((fst [unit -> kmap{|e1 } -> Prop,unit -> kmap{|e1 } ->
                   kmap{|e1 } -> unit -> Prop||] f tt s)
                  /\
                  (forall (s1:kmap{|e1 }),
                   (snd [unit -> kmap{|e1 } -> Prop,unit -> kmap{|e1 } ->
                    kmap{|e1 } -> unit -> Prop||] f tt s s1 tt)
                   ->
                   ((fst [unit -> kmap{|e1 } -> Prop,unit -> kmap{|e1 } ->
                     kmap{|e1 } -> unit -> Prop||] g tt s1)
                    /\
                    (forall (s2:kmap{|e1 }),
                     (snd [unit -> kmap{|e1 } -> Prop,unit -> kmap{|e1 } ->
                      kmap{|e1 } -> unit -> Prop||] g tt s1 s2 tt)
                     ->
                     (exists i4:kmap{|e1 },
                      (snd [unit -> kmap{|e1 } -> Prop,unit -> kmap{|e1 } ->
                       kmap{|e1 } -> unit -> Prop||] f tt s i4 tt)
                      /\
                      (snd [unit -> kmap{|e1 } -> Prop,unit -> kmap{|e1 } ->
                       kmap{|e1 } -> unit -> Prop||] g tt i4 s2 tt))))))))
/\
(forall [|r1|], forall (s3:kmap{r1 |}),
                forall (x:ref(r1,Z)),
                forall (s4:kmap{r1 |}),
                (exists i5:kmap{r1 |},
                 ((!! [Z|r1|{r1 |}] x i5) = 0) /\
                 ((!! [Z|r1|{r1 |}] x s4) = 1))
                -> ((!! [Z|r1|{r1 |}] x s4) = 1))
