firstsimpl
=============
section basiclogic Coq 
 let /\ = logic Prop -> Prop -> Prop in
 let \/ = logic Prop -> Prop -> Prop in
 let -> = logic Prop -> Prop -> Prop in
 let ~ = logic Prop -> Prop in
 let = [a||]= logic a -> a -> Prop in
 let <> [a1||]= logic a1 -> a1 -> Prop in
 let fst [a2 b||]= logic (a2 * b) -> a2 in
 let snd [a3 b1||]= logic (a3 * b1) -> b1 in
 let , [a4 b2||]= logic a4 -> b2 -> a4 * b2 in end
  section arith Coq WhoArith
   let + = logic int -> int -> int in
   let - = logic int -> int -> int in
   let * = logic int -> int -> int in
   let < = logic int -> int -> Prop in
   let <= = logic int -> int -> Prop in
   let > = logic int -> int -> Prop in
   let >= = logic int -> int -> Prop in
   let << = logic int -> int -> bool in
   let <<= = logic int -> int -> bool in
   let >> = logic int -> int -> bool in
   let >>= = logic int -> int -> bool in
   let max = logic int -> int -> int in
   let min = logic int -> int -> int in
   let mod = logic int -> int -> int in end
    let == [a5||]= logic a5 -> a5 -> bool in
    let != [a6||]= logic a6 -> a6 -> bool in
    section Whoref Coq WhoMap
     let !! [a7|r|e]= logic ref(r,a7) -> <{|e }> -> a7 in
     let combine [||e1 e2]= logic <{|e1 }> -> <{|e2 }> -> <{|e1 e2 }> in
     let restrict [||e11 e21]= logic <{|e11 }> -> <{|e21 }> in
     let empty = logic <{|}> in type kmap =  in type key =  in
     let kcombine [||e12 e22]= logic (kmap) -> (kmap) -> kmap in
     let krestrict [||e13 e23]= logic (kmap) -> kmap in
     let kset [a8||]= logic (key) -> a8 -> (kmap) -> kmap in
     let kget [a9|r1|]= logic ref(r1,a9) -> (kmap) -> a9 in
     let kempty = logic kmap in end
      section Array Coq WhoArray type array[a10||] =  in
      let get [a11||]= logic int -> (array[a11||]) -> a11 in
      let set [a12||]= logic int -> a12 -> (array[a12||]) -> array[a12||] in
      let len [a13||]= logic (array[a13||]) -> int in
      let
      update_length [a14||]=
                            axiom forall (t:array[a14||]),
                                  forall (i:int),
                                  forall (z:a14),
                                  (len [a14||] t) =
                                  (len [a14||] (set [a14||] i z t))
      in
      let
      get_set_eq [a15||]=
                         axiom forall (t1:array[a15||]),
                               forall (i1:int),
                               forall (z1:a15),
                               (i1 < (len [a15||] t1)) ->
                               ((get [a15||] i1 (set [a15||] i1 z1 t1)) = z1)
      in
      let
      get_set_neq [a16||]=
                          axiom forall (t2:array[a16||]),
                                forall (i2:int),
                                forall (j:int),
                                forall (z2:a16),
                                (i2 < (len [a16||] t2)) ->
                                ((j < (len [a16||] t2)) ->
                                 ((i2 <> j) ->
                                  ((get [a16||] i2 (set [a16||] j z2 t2)) =
                                   (get [a16||] i2 t2))))
      in
      let
      length_nonnegative [a17||]=
                                 axiom forall (t3:array[a17||]),
                                       0 <= (len [a17||] t3)
      in end
       section List Coq WhoList type list[a18||] =  in
       let nil [a19||]= logic list[a19||] in
       let cons [a20||]= logic a20 -> (list[a20||]) -> list[a20||] in
       let is_nil [a21||]= logic (list[a21||]) -> bool in
       let l_in [a22||]= logic a22 -> (list[a22||]) -> Prop in end
        (forall [||e1], forall (f:(unit -> <{|e1 }> -> Prop) * (unit -> <{|e1
                        }> -> <{|e1 }> -> unit -> Prop)),
                        forall (s:<{|e1 }>),
                        forall (g:(unit -> <{|e1 }> -> Prop) * (unit -> <{|e1
                        }> -> <{|e1 }> -> unit -> Prop)),
                        (fst [unit -> <{|e1 }> -> Prop,unit -> <{|e1 }> ->
                         <{|e1 }> -> unit -> Prop||] f tt s)
                        ->
                        ((forall (i3:<{|e1 }>),
                          (snd [unit -> <{|e1 }> -> Prop,unit -> <{|e1 }> ->
                           <{|e1 }> -> unit -> Prop||] f tt s i3 tt)
                          ->
                          (fst [unit -> <{|e1 }> -> Prop,unit -> <{|e1 }> ->
                           <{|e1 }> -> unit -> Prop||] g tt i3))
                         ->
                         ((fst [unit -> <{|e1 }> -> Prop,unit -> <{|e1 }> ->
                           <{|e1 }> -> unit -> Prop||] f tt s)
                          /\
                          (forall (s1:<{|e1 }>),
                           (snd [unit -> <{|e1 }> -> Prop,unit -> <{|e1 }> ->
                            <{|e1 }> -> unit -> Prop||] f tt s s1 tt)
                           ->
                           ((fst [unit -> <{|e1 }> -> Prop,unit -> <{|e1
                             }> -> <{|e1 }> -> unit -> Prop||] g tt s1)
                            /\
                            (forall (s2:<{|e1 }>),
                             (snd [unit -> <{|e1 }> -> Prop,unit -> <{|e1
                              }> -> <{|e1 }> -> unit -> Prop||] g tt s1 s2 tt)
                             ->
                             (exists i4:<{|e1 }>,
                              (snd [unit -> <{|e1 }> -> Prop,unit -> <{|e1
                               }> -> <{|e1 }> -> unit -> Prop||] f tt s i4 tt)
                              /\
                              (snd [unit -> <{|e1 }> -> Prop,unit -> <{|e1
                               }> -> <{|e1 }> -> unit -> Prop||] g tt i4 s2
                               tt))))))))
        /\
        (forall [|r2|], forall (s3:<{r2 |}>),
                        forall (x:ref(r2,int)),
                        forall (s4:<{r2 |}>),
                        (exists i5:<{r2 |}>,
                         ((!! [int|r2|{r2 |}] x i5) = 0) /\
                         ((!! [int|r2|{r2 |}] x s4) = 1))
                        -> ((!! [int|r2|{r2 |}] x s4) = 1))     
=================
