logic /\  : prop -> prop -> prop
logic \/  : prop -> prop -> prop
logic ->  : prop -> prop -> prop
logic = ['a||] : a -> a -> prop
logic mk_2tuple ['a 'b||] : a -> b -> a * b
logic fst ['a 'b||] : (a * b) -> a
logic snd ['a 'b||] : (a * b) -> b
type bool
logic true  : bool
logic false  : bool
type unit
logic tt  : unit
logic !! ['a|r|'e] : ref(r,a) -> <r 'e> -> a
let
  logic ! ['a|r|] = mk_2tuple [ref(r,a) -> <r > -> prop,ref(r,a) -> <r > ->
                    <r > -> a -> prop||]
                    (fun (x:ref(r,a)) -> (fun (cur:<r >) -> True))
                    (fun (x:ref(r,a)) ->
                    (fun (old:<r >) ->
                    (fun (cur:<r >) ->
                    (fun (r1:a) ->
                    (r1 =[a||] (!! [a| r| { }] x cur)) /\
                    ((!! [a| r| { }] x old) =[a||] (!! [a| r| { }] x cur)))))) 
let
  logic := ['a|r|] = (fun (x:ref(r,a)) ->
                     mk_2tuple [a -> <r > -> prop,a -> <r > -> <r > ->
                     unit -> prop||] (fun (v:a) -> (fun (cur:<r >) -> True))
                     (fun (v:a) ->
                     (fun (old:<r >) ->
                     (fun (cur:<r >) ->
                     (fun (anon:unit) -> v =[a||] (!! [a| r| { }] x cur)))))) 
logic combine [||'e 'e1 'e2] : < 'e 'e1> -> < 'e1 'e2> -> < 'e 'e1 'e2>
logic restrict [||'e 'e1] : < 'e 'e1> -> < 'e1>
logic empty  : < >
type hmap['a 'b||]
logic hmem ['a 'b||] : a -> hmap[a,b||] -> bool
logic hget ['a 'b||] : a -> hmap[a,b||] -> b
logic hset ['a 'b||] : a -> b -> hmap[a,b||] -> hmap[a,b||]
goal memo_correct : forall [|t|]. forall (table:ref(t,hmap[int,int||])).
                                  forall (f:int -> int).
                                  forall (x:int).
                                  forall (s:<t >).
                                  fst [ref(t,hmap[int,int||]) -> <t > ->
                                  prop,ref(t,hmap[int,int||]) -> <t > ->
                                  <t > -> hmap[int,int||] -> prop||]
                                  ! [hmap[int,int||]| t|] table s
let
  logic memo [|t|] = (fun (table:ref(t,hmap[int,int||])) ->
                     (fun (f:int -> int) ->
                     mk_2tuple [int -> <t > -> prop,int -> <t > -> <t > ->
                     int -> prop||] (fun (x:int) -> (fun (cur:<t >) -> True))
                     (fun (x:int) ->
                     (fun (old:<t >) ->
                     (fun (cur:<t >) -> (fun (r:int) -> True)))))) 
