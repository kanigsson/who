type unit
logic tt  : unit
logic = ['a||] : a -> a -> prop
logic /\  : prop -> prop -> prop
logic ->  : prop -> prop -> prop
logic mk_2tuple ['a 'b||] : a -> b -> a * b
logic restrict [||'e 'e1] : < 'e 'e1> -> < 'e1>
logic combine [||'e 'e1 'e2] : < 'e 'e1> -> < 'e1 'e2> -> < 'e 'e1 'e2>
logic fst ['a 'b||] : (a * b) -> a
logic snd ['a 'b||] : (a * b) -> b
logic !! ['a|r|'e] : ref(r,a) -> <r 'e> -> a
let
  logic ! ['a|r|] = mk_2tuple [ref(r,a) -> <r > -> prop,ref(r,a) -> <r > ->
                    <r > -> a -> prop||]
                    (fun (x:ref(r,a)) -> (fun (cur:<r >) -> True))
                    (fun (x:ref(r,a)) ->
                    (fun (old:<r >) ->
                    (fun (cur:<r >) ->
                    (fun (r1:a) ->
                    (r1 =[a||] (!! [a| r| { }] x cur)) /\
                    ((!! [a| r| { }] x old) =[a||] (!! [a| r| { }] x cur)))))) 
let logic pre ['a 'b||] = (fun (x:a * b) -> fst [a,b||] x) 
let logic post ['a 'b||] = (fun (x:a * b) -> snd [a,b||] x) 
logic <=  : int -> int -> prop
logic <  : int -> int -> prop
logic +  : int -> int -> int
logic -  : int -> int -> int
logic int_max  : int -> int -> int
type array['a||]
logic len ['a||] : array[a||] -> int
logic get ['a||] : int -> array[a||] -> a
let
  logic forto [||'e] = (fun (inv:int -> < 'e> -> prop) ->
                       (fun (start:int) ->
                       (fun (end_:int) ->
                       mk_2tuple [((int -> < 'e> -> prop) * (int -> < 'e> ->
                       < 'e> -> unit -> prop)) -> < 'e> -> prop,((int ->
                       < 'e> -> prop) * (int -> < 'e> -> < 'e> -> unit ->
                       prop)) -> < 'e> -> < 'e> -> unit -> prop||]
                       (fun (f:(int -> < 'e> -> prop) * (int -> < 'e> ->
                       < 'e> -> unit -> prop)) ->
                       (fun (cur:< 'e>) ->
                       (inv start cur) /\
                       (forall (i:int).
                        (start <= i) ->
                        ((i <= end_) ->
                         (forall (m:< 'e>).
                          (inv i m) ->
                          ((pre [int -> < 'e> -> prop,int -> < 'e> ->
                            < 'e> -> unit -> prop||] f i m)
                           /\
                           (forall (n:< 'e>).
                            (post [int -> < 'e> -> prop,int -> < 'e> ->
                             < 'e> -> unit -> prop||] f i m n tt)
                            -> (inv (i + 1) n))))))))
                       (fun (f:(int -> < 'e> -> prop) * (int -> < 'e> ->
                       < 'e> -> unit -> prop)) ->
                       (fun (old:< 'e>) ->
                       (fun (cur:< 'e>) ->
                       (fun (anon:unit) ->
                       inv (int_max start (end_ + 1)) cur))))))) 
goal iter_correct : forall ['a|t|'e]. forall (inv:<t 'e> -> int -> prop).
                                      forall (ar:ref(t,array[a||])).
                                      forall (f:(a -> <t 'e> -> prop) * (a ->
                                      <t 'e> -> <t 'e> -> unit -> prop)).
                                      forall (s:<t 'e>).
                                      (inv s 0) ->
                                      ((forall (i:int).
                                        (0 <= i) ->
                                        ((i <
                                          (len [a||]
                                           (!! [array[a||]| t| { 'e}] ar s)))
                                         ->
                                         (forall (s1:<t 'e>).
                                          (inv s1 i) ->
                                          ((fst [ref(t,array[a||]) -> <t > ->
                                            prop,ref(t,array[a||]) -> <t > ->
                                            <t > -> array[a||] -> prop||]
                                            ! [array[a||]| t|] ar
                                            (restrict [|| { 'e} {t }] s1))
                                           /\
                                           (forall (s2:<t >).
                                            forall (anon:array[a||]).
                                            (snd [ref(t,array[a||]) ->
                                             <t > ->
                                             prop,ref(t,array[a||]) ->
                                             <t > -> <t > -> array[a||] ->
                                             prop||] ! [array[a||]| t|] ar
                                             (restrict [|| { 'e} {t }] s1) s2
                                             anon)
                                            ->
                                            ((fst [a -> <t 'e> -> prop,a ->
                                              <t 'e> -> <t 'e> -> unit ->
                                              prop||] f (get [a||] i anon)
                                              (combine [|| { 'e} {t } { }] s1
                                               s2))
                                             /\
                                             (forall (s3:<t 'e>).
                                              (snd [a -> <t 'e> -> prop,a ->
                                               <t 'e> -> <t 'e> -> unit ->
                                               prop||] f (get [a||] i anon)
                                               (combine [|| { 'e} {t } { }]
                                                s1 s2)
                                               s3 tt)
                                              -> (inv s3 (i + 1)))))))))
                                       ->
                                       (let logic __start = 0 in
                                        (fst [ref(t,array[a||]) -> <t > ->
                                         prop,ref(t,array[a||]) -> <t > ->
                                         <t > -> array[a||] -> prop||]
                                         ! [array[a||]| t|] ar
                                         (restrict [|| { 'e} {t }] s))
                                        /\
                                        (forall (s1:<t >).
                                         forall (anon:array[a||]).
                                         (snd [ref(t,array[a||]) -> <t > ->
                                          prop,ref(t,array[a||]) -> <t > ->
                                          <t > -> array[a||] -> prop||]
                                          ! [array[a||]| t|] ar
                                          (restrict [|| { 'e} {t }] s) s1
                                          anon)
                                         ->
                                         (let
                                          logic __end = (len [a||] anon) - 1
                                          in
                                          ((forall (i:int).
                                            forall (s2:<t 'e>).
                                            (__start <= i) ->
                                            ((i <= __end) ->
                                             ((inv s2 i) ->
                                              ((fst [ref(t,array[a||]) ->
                                                <t > ->
                                                prop,ref(t,array[a||]) ->
                                                <t > -> <t > -> array[a||] ->
                                                prop||] ! [array[a||]| t|] ar
                                                (restrict [|| { 'e} {t }] s2))
                                               /\
                                               (forall (s3:<t >).
                                                forall (anon1:array[a||]).
                                                (snd [ref(t,array[a||]) ->
                                                 <t > ->
                                                 prop,ref(t,array[a||]) ->
                                                 <t > -> <t > ->
                                                 array[a||] -> prop||]
                                                 ! [array[a||]| t|] ar
                                                 (restrict [|| { 'e} {t }] s2)
                                                 s3 anon1)
                                                ->
                                                ((fst [a -> <t 'e> ->
                                                  prop,a -> <t 'e> ->
                                                  <t 'e> -> unit -> prop||] f
                                                  (get [a||] i anon1)
                                                  (combine [|| { 'e} {t }
                                                   { }] s2 s3))
                                                 /\
                                                 (forall (s4:<t 'e>).
                                                  (snd [a -> <t 'e> ->
                                                   prop,a -> <t 'e> ->
                                                   <t 'e> -> unit -> prop||]
                                                   f (get [a||] i anon1)
                                                   (combine [|| { 'e} {t }
                                                    { }] s2 s3)
                                                   s4 tt)
                                                  -> (inv s4 (i + 1)))))))))
                                           /\
                                           (fst [((int -> <t 'e> -> prop) *
                                            (int -> <t 'e> -> <t 'e> ->
                                            unit -> prop)) -> <t 'e> ->
                                            prop,((int -> <t 'e> -> prop) *
                                            (int -> <t 'e> -> <t 'e> ->
                                            unit -> prop)) -> <t 'e> ->
                                            <t 'e> -> unit -> prop||]
                                            (forto [|| {t 'e}]
                                             (fun (i:int) ->
                                             (fun (cur:<t 'e>) -> inv cur i))
                                             __start __end)
                                            (mk_2tuple [int -> <t 'e> ->
                                             prop,int -> <t 'e> -> <t 'e> ->
                                             unit -> prop||]
                                             (fun (i:int) ->
                                             (fun (cur:<t 'e>) ->
                                             ((__start <= i) /\ (i <= __end))
                                             /\ (inv cur i)))
                                             (fun (i:int) ->
                                             (fun (anon1:<t 'e>) ->
                                             (fun (cur:<t 'e>) ->
                                             (fun (anon2:unit) ->
                                             inv cur (i + 1))))))
                                            (combine [|| { 'e} {t } { }] s s1)))
                                          /\
                                          (forall (s2:<t 'e>).
                                           (snd [((int -> <t 'e> -> prop) *
                                            (int -> <t 'e> -> <t 'e> ->
                                            unit -> prop)) -> <t 'e> ->
                                            prop,((int -> <t 'e> -> prop) *
                                            (int -> <t 'e> -> <t 'e> ->
                                            unit -> prop)) -> <t 'e> ->
                                            <t 'e> -> unit -> prop||]
                                            (forto [|| {t 'e}]
                                             (fun (i:int) ->
                                             (fun (cur:<t 'e>) -> inv cur i))
                                             __start __end)
                                            (mk_2tuple [int -> <t 'e> ->
                                             prop,int -> <t 'e> -> <t 'e> ->
                                             unit -> prop||]
                                             (fun (i:int) ->
                                             (fun (cur:<t 'e>) ->
                                             ((__start <= i) /\ (i <= __end))
                                             /\ (inv cur i)))
                                             (fun (i:int) ->
                                             (fun (anon1:<t 'e>) ->
                                             (fun (cur:<t 'e>) ->
                                             (fun (anon2:unit) ->
                                             inv cur (i + 1))))))
                                            (combine [|| { 'e} {t } { }] s s1)
                                            s2 tt)
                                           ->
                                           (inv s2
                                            (len [a||]
                                             (!! [array[a||]| t| { 'e}] ar s))))))))
let
  logic iter ['a|t|'e] = (fun (inv:<t 'e> -> int -> prop) ->
                         (fun (ar:ref(t,array[a||])) ->
                         mk_2tuple [((a -> <t 'e> -> prop) * (a -> <t 'e> ->
                         <t 'e> -> unit -> prop)) -> <t 'e> -> prop,((a ->
                         <t 'e> -> prop) * (a -> <t 'e> -> <t 'e> -> unit ->
                         prop)) -> <t 'e> -> <t 'e> -> unit -> prop||]
                         (fun (f:(a -> <t 'e> -> prop) * (a -> <t 'e> ->
                         <t 'e> -> unit -> prop)) ->
                         (fun (cur:<t 'e>) ->
                         (inv cur 0) /\
                         (forall (i:int).
                          (0 <= i) ->
                          ((i <
                            (len [a||] (!! [array[a||]| t| { 'e}] ar cur)))
                           ->
                           (forall (s:<t 'e>).
                            (inv s i) ->
                            ((fst [ref(t,array[a||]) -> <t > ->
                              prop,ref(t,array[a||]) -> <t > -> <t > ->
                              array[a||] -> prop||] ! [array[a||]| t|] ar
                              (restrict [|| { 'e} {t }] s))
                             /\
                             (forall (s1:<t >).
                              forall (anon:array[a||]).
                              (snd [ref(t,array[a||]) -> <t > ->
                               prop,ref(t,array[a||]) -> <t > -> <t > ->
                               array[a||] -> prop||] ! [array[a||]| t|] ar
                               (restrict [|| { 'e} {t }] s) s1 anon)
                              ->
                              ((fst [a -> <t 'e> -> prop,a -> <t 'e> ->
                                <t 'e> -> unit -> prop||] f
                                (get [a||] i anon)
                                (combine [|| { 'e} {t } { }] s s1))
                               /\
                               (forall (s2:<t 'e>).
                                (snd [a -> <t 'e> -> prop,a -> <t 'e> ->
                                 <t 'e> -> unit -> prop||] f
                                 (get [a||] i anon)
                                 (combine [|| { 'e} {t } { }] s s1) s2 tt)
                                -> (inv s2 (i + 1)))))))))))
                         (fun (f:(a -> <t 'e> -> prop) * (a -> <t 'e> ->
                         <t 'e> -> unit -> prop)) ->
                         (fun (old:<t 'e>) ->
                         (fun (cur:<t 'e>) ->
                         (fun (anon:unit) ->
                         inv cur
                         (len [a||] (!! [array[a||]| t| { 'e}] ar old)))))))) 
