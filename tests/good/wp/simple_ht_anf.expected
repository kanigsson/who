type unit
logic tt  : unit
logic empty  : < >
logic mk_2tuple ['a 'b||] : a -> b -> a * b
logic fst ['a 'b||] : (a * b) -> a
logic snd ['a 'b||] : (a * b) -> b
logic /\  : prop -> prop -> prop
logic \/  : prop -> prop -> prop
logic ->  : prop -> prop -> prop
logic ~  : prop -> prop
logic = ['a||] : a -> a -> prop
logic <  : int -> int -> prop
goal f_correct : forall (g:(unit -> < > -> prop) * (unit -> < > -> < > ->
                 unit -> prop)).
                 ((0 < 5) ->
                  ((fst [unit -> < > -> prop,unit -> < > -> < > -> unit ->
                    prop||] g tt empty)
                   /\
                   ((snd [unit -> < > -> prop,unit -> < > -> < > -> unit ->
                     prop||] g tt empty empty tt)
                    -> (3 < 6))))
                 ->
                 ((fst [unit -> < > -> prop,unit -> < > -> < > -> unit ->
                   prop||] g tt empty)
                  /\
                  ((snd [unit -> < > -> prop,unit -> < > -> < > -> unit ->
                    prop||] g tt empty empty tt)
                   -> (3 < 6)))
let
  logic f  = mk_2tuple [((unit -> < > -> prop) * (unit -> < > -> < > ->
             unit -> prop)) -> < > -> prop,((unit -> < > -> prop) * (unit ->
             < > -> < > -> unit -> prop)) -> < > -> < > -> unit -> prop||]
             (fun (g:(unit -> < > -> prop) * (unit -> < > -> < > -> unit ->
             prop)) ->
             (fun (cur:< >) ->
             (0 < 5) ->
             ((fst [unit -> < > -> prop,unit -> < > -> < > -> unit -> prop||]
               g tt empty)
              /\
              ((snd [unit -> < > -> prop,unit -> < > -> < > -> unit ->
                prop||] g tt empty empty tt)
               -> (3 < 6)))))
             (fun (g:(unit -> < > -> prop) * (unit -> < > -> < > -> unit ->
             prop)) ->
             (fun (old:< >) -> (fun (cur:< >) -> (fun (anon:unit) -> 3 < 6)))) 
