type unit
logic tt  : unit
logic empty  : <{ }>
logic mk_2tuple ['a 'b||] : a -> b -> a * b
logic fst ['a1 'b1||] : (a1 * b1) -> a1
logic snd ['a2 'b2||] : (a2 * b2) -> b2
logic /\  : prop -> prop -> prop
logic \/  : prop -> prop -> prop
logic ->  : prop -> prop -> prop
logic ~  : prop -> prop
logic = ['a3||] : a3 -> a3 -> prop
logic <  : int -> int -> prop
goal f_correct : forall (g:(unit -> <{ }> -> prop) * (unit -> <{ }> ->
                 <{ }> -> unit -> prop)).
                 ((0 < 5) ->
                  ((fst [unit -> <{ }> -> prop,unit -> <{ }> -> <{ }> ->
                    unit -> prop||] g tt empty)
                   /\
                   ((snd [unit -> <{ }> -> prop,unit -> <{ }> -> <{ }> ->
                     unit -> prop||] g tt empty empty tt)
                    -> (3 < 6))))
                 ->
                 ((fst [unit -> <{ }> -> prop,unit -> <{ }> -> <{ }> ->
                   unit -> prop||] g tt empty)
                  /\
                  ((snd [unit -> <{ }> -> prop,unit -> <{ }> -> <{ }> ->
                    unit -> prop||] g tt empty empty tt)
                   -> (3 < 6)))
let
  logic f  = (fun (g:(unit -> <{ }> -> prop) * (unit -> <{ }> -> <{ }> ->
             unit -> prop)) ->
             (fun (cur:<{ }>) ->
             (0 < 5) ->
             ((fst [unit -> <{ }> -> prop,unit -> <{ }> -> <{ }> -> unit ->
               prop||] g tt empty)
              /\
              ((snd [unit -> <{ }> -> prop,unit -> <{ }> -> <{ }> -> unit ->
                prop||] g tt empty empty tt)
               -> (3 < 6)))))
             mk_2tuple[((unit -> <{ }> -> prop) * (unit -> <{ }> -> <{ }> ->
             unit -> prop)) -> <{ }> -> prop,((unit -> <{ }> -> prop) *
             (unit -> <{ }> -> <{ }> -> unit -> prop)) -> <{ }> -> <{ }> ->
             unit -> prop||]
             (fun (g:(unit -> <{ }> -> prop) * (unit -> <{ }> -> <{ }> ->
             unit -> prop)) ->
             (fun (old:<{ }>) ->
             (fun (cur1:<{ }>) -> (fun (anon:unit) -> 3 < 6)))) 
