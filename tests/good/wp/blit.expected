type bool
logic true  : bool
logic false  : bool
type unit
logic mk_2tuple ['a 'b||] : a -> b -> a * b
logic tt  : unit
section basiclogic coq predefined
  pangoline predefined
   logic /\  : prop -> prop -> prop
  logic \/  : prop -> prop -> prop
  logic ->  : prop -> prop -> prop
  logic ~  : prop -> prop
  logic = ['a||] : a -> a -> prop
  logic <> ['a||] : a -> a -> prop
  logic get_2_2_tuple ['a 'b||] : (a * b) -> b
  logic get_2_1_tuple ['a 'b||] : (a * b) -> a
  section arith coq "WhoArith"
    pangoline predefined
     logic +  : int -> int -> int
    logic -  : int -> int -> int
    logic *  : int -> int -> int
    logic <  : int -> int -> prop
    logic <=  : int -> int -> prop
    logic >  : int -> int -> prop
    logic >=  : int -> int -> prop
    logic <<  : int -> int -> bool
    logic <<=  : int -> int -> bool
    logic >>  : int -> int -> bool
    logic >>=  : int -> int -> bool
    logic max  : int -> int -> int
    logic min  : int -> int -> int
    logic mod  : int -> int -> int
    logic band  : bool -> bool -> bool
    logic bor  : bool -> bool -> bool end
  logic == ['a||] : a -> a -> bool
  logic != ['a||] : a -> a -> bool
  section Whoref coq "WhoMap"
    pangoline predefined
     logic !! ['a|r|'e] : ref(r,a) -> < 'e> -> a
    let
      logic ! ['a|r|] = mk_2tuple [ref(r,a) -> <r > -> prop,ref(r,a) ->
                        <r > -> <r > -> a -> prop||]
                        (fun (x:ref(r,a)) -> (fun (cur:<r >) -> True))
                        (fun (x:ref(r,a)) ->
                        (fun (old:<r >) ->
                        (fun (cur:<r >) ->
                        (fun (r1:a) ->
                        (r1 =[a||] (!! [a| r| {r }] x cur)) /\
                        ((!! [a| r| {r }] x old) =[a||]
                         (!! [a| r| {r }] x cur)))))) 
    let
      logic := ['a|r|] = (fun (x:ref(r,a)) ->
                         mk_2tuple [a -> <r > -> prop,a -> <r > -> <r > ->
                         unit -> prop||]
                         (fun (v:a) -> (fun (cur:<r >) -> True))
                         (fun (v:a) ->
                         (fun (old:<r >) ->
                         (fun (cur:<r >) ->
                         (fun (anon:unit) ->
                         v =[a||] (!! [a| r| {r }] x cur)))))) 
    let
      logic ref ['a|r|] = mk_2tuple [a -> <r > -> prop,a -> <r > -> <r > ->
                          ref(r,a) -> prop||]
                          (fun (v:a) -> (fun (cur:<r >) -> True))
                          (fun (v:a) ->
                          (fun (old:<r >) ->
                          (fun (cur:<r >) ->
                          (fun (x:ref(r,a)) ->
                          v =[a||] (!! [a| r| {r }] x cur))))) 
    logic combine [||'e 'e1 'e2] : < 'e 'e1> -> < 'e1 'e2> -> < 'e 'e1 'e2>
    logic restrict [||'e 'e1] : < 'e 'e1> -> < 'e1>
    logic empty  : < >
    let logic pre ['a 'b||] = (fun (x:a * b) -> get_2_1_tuple [a,b||] x) 
    let logic post ['a 'b||] = (fun (x:a * b) -> get_2_2_tuple [a,b||] x)  end
  let
    logic forto [||'e] = (fun (inv:int -> < 'e> -> prop) ->
                         (fun (start:int) ->
                         (fun (end_:int) ->
                         mk_2tuple [((int -> < 'e> -> prop) * (int ->
                         < 'e> -> < 'e> -> unit -> prop)) -> < 'e> ->
                         prop,((int -> < 'e> -> prop) * (int -> < 'e> ->
                         < 'e> -> unit -> prop)) -> < 'e> -> < 'e> -> unit ->
                         prop||]
                         (fun (f:(int -> < 'e> -> prop) * (int -> < 'e> ->
                         < 'e> -> unit -> prop)) ->
                         (fun (cur:< 'e>) ->
                         (inv start cur) /\
                         (forall (i:int).
                          (start <= i) ->
                          ((i <= end_) ->
                           (forall (m:< 'e>).
                            (inv i m) ->
                            ((pre [int -> < 'e> -> prop,int -> < 'e> ->
                              < 'e> -> unit -> prop||] f i m)
                             /\
                             (forall (n:< 'e>).
                              (post [int -> < 'e> -> prop,int -> < 'e> ->
                               < 'e> -> unit -> prop||] f i m n tt)
                              -> (inv (i + 1) n))))))))
                         (fun (f:(int -> < 'e> -> prop) * (int -> < 'e> ->
                         < 'e> -> unit -> prop)) ->
                         (fun (old:< 'e>) ->
                         (fun (cur:< 'e>) ->
                         (fun (anon:unit) -> inv (max start (end_ + 1)) cur))))))) 
  let
    logic fordownto [||'e] = (fun (inv:int -> < 'e> -> prop) ->
                             (fun (start:int) ->
                             (fun (end_:int) ->
                             mk_2tuple [((int -> < 'e> -> prop) * (int ->
                             < 'e> -> < 'e> -> unit -> prop)) -> < 'e> ->
                             prop,((int -> < 'e> -> prop) * (int -> < 'e> ->
                             < 'e> -> unit -> prop)) -> < 'e> -> < 'e> ->
                             unit -> prop||]
                             (fun (f:(int -> < 'e> -> prop) * (int ->
                             < 'e> -> < 'e> -> unit -> prop)) ->
                             (fun (cur:< 'e>) ->
                             (inv start cur) /\
                             (forall (i:int).
                              (end_ <= i) ->
                              ((i <= start) ->
                               (forall (m:< 'e>).
                                (inv i m) ->
                                ((pre [int -> < 'e> -> prop,int -> < 'e> ->
                                  < 'e> -> unit -> prop||] f i m)
                                 /\
                                 (forall (n:< 'e>).
                                  (post [int -> < 'e> -> prop,int -> < 'e> ->
                                   < 'e> -> unit -> prop||] f i m n tt)
                                  -> (inv (i - 1) n))))))))
                             (fun (f:(int -> < 'e> -> prop) * (int ->
                             < 'e> -> < 'e> -> unit -> prop)) ->
                             (fun (old:< 'e>) ->
                             (fun (cur:< 'e>) ->
                             (fun (anon:unit) ->
                             inv (min start (end_ - 1)) cur))))))) 
  section Array coq "WhoArray"
    pangoline takeover
     type array['a||]
    logic ar_empty ['a||] : array[a]
    logic get ['a||] : int -> array[a] -> a
    logic set ['a||] : int -> a -> array[a] -> array[a]
    logic len ['a||] : array[a] -> int
    logic create ['a||] : int -> a -> array[a]
    axiom update_length : forall ['a||]. forall (t:array[a]).
                                         forall (i:int).
                                         forall (z:a).
                                         (len [a||] t) =[int||]
                                         (len [a||] (set [a||] i z t))
    axiom get_set_eq : forall ['a||]. forall (t:array[a]).
                                      forall (i:int).
                                      forall (z:a).
                                      (i < (len [a||] t)) ->
                                      (z =[a||]
                                       (get [a||] i (set [a||] i z t)))
    axiom length_empty : forall ['a||]. (len [a||] ar_empty [a||]) =[int||] 0
    axiom get_set_neq : forall ['a||]. forall (t:array[a]).
                                       forall (i:int).
                                       forall (j:int).
                                       forall (z:a).
                                       (i < (len [a||] t)) ->
                                       ((j < (len [a||] t)) ->
                                        ((i <>[int||] j) ->
                                         ((get [a||] i (set [a||] j z t))
                                          =[a||] (get [a||] i t))))
    axiom length_nonnegative : forall ['a||]. forall (t:array[a]).
                                              0 <= (len [a||] t)
    axiom length_create : forall ['a||]. forall (l:int).
                                         forall (v:a).
                                         (0 <= l) ->
                                         (l =[int||]
                                          (len [a||] (create [a||] l v)))
    axiom length_access : forall ['a||]. forall (i:int).
                                         forall (l:int).
                                         forall (v:a).
                                         (0 <= i) ->
                                         ((i <= l) ->
                                          (v =[a||]
                                           (get [a||] i (create [a||] l v)))) end
  section List coq "WhoList"
    pangoline takeover
     type list['a||]
    logic nil ['a||] : list[a]
    logic cons ['a||] : a -> list[a] -> list[a]
    logic is_nil ['a||] : list[a] -> bool
    logic l_in ['a||] : a -> list[a] -> prop end
  goal blit_correct : forall ['a|r
    r1|]. forall (ar:ref(r,array[a])).
          forall (ar1:ref(r1,array[a])).
          forall (ofs:int).
          forall (ofs1:int).
          forall (l:int).
          forall (s:<r r1 >).
          (0 <= l) ->
          ((0 <= ofs) ->
           ((0 <= ofs1) ->
            ((ofs <= ((len [a||] (!! [array[a]| r| {r r1 }] ar s)) - l)) ->
             ((ofs1 <= ((len [a||] (!! [array[a]| r1| {r r1 }] ar1 s)) - l))
              ->
              ((get_2_1_tuple [ref(r,array[a]) -> <r > ->
                prop,ref(r,array[a]) -> <r > -> <r > -> array[a] -> prop||]
                ! [array[a]| r|] ar (restrict [|| {r1 } {r }] s))
               /\
               (forall (s1:<r >).
                forall (anon:array[a]).
                (get_2_2_tuple [ref(r,array[a]) -> <r > ->
                 prop,ref(r,array[a]) -> <r > -> <r > -> array[a] -> prop||]
                 ! [array[a]| r|] ar (restrict [|| {r1 } {r }] s) s1 anon)
                ->
                ((get_2_1_tuple [ref(r1,array[a]) -> <r1 > ->
                  prop,ref(r1,array[a]) -> <r1 > -> <r1 > -> array[a] ->
                  prop||] ! [array[a]| r1|] ar1 (restrict [|| {r } {r1 }] s))
                 /\
                 (forall (s2:<r1 >).
                  forall (anon1:array[a]).
                  (get_2_2_tuple [ref(r1,array[a]) -> <r1 > ->
                   prop,ref(r1,array[a]) -> <r1 > -> <r1 > -> array[a] ->
                   prop||] ! [array[a]| r1|] ar1 (restrict [|| {r } {r1 }] s)
                   s2 anon1)
                  ->
                  (let logic l1 = len [a||] anon1 in
                   ((ofs < ofs1) ->
                    (let logic __start = l1 - 1 in
                     let logic __end = 0 in
                     ((forall (i:int).
                       forall (s3:<r r1 >).
                       (anon =[array[a]||] (!! [array[a]| r| {r r1 }] ar s3))
                       ->
                       ((l1 =[int||]
                         (len [a||] (!! [array[a]| r1| {r r1 }] ar1 s3)))
                        ->
                        ((__end <= i) ->
                         ((i <= __start) ->
                          ((forall (k:int).
                            (i < k) ->
                            ((k <= (l1 - 1)) ->
                             ((get [a||] (ofs1 + k)
                               (!! [array[a]| r1| {r r1 }] ar1 s3))
                              =[a||]
                              (get [a||] (ofs + k)
                               (!! [array[a]| r| {r r1 }] ar s3)))))
                           ->
                           ((get_2_1_tuple [ref(r,array[a]) -> <r > ->
                             prop,ref(r,array[a]) -> <r > -> <r > ->
                             array[a] -> prop||] ! [array[a]| r|] ar
                             (restrict [|| {r1 } {r }] s3))
                            /\
                            (forall (s4:<r >).
                             forall (anon2:array[a]).
                             (get_2_2_tuple [ref(r,array[a]) -> <r > ->
                              prop,ref(r,array[a]) -> <r > -> <r > ->
                              array[a] -> prop||] ! [array[a]| r|] ar
                              (restrict [|| {r1 } {r }] s3) s4 anon2)
                             ->
                             ((get_2_1_tuple [ref(r1,array[a]) -> <r1 > ->
                               prop,ref(r1,array[a]) -> <r1 > -> <r1 > ->
                               array[a] -> prop||] ! [array[a]| r1|] ar1
                               (restrict [|| {r } {r1 }] s3))
                              /\
                              (forall (s5:<r1 >).
                               forall (anon3:array[a]).
                               (get_2_2_tuple [ref(r1,array[a]) -> <r1 > ->
                                prop,ref(r1,array[a]) -> <r1 > -> <r1 > ->
                                array[a] -> prop||] ! [array[a]| r1|] ar1
                                (restrict [|| {r } {r1 }] s3) s5 anon3)
                               ->
                               ((get_2_1_tuple [array[a] -> <r1 > ->
                                 prop,array[a] -> <r1 > -> <r1 > -> unit ->
                                 prop||] ((:= [array[a]| r1|]) ar1)
                                 (set [a||] (ofs1 + i)
                                  (get [a||] (ofs + i) anon2) anon3)
                                 s5)
                                /\
                                (forall (s6:<r1 >).
                                 (get_2_2_tuple [array[a] -> <r1 > ->
                                  prop,array[a] -> <r1 > -> <r1 > -> unit ->
                                  prop||] ((:= [array[a]| r1|]) ar1)
                                  (set [a||] (ofs1 + i)
                                   (get [a||] (ofs + i) anon2) anon3)
                                  s5 s6 tt)
                                 ->
                                 (((anon =[array[a]||]
                                    (!! [array[a]| r| {r r1 }] ar
                                     (combine [|| {r } { } {r1 }] s4 s6)))
                                   /\
                                   (l1 =[int||]
                                    (len [a||]
                                     (!! [array[a]| r1| {r r1 }] ar1
                                      (combine [|| {r } { } {r1 }] s4 s6)))))
                                  /\
                                  (forall (k:int).
                                   ((i - 1) < k) ->
                                   ((k <= (l1 - 1)) ->
                                    ((get [a||] (ofs1 + k)
                                      (!! [array[a]| r1| {r r1 }] ar1
                                       (combine [|| {r } { } {r1 }] s4 s6)))
                                     =[a||]
                                     (get [a||] (ofs + k)
                                      (!! [array[a]| r| {r r1 }] ar
                                       (combine [|| {r } { } {r1 }] s4 s6))))))))))))))))))
                      /\
                      (get_2_1_tuple [((int -> <r r1 > -> prop) * (int -> <r
                       r1 > -> <r r1 > -> unit -> prop)) -> <r r1 > ->
                       prop,((int -> <r r1 > -> prop) * (int -> <r r1 > -> <r
                       r1 > -> unit -> prop)) -> <r r1 > -> <r r1 > ->
                       unit -> prop||]
                       (fordownto [|| {r r1 }]
                        (fun (i:int) ->
                        (fun (cur:<r r1 >) ->
                        ((anon =[array[a]||]
                          (!! [array[a]| r| {r r1 }] ar cur))
                         /\
                         (l1 =[int||]
                          (len [a||] (!! [array[a]| r1| {r r1 }] ar1 cur))))
                        /\
                        (forall (k:int).
                         (i < k) ->
                         ((k <= (l1 - 1)) ->
                          ((get [a||] (ofs1 + k)
                            (!! [array[a]| r1| {r r1 }] ar1 cur))
                           =[a||]
                           (get [a||] (ofs + k)
                            (!! [array[a]| r| {r r1 }] ar cur)))))))
                        __start __end)
                       (mk_2tuple [int -> <r r1 > -> prop,int -> <r r1 > ->
                        <r r1 > -> unit -> prop||]
                        (fun (i:int) ->
                        (fun (cur:<r r1 >) ->
                        ((__end <= i) /\ (i <= __start)) /\
                        (((anon =[array[a]||]
                           (!! [array[a]| r| {r r1 }] ar cur))
                          /\
                          (l1 =[int||]
                           (len [a||] (!! [array[a]| r1| {r r1 }] ar1 cur))))
                         /\
                         (forall (k:int).
                          (i < k) ->
                          ((k <= (l1 - 1)) ->
                           ((get [a||] (ofs1 + k)
                             (!! [array[a]| r1| {r r1 }] ar1 cur))
                            =[a||]
                            (get [a||] (ofs + k)
                             (!! [array[a]| r| {r r1 }] ar cur))))))))
                        (fun (i:int) ->
                        (fun (anon2:<r r1 >) ->
                        (fun (cur:<r r1 >) ->
                        (fun (anon3:unit) ->
                        ((anon =[array[a]||]
                          (!! [array[a]| r| {r r1 }] ar cur))
                         /\
                         (l1 =[int||]
                          (len [a||] (!! [array[a]| r1| {r r1 }] ar1 cur))))
                        /\
                        (forall (k:int).
                         ((i - 1) < k) ->
                         ((k <= (l1 - 1)) ->
                          ((get [a||] (ofs1 + k)
                            (!! [array[a]| r1| {r r1 }] ar1 cur))
                           =[a||]
                           (get [a||] (ofs + k)
                            (!! [array[a]| r| {r r1 }] ar cur))))))))))
                       (combine [|| {r } { } {r1 }] s1 s2)))
                     /\
                     (forall (s3:<r r1 >).
                      (get_2_2_tuple [((int -> <r r1 > -> prop) * (int -> <r
                       r1 > -> <r r1 > -> unit -> prop)) -> <r r1 > ->
                       prop,((int -> <r r1 > -> prop) * (int -> <r r1 > -> <r
                       r1 > -> unit -> prop)) -> <r r1 > -> <r r1 > ->
                       unit -> prop||]
                       (fordownto [|| {r r1 }]
                        (fun (i:int) ->
                        (fun (cur:<r r1 >) ->
                        ((anon =[array[a]||]
                          (!! [array[a]| r| {r r1 }] ar cur))
                         /\
                         (l1 =[int||]
                          (len [a||] (!! [array[a]| r1| {r r1 }] ar1 cur))))
                        /\
                        (forall (k:int).
                         (i < k) ->
                         ((k <= (l1 - 1)) ->
                          ((get [a||] (ofs1 + k)
                            (!! [array[a]| r1| {r r1 }] ar1 cur))
                           =[a||]
                           (get [a||] (ofs + k)
                            (!! [array[a]| r| {r r1 }] ar cur)))))))
                        __start __end)
                       (mk_2tuple [int -> <r r1 > -> prop,int -> <r r1 > ->
                        <r r1 > -> unit -> prop||]
                        (fun (i:int) ->
                        (fun (cur:<r r1 >) ->
                        ((__end <= i) /\ (i <= __start)) /\
                        (((anon =[array[a]||]
                           (!! [array[a]| r| {r r1 }] ar cur))
                          /\
                          (l1 =[int||]
                           (len [a||] (!! [array[a]| r1| {r r1 }] ar1 cur))))
                         /\
                         (forall (k:int).
                          (i < k) ->
                          ((k <= (l1 - 1)) ->
                           ((get [a||] (ofs1 + k)
                             (!! [array[a]| r1| {r r1 }] ar1 cur))
                            =[a||]
                            (get [a||] (ofs + k)
                             (!! [array[a]| r| {r r1 }] ar cur))))))))
                        (fun (i:int) ->
                        (fun (anon2:<r r1 >) ->
                        (fun (cur:<r r1 >) ->
                        (fun (anon3:unit) ->
                        ((anon =[array[a]||]
                          (!! [array[a]| r| {r r1 }] ar cur))
                         /\
                         (l1 =[int||]
                          (len [a||] (!! [array[a]| r1| {r r1 }] ar1 cur))))
                        /\
                        (forall (k:int).
                         ((i - 1) < k) ->
                         ((k <= (l1 - 1)) ->
                          ((get [a||] (ofs1 + k)
                            (!! [array[a]| r1| {r r1 }] ar1 cur))
                           =[a||]
                           (get [a||] (ofs + k)
                            (!! [array[a]| r| {r r1 }] ar cur))))))))))
                       (combine [|| {r } { } {r1 }] s1 s2) s3 tt)
                      ->
                      ((((!! [array[a]| r| {r r1 }] ar s) =[array[a]||]
                         (!! [array[a]| r| {r r1 }] ar s3))
                        /\
                        ((len [a||] (!! [array[a]| r1| {r r1 }] ar1 s3))
                         =[int||]
                         (len [a||] (!! [array[a]| r1| {r r1 }] ar1 s))))
                       /\
                       (forall (k:int).
                        (0 <= k) ->
                        ((k < l) ->
                         ((get [a||] (ofs1 + k)
                           (!! [array[a]| r1| {r r1 }] ar1 s3))
                          =[a||]
                          (get [a||] (ofs + k)
                           (!! [array[a]| r| {r r1 }] ar s3)))))))))
                   /\
                   ((~ (ofs < ofs1)) ->
                    (let logic __start = 0 in
                     let logic __end = l1 - 1 in
                     ((forall (i:int).
                       forall (s3:<r r1 >).
                       (anon =[array[a]||] (!! [array[a]| r| {r r1 }] ar s3))
                       ->
                       ((l1 =[int||]
                         (len [a||] (!! [array[a]| r1| {r r1 }] ar1 s3)))
                        ->
                        ((__start <= i) ->
                         ((i <= __end) ->
                          ((forall (k:int).
                            (0 <= k) ->
                            ((k < i) ->
                             ((get [a||] (ofs1 + k)
                               (!! [array[a]| r1| {r r1 }] ar1 s3))
                              =[a||]
                              (get [a||] (ofs + k)
                               (!! [array[a]| r| {r r1 }] ar s3)))))
                           ->
                           ((get_2_1_tuple [ref(r,array[a]) -> <r > ->
                             prop,ref(r,array[a]) -> <r > -> <r > ->
                             array[a] -> prop||] ! [array[a]| r|] ar
                             (restrict [|| {r1 } {r }] s3))
                            /\
                            (forall (s4:<r >).
                             forall (anon2:array[a]).
                             (get_2_2_tuple [ref(r,array[a]) -> <r > ->
                              prop,ref(r,array[a]) -> <r > -> <r > ->
                              array[a] -> prop||] ! [array[a]| r|] ar
                              (restrict [|| {r1 } {r }] s3) s4 anon2)
                             ->
                             ((get_2_1_tuple [ref(r1,array[a]) -> <r1 > ->
                               prop,ref(r1,array[a]) -> <r1 > -> <r1 > ->
                               array[a] -> prop||] ! [array[a]| r1|] ar1
                               (restrict [|| {r } {r1 }] s3))
                              /\
                              (forall (s5:<r1 >).
                               forall (anon3:array[a]).
                               (get_2_2_tuple [ref(r1,array[a]) -> <r1 > ->
                                prop,ref(r1,array[a]) -> <r1 > -> <r1 > ->
                                array[a] -> prop||] ! [array[a]| r1|] ar1
                                (restrict [|| {r } {r1 }] s3) s5 anon3)
                               ->
                               ((get_2_1_tuple [array[a] -> <r1 > ->
                                 prop,array[a] -> <r1 > -> <r1 > -> unit ->
                                 prop||] ((:= [array[a]| r1|]) ar1)
                                 (set [a||] (ofs1 + i)
                                  (get [a||] (ofs + i) anon2) anon3)
                                 s5)
                                /\
                                (forall (s6:<r1 >).
                                 (get_2_2_tuple [array[a] -> <r1 > ->
                                  prop,array[a] -> <r1 > -> <r1 > -> unit ->
                                  prop||] ((:= [array[a]| r1|]) ar1)
                                  (set [a||] (ofs1 + i)
                                   (get [a||] (ofs + i) anon2) anon3)
                                  s5 s6 tt)
                                 ->
                                 (((anon =[array[a]||]
                                    (!! [array[a]| r| {r r1 }] ar
                                     (combine [|| {r } { } {r1 }] s4 s6)))
                                   /\
                                   (l1 =[int||]
                                    (len [a||]
                                     (!! [array[a]| r1| {r r1 }] ar1
                                      (combine [|| {r } { } {r1 }] s4 s6)))))
                                  /\
                                  (forall (k:int).
                                   (0 <= k) ->
                                   ((k < (i + 1)) ->
                                    ((get [a||] (ofs1 + k)
                                      (!! [array[a]| r1| {r r1 }] ar1
                                       (combine [|| {r } { } {r1 }] s4 s6)))
                                     =[a||]
                                     (get [a||] (ofs + k)
                                      (!! [array[a]| r| {r r1 }] ar
                                       (combine [|| {r } { } {r1 }] s4 s6))))))))))))))))))
                      /\
                      (get_2_1_tuple [((int -> <r r1 > -> prop) * (int -> <r
                       r1 > -> <r r1 > -> unit -> prop)) -> <r r1 > ->
                       prop,((int -> <r r1 > -> prop) * (int -> <r r1 > -> <r
                       r1 > -> unit -> prop)) -> <r r1 > -> <r r1 > ->
                       unit -> prop||]
                       (forto [|| {r r1 }]
                        (fun (i:int) ->
                        (fun (cur:<r r1 >) ->
                        ((anon =[array[a]||]
                          (!! [array[a]| r| {r r1 }] ar cur))
                         /\
                         (l1 =[int||]
                          (len [a||] (!! [array[a]| r1| {r r1 }] ar1 cur))))
                        /\
                        (forall (k:int).
                         (0 <= k) ->
                         ((k < i) ->
                          ((get [a||] (ofs1 + k)
                            (!! [array[a]| r1| {r r1 }] ar1 cur))
                           =[a||]
                           (get [a||] (ofs + k)
                            (!! [array[a]| r| {r r1 }] ar cur)))))))
                        __start __end)
                       (mk_2tuple [int -> <r r1 > -> prop,int -> <r r1 > ->
                        <r r1 > -> unit -> prop||]
                        (fun (i:int) ->
                        (fun (cur:<r r1 >) ->
                        ((__start <= i) /\ (i <= __end)) /\
                        (((anon =[array[a]||]
                           (!! [array[a]| r| {r r1 }] ar cur))
                          /\
                          (l1 =[int||]
                           (len [a||] (!! [array[a]| r1| {r r1 }] ar1 cur))))
                         /\
                         (forall (k:int).
                          (0 <= k) ->
                          ((k < i) ->
                           ((get [a||] (ofs1 + k)
                             (!! [array[a]| r1| {r r1 }] ar1 cur))
                            =[a||]
                            (get [a||] (ofs + k)
                             (!! [array[a]| r| {r r1 }] ar cur))))))))
                        (fun (i:int) ->
                        (fun (anon2:<r r1 >) ->
                        (fun (cur:<r r1 >) ->
                        (fun (anon3:unit) ->
                        ((anon =[array[a]||]
                          (!! [array[a]| r| {r r1 }] ar cur))
                         /\
                         (l1 =[int||]
                          (len [a||] (!! [array[a]| r1| {r r1 }] ar1 cur))))
                        /\
                        (forall (k:int).
                         (0 <= k) ->
                         ((k < (i + 1)) ->
                          ((get [a||] (ofs1 + k)
                            (!! [array[a]| r1| {r r1 }] ar1 cur))
                           =[a||]
                           (get [a||] (ofs + k)
                            (!! [array[a]| r| {r r1 }] ar cur))))))))))
                       (combine [|| {r } { } {r1 }] s1 s2)))
                     /\
                     (forall (s3:<r r1 >).
                      (get_2_2_tuple [((int -> <r r1 > -> prop) * (int -> <r
                       r1 > -> <r r1 > -> unit -> prop)) -> <r r1 > ->
                       prop,((int -> <r r1 > -> prop) * (int -> <r r1 > -> <r
                       r1 > -> unit -> prop)) -> <r r1 > -> <r r1 > ->
                       unit -> prop||]
                       (forto [|| {r r1 }]
                        (fun (i:int) ->
                        (fun (cur:<r r1 >) ->
                        ((anon =[array[a]||]
                          (!! [array[a]| r| {r r1 }] ar cur))
                         /\
                         (l1 =[int||]
                          (len [a||] (!! [array[a]| r1| {r r1 }] ar1 cur))))
                        /\
                        (forall (k:int).
                         (0 <= k) ->
                         ((k < i) ->
                          ((get [a||] (ofs1 + k)
                            (!! [array[a]| r1| {r r1 }] ar1 cur))
                           =[a||]
                           (get [a||] (ofs + k)
                            (!! [array[a]| r| {r r1 }] ar cur)))))))
                        __start __end)
                       (mk_2tuple [int -> <r r1 > -> prop,int -> <r r1 > ->
                        <r r1 > -> unit -> prop||]
                        (fun (i:int) ->
                        (fun (cur:<r r1 >) ->
                        ((__start <= i) /\ (i <= __end)) /\
                        (((anon =[array[a]||]
                           (!! [array[a]| r| {r r1 }] ar cur))
                          /\
                          (l1 =[int||]
                           (len [a||] (!! [array[a]| r1| {r r1 }] ar1 cur))))
                         /\
                         (forall (k:int).
                          (0 <= k) ->
                          ((k < i) ->
                           ((get [a||] (ofs1 + k)
                             (!! [array[a]| r1| {r r1 }] ar1 cur))
                            =[a||]
                            (get [a||] (ofs + k)
                             (!! [array[a]| r| {r r1 }] ar cur))))))))
                        (fun (i:int) ->
                        (fun (anon2:<r r1 >) ->
                        (fun (cur:<r r1 >) ->
                        (fun (anon3:unit) ->
                        ((anon =[array[a]||]
                          (!! [array[a]| r| {r r1 }] ar cur))
                         /\
                         (l1 =[int||]
                          (len [a||] (!! [array[a]| r1| {r r1 }] ar1 cur))))
                        /\
                        (forall (k:int).
                         (0 <= k) ->
                         ((k < (i + 1)) ->
                          ((get [a||] (ofs1 + k)
                            (!! [array[a]| r1| {r r1 }] ar1 cur))
                           =[a||]
                           (get [a||] (ofs + k)
                            (!! [array[a]| r| {r r1 }] ar cur))))))))))
                       (combine [|| {r } { } {r1 }] s1 s2) s3 tt)
                      ->
                      ((((!! [array[a]| r| {r r1 }] ar s) =[array[a]||]
                         (!! [array[a]| r| {r r1 }] ar s3))
                        /\
                        ((len [a||] (!! [array[a]| r1| {r r1 }] ar1 s3))
                         =[int||]
                         (len [a||] (!! [array[a]| r1| {r r1 }] ar1 s))))
                       /\
                       (forall (k:int).
                        (0 <= k) ->
                        ((k < l) ->
                         ((get [a||] (ofs1 + k)
                           (!! [array[a]| r1| {r r1 }] ar1 s3))
                          =[a||]
                          (get [a||] (ofs + k)
                           (!! [array[a]| r| {r r1 }] ar s3))))))))))))))))))
  let logic blit ['a|r
    r1|] = (fun (ar:ref(r,array[a])) ->
           (fun (ar1:ref(r1,array[a])) ->
           (fun (ofs:int) ->
           (fun (ofs1:int) ->
           mk_2tuple [int -> <r r1 > -> prop,int -> <r r1 > -> <r r1 > ->
           unit -> prop||]
           (fun (l:int) ->
           (fun (cur:<r r1 >) ->
           ((((0 <= l) /\ (0 <= ofs)) /\ (0 <= ofs1)) /\
            (ofs <= ((len [a||] (!! [array[a]| r| {r r1 }] ar cur)) - l)))
           /\
           (ofs1 <= ((len [a||] (!! [array[a]| r1| {r r1 }] ar1 cur)) - l))))
           (fun (l:int) ->
           (fun (old:<r r1 >) ->
           (fun (cur:<r r1 >) ->
           (fun (anon:unit) ->
           (((!! [array[a]| r| {r r1 }] ar old) =[array[a]||]
             (!! [array[a]| r| {r r1 }] ar cur))
            /\
            ((len [a||] (!! [array[a]| r1| {r r1 }] ar1 cur)) =[int||]
             (len [a||] (!! [array[a]| r1| {r r1 }] ar1 old))))
           /\
           (forall (k:int).
            (0 <= k) ->
            ((k < l) ->
             ((get [a||] (ofs1 + k) (!! [array[a]| r1| {r r1 }] ar1 cur))
              =[a||] (get [a||] (ofs + k) (!! [array[a]| r| {r r1 }] ar cur)))))))))))))  end
