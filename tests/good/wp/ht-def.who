type bool
logic true  : bool
logic false  : bool
logic = ['a||] : (a) -> (a) -> prop
logic /\  : prop -> prop -> prop
logic \/  : prop -> prop -> prop
logic ->  : prop -> prop -> prop
logic , ['a 'b||] : 'a -> 'b -> 'a * 'b
  logic fst ['a 'b||] : 'a * 'b -> 'a
  logic snd ['a 'b||] : 'a * 'b -> 'b
type hmap['a1
'b||]
logic hmem ['a2 'b1||] : (a2) -> (hmap[(a2),(b1)||]) -> bool
logic hget ['a3 'b2||] : (a3) -> (hmap[(a3),(b2)||]) -> b2
logic hset ['a4 'b3||] : (a4) -> (b3) -> (hmap[(a4),(b3)||]) ->
  hmap[(a4),(b3)||]
type unit
logic tt  : unit
logic !! ['a5|r|'e] : ref(r,a5) -> <r  'e > -> a5
let
  ! ['a6|r1|] = (fun (x:ref(r1,a6)) -> {(fun (cur:<r1  >) -> True)}
                parameter(a6,{r1  })
                {(fun (old:<r1  >) ->
                 (fun (cur1:<r1  >) ->
                 (fun (r2:a6) ->
                 ((!! [a6| r1| { }] x cur1) =[a6||] r2) /\
                 ((!! [a6| r1| { }] x old) =[a6||] (!! [a6| r1| { }] x cur1)))))}) 
let
  := ['a7|r3|] = (fun (x1:ref(r3,a7)) ->
                 (fun (v:a7) -> {(fun (cur2:<r3  >) -> True)}
                 parameter(unit,{r3  })
                 {(fun (old1:<r3  >) ->
                  (fun (cur3:<r3  >) ->
                  (fun (anon:unit) -> (!! [a7| r3| { }] x1 cur3) =[a7||] v)))})) 
let
  stores  = (fun (f:int -> int) ->
            (fun (m:hmap[int,int||]) ->
            forall (x2:int).
            ((hmem [int,int||] x2 m) =[bool||] true) ->
            ((hget [int,int||] x2 m) =[int||] (f x2)))) 
letregion t
logic table  : ref(t,hmap[int,int||])
let
  realizes  = (fun (f1:int -> int) ->
              (fun (f2:int ->{t  } int) ->
              forall (x3:int).
              [[(fun (cur4:<t  >) ->
                stores f1 (!! [hmap[int,int||]| t| { }] table cur4))]]
              f2 x3[[(fun (old2:<t  >) ->
                     (fun (cur5:<t  >) ->
                     (fun (anon1:int) ->
                     stores f1 (!! [hmap[int,int||]| t| { }] table cur5))))]])) 
