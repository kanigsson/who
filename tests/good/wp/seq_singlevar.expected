forall (s:<{|}>),
section basiclogic Coq 
 let /\ = logic Prop -> Prop -> Prop in
 let \/ = logic Prop -> Prop -> Prop in
 let -> = logic Prop -> Prop -> Prop in
 let ~ = logic Prop -> Prop in
 let = [a||]= logic a -> a -> Prop in
 let <> [a1||]= logic a1 -> a1 -> Prop in
 let fst [a2 b||]= logic (a2 * b) -> a2 in
 let snd [a3 b1||]= logic (a3 * b1) -> b1 in
 let , [a4 b2||]= logic a4 -> b2 -> a4 * b2 in end
  section arith Coq WhoArith
   let + = logic int -> int -> int in
   let - = logic int -> int -> int in
   let * = logic int -> int -> int in
   let < = logic int -> int -> Prop in
   let <= = logic int -> int -> Prop in
   let > = logic int -> int -> Prop in
   let >= = logic int -> int -> Prop in
   let << = logic int -> int -> bool in
   let <<= = logic int -> int -> bool in
   let >> = logic int -> int -> bool in
   let >>= = logic int -> int -> bool in
   let max = logic int -> int -> int in
   let min = logic int -> int -> int in
   let mod = logic int -> int -> int in end
    let == [a5||]= logic a5 -> a5 -> bool in
    let != [a6||]= logic a6 -> a6 -> bool in
    section Whoref Coq WhoMap
     let !! [a7|r|e]= logic ref(r,a7) -> <{|e }> -> a7 in
     let
     ! [a8|r1|]=
                (λ(x:ref(r1,a8)) -> (λ(s1:<{r1 |}>) -> True)) ,
                (λ(x:ref(r1,a8)) ->
                (λ(old:<{r1 |}>) ->
                (λ(cur:<{r1 |}>) ->
                (λ(r2:a8) ->
                ((!! [a8|r1|{r1 |}] x cur) = r2) /\
                ((!! [a8|r1|{r1 |}] x old) = (!! [a8|r1|{r1 |}] x cur))))))
     in
     let
     := [a9|r3|]=
                 (λ(x1:ref(r3,a9)) ->
                 (λ(v:a9) -> (λ(s2:<{r3 |}>) -> True)) ,
                 (λ(v:a9) ->
                 (λ(old1:<{r3 |}>) ->
                 (λ(cur1:<{r3 |}>) ->
                 (λ(anon:unit) -> (!! [a9|r3|{r3 |}] x1 cur1) = v)))))
     in
     let
     ref [a10|r4|]=
                   (λ(v1:a10) -> (λ(s3:<{r4 |}>) -> True)) ,
                   (λ(v1:a10) ->
                   (λ(old2:<{r4 ||r4 }>) ->
                   (λ(cur2:<{r4 ||r4 }>) ->
                   (λ(x2:ref(r4,a10)) ->
                   (!! [a10|r4|{r4 ||r4 }] x2 cur2) = v1))))
     in
     let combine [||e1 e2]= logic <{|e1 }> -> <{|e2 }> -> <{|e1 e2 }> in
     let restrict [||e11 e21]= logic <{|e11 }> -> <{|e21 }> in
     let empty = logic <{|}> in type kmap =  in type key =  in
     let kcombine [||e12 e22]= logic (kmap) -> (kmap) -> kmap in
     let krestrict [||e13 e23]= logic (kmap) -> kmap in
     let kset [a11||]= logic (key) -> a11 -> (kmap) -> kmap in
     let kget [a12|r5|]= logic ref(r5,a12) -> (kmap) -> a12 in
     let kempty = logic kmap in
     let pre [a13 b3||]= (λ(x3:a13 * b3) -> fst [a13,b3||] x3) in
     let post [a14 b4||]= (λ(x4:a14 * b4) -> snd [a14,b4||] x4) in end
      let
      forto [||e1]=
                   (λ(inv:int -> <{|e1 }> -> Prop) ->
                   (λ(start:int) ->
                   (λ(end_:int) ->
                   (λ(f:(int -> <{|e1 }> -> Prop) * (int -> <{|e1 }> ->
                   <{|e1 }> -> unit -> Prop)) ->
                   (λ(cur3:<{|e1 }>) ->
                   (inv start cur3) /\
                   (forall (i:int),
                    ((start <= i) /\ (i <= end_)) ->
                    (forall (m:<{|e1 }>),
                     (inv i m) ->
                     ((pre [int -> <{|e1 }> -> Prop,int -> <{|e1 }> -> <{|e1
                       }> -> unit -> Prop||] f i m)
                      /\
                      (forall (n:<{|e1 }>),
                       (post [int -> <{|e1 }> -> Prop,int -> <{|e1 }> ->
                        <{|e1 }> -> unit -> Prop||] f i m n tt)
                       -> (inv (i + 1) n)))))))
                   ,
                   (λ(f:(int -> <{|e1 }> -> Prop) * (int -> <{|e1 }> ->
                   <{|e1 }> -> unit -> Prop)) ->
                   (λ(old3:<{|e1 }>) ->
                   (λ(cur4:<{|e1 }>) ->
                   (λ(anon1:unit) -> inv (max start (end_ + 1)) cur4)))))))
      in
      let
      fordownto [||e2]=
                       (λ(inv1:int -> <{|e2 }> -> Prop) ->
                       (λ(start1:int) ->
                       (λ(end_1:int) ->
                       (λ(f1:(int -> <{|e2 }> -> Prop) * (int -> <{|e2 }> ->
                       <{|e2 }> -> unit -> Prop)) ->
                       (λ(cur5:<{|e2 }>) ->
                       (inv1 start1 cur5) /\
                       (forall (i1:int),
                        ((start1 <= i1) /\ (i1 <= end_1)) ->
                        (forall (m1:<{|e2 }>),
                         (inv1 i1 m1) ->
                         ((pre [int -> <{|e2 }> -> Prop,int -> <{|e2 }> ->
                           <{|e2 }> -> unit -> Prop||] f1 i1 m1)
                          /\
                          (forall (n1:<{|e2 }>),
                           (post [int -> <{|e2 }> -> Prop,int -> <{|e2 }> ->
                            <{|e2 }> -> unit -> Prop||] f1 i1 m1 n1 tt)
                           -> (inv1 (i1 - 1) n1)))))))
                       ,
                       (λ(f1:(int -> <{|e2 }> -> Prop) * (int -> <{|e2 }> ->
                       <{|e2 }> -> unit -> Prop)) ->
                       (λ(old4:<{|e2 }>) ->
                       (λ(cur6:<{|e2 }>) ->
                       (λ(anon2:unit) -> inv1 (min start1 (end_1 - 1)) cur6)))))))
      in
      section Array Coq WhoArray type array[a15||] =  in
      let get [a16||]= logic int -> (array[a16||]) -> a16 in
      let set [a17||]= logic int -> a17 -> (array[a17||]) -> array[a17||] in
      let len [a18||]= logic (array[a18||]) -> int in
      let
      update_length [a19||]=
                            axiom forall (t:array[a19||]),
                                  forall (i2:int),
                                  forall (z:a19),
                                  (len [a19||] t) =
                                  (len [a19||] (set [a19||] i2 z t))
      in
      let
      get_set_eq [a20||]=
                         axiom forall (t1:array[a20||]),
                               forall (i3:int),
                               forall (z1:a20),
                               (i3 < (len [a20||] t1)) ->
                               ((get [a20||] i3 (set [a20||] i3 z1 t1)) = z1)
      in
      let
      get_set_neq [a21||]=
                          axiom forall (t2:array[a21||]),
                                forall (i4:int),
                                forall (j:int),
                                forall (z2:a21),
                                (i4 < (len [a21||] t2)) ->
                                ((j < (len [a21||] t2)) ->
                                 ((i4 <> j) ->
                                  ((get [a21||] i4 (set [a21||] j z2 t2)) =
                                   (get [a21||] i4 t2))))
      in
      let
      length_nonnegative [a22||]=
                                 axiom forall (t3:array[a22||]),
                                       0 <= (len [a22||] t3)
      in end
       section List Coq WhoList type list[a23||] =  in
       let nil [a24||]= logic list[a24||] in
       let cons [a25||]= logic a25 -> (list[a25||]) -> list[a25||] in
       let is_nil [a26||]= logic (list[a26||]) -> bool in
       let l_in [a27||]= logic a27 -> (list[a27||]) -> Prop in end
        (forall [||e3], forall (f2:(unit -> <{|e3 }> -> Prop) * (unit ->
                        <{|e3 }> -> <{|e3 }> -> unit -> Prop)),
                        forall (s4:<{|e3 }>),
                        forall (g:(unit -> <{|e3 }> -> Prop) * (unit -> <{|e3
                        }> -> <{|e3 }> -> unit -> Prop)),
                        ((λ(cur7:<{|e3 }>) ->
                         (fst [unit -> <{|e3 }> -> Prop,unit -> <{|e3 }> ->
                          <{|e3 }> -> unit -> Prop||] f2 tt cur7)
                         /\
                         (forall (i5:<{|e3 }>),
                          (True /\
                           (snd [unit -> <{|e3 }> -> Prop,unit -> <{|e3 }> ->
                            <{|e3 }> -> unit -> Prop||] f2 tt cur7 i5 tt))
                          ->
                          (fst [unit -> <{|e3 }> -> Prop,unit -> <{|e3 }> ->
                           <{|e3 }> -> unit -> Prop||] g tt i5)))
                         s4)
                        ->
                        ((fst [unit -> <{|e3 }> -> Prop,unit -> <{|e3 }> ->
                          <{|e3 }> -> unit -> Prop||] f2 tt s4)
                         /\
                         (forall (s5:<{|e3 }>),
                          forall (anon3:unit),
                          (snd [unit -> <{|e3 }> -> Prop,unit -> <{|e3 }> ->
                           <{|e3 }> -> unit -> Prop||] f2 tt s4 s5 anon3)
                          ->
                          ((λ(s6:<{|e3 }>) ->
                           (λ(x5:unit) ->
                           (fst [unit -> <{|e3 }> -> Prop,unit -> <{|e3 }> ->
                            <{|e3 }> -> unit -> Prop||] g tt s6)
                           /\
                           (forall (s7:<{|e3 }>),
                            forall (anon4:unit),
                            (snd [unit -> <{|e3 }> -> Prop,unit -> <{|e3
                             }> -> <{|e3 }> -> unit -> Prop||] g tt s6 s7
                             anon4)
                            ->
                            ((λ(old5:<{|e3 }>) ->
                             (λ(cur8:<{|e3 }>) ->
                             (λ(anon5:unit) ->
                             exists i6:<{|e3 }>,
                             (snd [unit -> <{|e3 }> -> Prop,unit -> <{|e3
                              }> -> <{|e3 }> -> unit -> Prop||] f2 tt old5 i6
                              tt)
                             /\
                             (snd [unit -> <{|e3 }> -> Prop,unit -> <{|e3
                              }> -> <{|e3 }> -> unit -> Prop||] g tt i6 cur8
                              tt))))
                             s4 s7 anon4))))
                           s5 anon3))))
        /\
        (let
         seq [||e3]=
                    (λ(f2:(unit -> <{|e3 }> -> Prop) * (unit -> <{|e3 }> ->
                    <{|e3 }> -> unit -> Prop)) ->
                    (λ(g:(unit -> <{|e3 }> -> Prop) * (unit -> <{|e3 }> ->
                    <{|e3 }> -> unit -> Prop)) ->
                    (λ(cur7:<{|e3 }>) ->
                    (fst [unit -> <{|e3 }> -> Prop,unit -> <{|e3 }> -> <{|e3
                     }> -> unit -> Prop||] f2 tt cur7)
                    /\
                    (forall (i5:<{|e3 }>),
                     (True /\
                      (snd [unit -> <{|e3 }> -> Prop,unit -> <{|e3 }> ->
                       <{|e3 }> -> unit -> Prop||] f2 tt cur7 i5 tt))
                     ->
                     (fst [unit -> <{|e3 }> -> Prop,unit -> <{|e3 }> -> <{|e3
                      }> -> unit -> Prop||] g tt i5))))
                    ,
                    (λ(g:(unit -> <{|e3 }> -> Prop) * (unit -> <{|e3 }> ->
                    <{|e3 }> -> unit -> Prop)) ->
                    (λ(old5:<{|e3 }>) ->
                    (λ(cur8:<{|e3 }>) ->
                    (λ(anon5:unit) ->
                    exists i6:<{|e3 }>,
                    (snd [unit -> <{|e3 }> -> Prop,unit -> <{|e3 }> -> <{|e3
                     }> -> unit -> Prop||] f2 tt old5 i6 tt)
                    /\
                    (snd [unit -> <{|e3 }> -> Prop,unit -> <{|e3 }> -> <{|e3
                     }> -> unit -> Prop||] g tt i6 cur8 tt))))))
         in
         (forall [|r6|], forall (s8:<{r6 |}>),
                         forall (x6:ref(r6,int)),
                         (((forall (s9:<{r6 |}>),
                            forall (z3:unit),
                            (fst [int -> <{r6 |}> -> Prop,int -> <{r6 |}> ->
                             <{r6 |}> -> unit -> Prop||] (:= [int|r6|] x6) 0
                             s9)
                            /\
                            (forall (s10:<{r6 |}>),
                             forall (anon6:unit),
                             (snd [int -> <{r6 |}> -> Prop,int -> <{r6 |}> ->
                              <{r6 |}> -> unit -> Prop||] (:= [int|r6|] x6) 0
                              s9 s10 anon6)
                             ->
                             ((λ(old6:<{r6 |}>) ->
                              (λ(cur9:<{r6 |}>) ->
                              (λ(anon7:unit) ->
                              (!! [int|r6|{r6 |}] x6 cur9) = 0))) s9 s10
                              anon6)))
                           /\
                           (forall (s11:<{r6 |}>),
                            forall (z4:unit),
                            (fst [int -> <{r6 |}> -> Prop,int -> <{r6 |}> ->
                             <{r6 |}> -> unit -> Prop||] (:= [int|r6|] x6) 1
                             s11)
                            /\
                            (forall (s12:<{r6 |}>),
                             forall (anon8:unit),
                             (snd [int -> <{r6 |}> -> Prop,int -> <{r6 |}> ->
                              <{r6 |}> -> unit -> Prop||] (:= [int|r6|] x6) 1
                              s11 s12 anon8)
                             ->
                             ((λ(old7:<{r6 |}>) ->
                              (λ(cur10:<{r6 |}>) ->
                              (λ(anon9:unit) ->
                              (!! [int|r6|{r6 |}] x6 cur10) = 1))) s11 s12
                              anon8))))
                          /\
                          (fst [((unit -> <{r6 |}> -> Prop) * (unit -> <{r6
                           |}> -> <{r6 |}> -> unit -> Prop)) -> <{r6 |}> ->
                           Prop,((unit -> <{r6 |}> -> Prop) * (unit -> <{r6
                           |}> -> <{r6 |}> -> unit -> Prop)) -> <{r6 |}> ->
                           <{r6 |}> -> unit -> Prop||]
                           (seq [||{r6 |}]
                            ((λ(z3:unit) -> (λ(s13:<{r6 |}>) -> True)) ,
                             (λ(z3:unit) ->
                             (λ(old6:<{r6 |}>) ->
                             (λ(cur9:<{r6 |}>) ->
                             (λ(anon7:unit) ->
                             (!! [int|r6|{r6 |}] x6 cur9) = 0))))))
                           ((λ(z4:unit) -> (λ(s14:<{r6 |}>) -> True)) ,
                            (λ(z4:unit) ->
                            (λ(old7:<{r6 |}>) ->
                            (λ(cur10:<{r6 |}>) ->
                            (λ(anon9:unit) ->
                            (!! [int|r6|{r6 |}] x6 cur10) = 1)))))
                           s8))
                         /\
                         (forall (s15:<{r6 |}>),
                          forall (anon10:unit),
                          (snd [((unit -> <{r6 |}> -> Prop) * (unit -> <{r6
                           |}> -> <{r6 |}> -> unit -> Prop)) -> <{r6 |}> ->
                           Prop,((unit -> <{r6 |}> -> Prop) * (unit -> <{r6
                           |}> -> <{r6 |}> -> unit -> Prop)) -> <{r6 |}> ->
                           <{r6 |}> -> unit -> Prop||]
                           (seq [||{r6 |}]
                            ((λ(z3:unit) -> (λ(s13:<{r6 |}>) -> True)) ,
                             (λ(z3:unit) ->
                             (λ(old6:<{r6 |}>) ->
                             (λ(cur9:<{r6 |}>) ->
                             (λ(anon7:unit) ->
                             (!! [int|r6|{r6 |}] x6 cur9) = 0))))))
                           ((λ(z4:unit) -> (λ(s14:<{r6 |}>) -> True)) ,
                            (λ(z4:unit) ->
                            (λ(old7:<{r6 |}>) ->
                            (λ(cur10:<{r6 |}>) ->
                            (λ(anon9:unit) ->
                            (!! [int|r6|{r6 |}] x6 cur10) = 1)))))
                           s8 s15 anon10)
                          ->
                          ((λ(old8:<{r6 |}>) ->
                           (λ(cur11:<{r6 |}>) ->
                           (λ(anon11:unit) ->
                           (!! [int|r6|{r6 |}] x6 cur11) = 1))) s8 s15 anon10)))
         /\
         (let
          z5 [|r6|]=
                    (λ(x6:ref(r6,int)) -> (λ(s16:<{r6 |}>) -> True)) ,
                    (λ(x6:ref(r6,int)) ->
                    (λ(old8:<{r6 |}>) ->
                    (λ(cur11:<{r6 |}>) ->
                    (λ(anon11:unit) -> (!! [int|r6|{r6 |}] x6 cur11) = 1))))
          in (λ(s17:<{|}>) -> (λ(r7:unit) -> True)) s tt))     
