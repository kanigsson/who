forall (anon:map{|}).
let /\ = logic prop -> prop -> prop in
let -> = logic prop -> prop -> prop in
let ~ = logic prop -> prop in
let = ['a||]= logic 'a -> 'a -> prop in
let <> ['a1||]= logic 'a1 -> 'a1 -> prop in
let fst ['a2 'b||]= logic ('a2 * 'b) -> 'a2 in
let snd ['a3 'b1||]= logic ('a3 * 'b1) -> 'b1 in
let , ['a4 'b2||]= logic 'a4 -> 'b2 -> 'a4 * 'b2 in
let == ['a5||]= logic 'a5 -> 'a5 -> bool in
let != ['a6||]= logic 'a6 -> 'a6 -> bool in
let !! ['a7|r|e]= logic ref(r,'a7) -> map{|e } -> 'a7 in
let
! ['a8|r1|]=
            (λ(x:ref(r1,'a8)) -> (λ(anon1:map{r1 |}) -> True)) ,
            (λ(x:ref(r1,'a8)) ->
            (λ(old:map{r1 |}) ->
            (λ(cur:map{r1 |}) ->
            (λ(r2:'a8) ->
            ((!! ['a8|r1|{r1 |}] x cur) = r2) /\
            ((!! ['a8|r1|{r1 |}] x old) = (!! ['a8|r1|{r1 |}] x cur))))))
in
let
:= ['a9|r3|]=
             (λ(x1:ref(r3,'a9)) ->
             (λ(v:'a9) -> (λ(anon2:map{r3 |}) -> True)) ,
             (λ(v:'a9) ->
             (λ(old1:map{r3 |}) ->
             (λ(cur1:map{r3 |}) ->
             (λ(anon3:unit) -> (!! ['a9|r3|{r3 |}] x1 cur1) = v)))))
in
let
ref ['a10|r4|]=
               (λ(v1:'a10) -> (λ(anon4:map{r4 |}) -> True)) ,
               (λ(v1:'a10) ->
               (λ(old2:map{r4 ||r4 }) ->
               (λ(cur2:map{r4 ||r4 }) ->
               (λ(x2:ref(r4,'a10)) ->
               (!! ['a10|r4|{r4 ||r4 }] x2 cur2) = v1))))
in
let + = logic nat -> nat -> nat in
let - = logic nat -> nat -> nat in
let * = logic nat -> nat -> nat in
let < = logic nat -> nat -> prop in
let <= = logic nat -> nat -> prop in
let > = logic nat -> nat -> prop in
let >= = logic nat -> nat -> prop in
let << = logic nat -> nat -> bool in
let <<= = logic nat -> nat -> bool in
let >> = logic nat -> nat -> bool in
let >>= = logic nat -> nat -> bool in
let max = logic nat -> nat -> nat in
let min = logic nat -> nat -> nat in
let pre ['a11 'b3||]= (λ(x3:'a11 * 'b3) -> fst ['a11,'b3||] x3) in
let post ['a12 'b4||]= (λ(x4:'a12 * 'b4) -> snd ['a12,'b4||] x4) in
let combine [||e1 e2]= logic map{|e1 } -> map{|e2 } -> map{|e1 e2 } in
let restrict [||e11 e21]= logic map{|e11 } -> map{|e21 } in
let
forto [||e1]=
             (λ(inv:nat -> map{|e1 } -> prop) ->
             (λ(start:nat) ->
             (λ(end_:nat) ->
             (λ(f:nat -> map{|e1 } -> prop * nat -> map{|e1 } -> map{|e1
             } -> unit -> prop) ->
             (λ(cur3:map{|e1 }) ->
             (inv start cur3) /\
             (forall (i:nat).
              ((start <= i) /\ (i <= end_)) ->
              (forall (m:map{|e1 }).
               (inv i m) ->
               ((pre [nat -> map{|e1 } -> prop,nat -> map{|e1 } -> map{|e1
                 } -> unit -> prop||] f i m)
                /\
                (forall (n:map{|e1 }).
                 (post [nat -> map{|e1 } -> prop,nat -> map{|e1 } -> map{|e1
                  } -> unit -> prop||] f i m n ())
                 -> (inv (i + 1) n)))))))
             ,
             (λ(f:nat -> map{|e1 } -> prop * nat -> map{|e1 } -> map{|e1
             } -> unit -> prop) ->
             (λ(old3:map{|e1 }) ->
             (λ(cur4:map{|e1 }) ->
             (λ(anon5:unit) -> inv (max start (end_ + 1)) cur4)))))))
in
let
fordownto [||e2]=
                 (λ(inv1:nat -> map{|e2 } -> prop) ->
                 (λ(start1:nat) ->
                 (λ(end_1:nat) ->
                 (λ(f1:nat -> map{|e2 } -> prop * nat -> map{|e2 } ->
                 map{|e2 } -> unit -> prop) ->
                 (λ(cur5:map{|e2 }) ->
                 (inv1 start1 cur5) /\
                 (forall (i1:nat).
                  ((start1 <= i1) /\ (i1 <= end_1)) ->
                  (forall (m1:map{|e2 }).
                   (inv1 i1 m1) ->
                   ((pre [nat -> map{|e2 } -> prop,nat -> map{|e2 } ->
                     map{|e2 } -> unit -> prop||] f1 i1 m1)
                    /\
                    (forall (n1:map{|e2 }).
                     (post [nat -> map{|e2 } -> prop,nat -> map{|e2 } ->
                      map{|e2 } -> unit -> prop||] f1 i1 m1 n1 ())
                     -> (inv1 (i1 - 1) n1)))))))
                 ,
                 (λ(f1:nat -> map{|e2 } -> prop * nat -> map{|e2 } ->
                 map{|e2 } -> unit -> prop) ->
                 (λ(old4:map{|e2 }) ->
                 (λ(cur6:map{|e2 }) ->
                 (λ(anon6:unit) -> inv1 (min start1 (end_1 - 1)) cur6)))))))
in type array['a13||] =  in
let get ['a14||]= logic nat -> (array['a14||]) -> 'a14 in
let set ['a15||]= logic nat -> 'a15 -> (array['a15||]) -> array['a15||] in
let length ['a16||]= logic (array['a16||]) -> nat in
let create ['a17||]= logic nat -> array['a17||] in
let
update_length ['a18||]=
                       axiom forall (t:array['a18||]).
                             forall (i2:nat).
                             forall (z:'a18).
                             (length ['a18||] t) =
                             (length ['a18||] (set ['a18||] i2 z t))
in
let
get_set_eq ['a19||]=
                    axiom forall (t1:array['a19||]).
                          forall (i3:nat).
                          forall (z1:'a19).
                          (i3 < (length ['a19||] t1)) ->
                          ((get ['a19||] i3 (set ['a19||] i3 z1 t1)) = z1)
in
let
get_set_neq ['a20||]=
                     axiom forall (t2:array['a20||]).
                           forall (i4:nat).
                           forall (j:nat).
                           forall (z2:'a20).
                           (i4 < (length ['a20||] t2)) ->
                           ((j < (length ['a20||] t2)) ->
                            ((i4 <> j) ->
                             ((get ['a20||] i4 (set ['a20||] j z2 t2)) =
                              (get ['a20||] i4 t2))))
in
let
length_nonnegative ['a21||]=
                            axiom forall (t3:array['a21||]).
                                  0 <= (length ['a21||] t3)
in
let
length_create ['a22||]=
                       axiom forall (l:nat).
                             (0 <= l) ->
                             ((length ['a22||]
                               (create ['a22||] l : array['a22||]))
                              = l)
in
(forall ['a23 'b5 'c||e12
e22]. forall (f2:'a23 -> map{|e12 } -> prop * 'a23 -> map{|e12 } -> map{|e12
      } -> 'b5 -> prop).
      forall (g:'b5 -> map{|e22 } -> prop * 'b5 -> map{|e22 } -> map{|e22
      } -> 'c -> prop).
      forall (anon7:map{|e12 e22 }).
      forall (x5:'a23).
      (fst ['a23 -> map{|e12 } -> prop,'a23 -> map{|e12 } -> map{|e12 } ->
       'b5 -> prop||] f2 x5 anon7)
      /\
      (forall (anon8:map{|e12 }).
       forall (anon9:'b5).
       (snd ['a23 -> map{|e12 } -> prop,'a23 -> map{|e12 } -> map{|e12 } ->
        'b5 -> prop||] f2 x5 anon7 anon8 anon9)
       ->
       ((λ(anon10:map{|e12 }) ->
        (λ(anf:'b5) ->
        (fst ['b5 -> map{|e22 } -> prop,'b5 -> map{|e22 } -> map{|e22 } ->
         'c -> prop||] g anf (combine [||{|e12 e22 },{|e12 }] anon7 anon10))
        /\
        (forall (anon11:map{|e22 }).
         forall (anon12:'c).
         (snd ['b5 -> map{|e22 } -> prop,'b5 -> map{|e22 } -> map{|e22 } ->
          'c -> prop||] g anf (combine [||{|e12 e22 },{|e12 }] anon7 anon10)
          anon11 anon12)
         ->
         ((λ(anon13:map{|e12 e22 }) -> (λ(anon14:'c) -> True)) anon11
          anon12))))
        anon8 anon9)))
/\
(let seq ['a23 'b5 'c||e12
 e22]=
      (λ(f2:'a23 -> map{|e12 } -> prop * 'a23 -> map{|e12 } -> map{|e12 } ->
      'b5 -> prop) ->
      (λ(g:'b5 -> map{|e22 } -> prop * 'b5 -> map{|e22 } -> map{|e22 } ->
      'c -> prop) ->
      (λ(x5:'a23) -> (λ(anon15:map{|e12 e22 }) -> True)) ,
      (λ(x5:'a23) ->
      (λ(anon16:map{|e12 e22 }) ->
      (λ(anon17:map{|e12 e22 }) -> (λ(anon18:'c) -> True))))))
 in
 (forall [|r1
 r2|]. forall (x6:ref(r1,nat)).
       forall (anon19:map{|}).
       forall (y:ref(r2,nat)).
       ((λ(anon20:map{|}) ->
        (λ(anon21:nat -> map{r1 r2 |} -> prop * nat -> map{r1 r2 |} ->
        map{r1 r2 |} -> nat -> prop) -> True)) anon19
        (seq [nat,nat,nat||{r1 |},{r2 |}]
         ((λ(z3:nat) -> (λ(anon22:map{r1 |}) -> True)) ,
          (λ(z3:nat) ->
          (λ(anon23:map{r1 |}) ->
          (λ(anon24:map{r1 |}) -> (λ(anon25:nat) -> True)))))
         ((λ(z4:nat) -> (λ(anon26:map{r2 |}) -> True)) ,
          (λ(z4:nat) ->
          (λ(anon27:map{r2 |}) ->
          (λ(anon28:map{r2 |}) -> (λ(anon29:nat) -> True)))))))
       /\
       ((forall (anon30:map{r1 |}).
         forall (z3:nat).
         (fst [ref(r1,nat) -> map{r1 |} -> prop,ref(r1,nat) -> map{r1 |} ->
          map{r1 |} -> nat -> prop||] ! [nat|r1|] x6 anon30)
         /\
         (forall (anon31:map{r1 |}).
          forall (anon32:nat).
          (snd [ref(r1,nat) -> map{r1 |} -> prop,ref(r1,nat) -> map{r1 |} ->
           map{r1 |} -> nat -> prop||] ! [nat|r1|] x6 anon30 anon31 anon32)
          ->
          ((λ(anon33:map{r1 |}) -> (λ(anon34:nat) -> True)) anon31 anon32)))
        /\
        (forall (anon35:map{r2 |}).
         forall (z4:nat).
         (fst [ref(r2,nat) -> map{r2 |} -> prop,ref(r2,nat) -> map{r2 |} ->
          map{r2 |} -> nat -> prop||] ! [nat|r2|] y anon35)
         /\
         (forall (anon36:map{r2 |}).
          forall (anon37:nat).
          (snd [ref(r2,nat) -> map{r2 |} -> prop,ref(r2,nat) -> map{r2 |} ->
           map{r2 |} -> nat -> prop||] ! [nat|r2|] y anon35 anon36 anon37)
          ->
          ((λ(anon38:map{r2 |}) -> (λ(anon39:nat) -> True)) anon36 anon37)))))
 /\
 (let h [|r1
  r2|]=
       (λ(x6:ref(r1,nat)) ->
       (λ(y:ref(r2,nat)) -> (λ(anon40:map{|}) -> True)) ,
       (λ(y:ref(r2,nat)) ->
       (λ(anon41:map{|}) ->
       (λ(anon42:map{|}) ->
       (λ(anon43:nat -> map{r1 r2 |} -> prop * nat -> map{r1 r2 |} -> map{r1
       r2 |} -> nat -> prop) -> True)))))
  in (λ(anon44:map{|}) -> (λ(anon45:unit) -> True)) anon ()))
