forall (s:<{|}>),
section basiclogic Coq 
 let /\ = logic Prop -> Prop -> Prop in
 let \/ = logic Prop -> Prop -> Prop in
 let -> = logic Prop -> Prop -> Prop in
 let ~ = logic Prop -> Prop in
 let = [a||]= logic a -> a -> Prop in
 let <> [a1||]= logic a1 -> a1 -> Prop in
 let fst [a2 b||]= logic (a2 * b) -> a2 in
 let snd [a3 b1||]= logic (a3 * b1) -> b1 in
 let , [a4 b2||]= logic a4 -> b2 -> a4 * b2 in end
  section arith Coq WhoArith
   let + = logic int -> int -> int in
   let - = logic int -> int -> int in
   let * = logic int -> int -> int in
   let < = logic int -> int -> Prop in
   let <= = logic int -> int -> Prop in
   let > = logic int -> int -> Prop in
   let >= = logic int -> int -> Prop in
   let << = logic int -> int -> bool in
   let <<= = logic int -> int -> bool in
   let >> = logic int -> int -> bool in
   let >>= = logic int -> int -> bool in
   let max = logic int -> int -> int in
   let min = logic int -> int -> int in
   let mod = logic int -> int -> int in end
    let == [a5||]= logic a5 -> a5 -> bool in
    let != [a6||]= logic a6 -> a6 -> bool in
    section Whoref Coq WhoMap
     let !! [a7|r|e]= logic ref(r,a7) -> <{|e }> -> a7 in
     let
     ! [a8|r1|]=
                (λ(x:ref(r1,a8)) -> (λ(s1:<{r1 |}>) -> True))
                ,[ref(r1,a8) -> <{r1 |}> -> Prop,ref(r1,a8) -> <{r1 |}> ->
                <{r1 |}> -> a8 -> Prop||]
                (λ(x:ref(r1,a8)) ->
                (λ(old:<{r1 |}>) ->
                (λ(cur:<{r1 |}>) ->
                (λ(r2:a8) ->
                ((!! [a8|r1|{r1 |}] x cur) =[a8||] r2) /\
                ((!! [a8|r1|{r1 |}] x old) =[a8||] (!! [a8|r1|{r1 |}] x cur))))))
     in
     let
     := [a9|r3|]=
                 (λ(x1:ref(r3,a9)) ->
                 (λ(v:a9) -> (λ(s2:<{r3 |}>) -> True)) ,[a9 -> <{r3 |}> ->
                 Prop,a9 -> <{r3 |}> -> <{r3 |}> -> unit -> Prop||]
                 (λ(v:a9) ->
                 (λ(old1:<{r3 |}>) ->
                 (λ(cur1:<{r3 |}>) ->
                 (λ(anon:unit) -> (!! [a9|r3|{r3 |}] x1 cur1) =[a9||] v)))))
     in
     let
     ref [a10|r4|]=
                   (λ(v1:a10) -> (λ(s3:<{r4 |}>) -> True)) ,[a10 -> <{r4
                   |}> -> Prop,a10 -> <{r4 |}> -> <{r4 |}> -> ref(r4,a10) ->
                   Prop||]
                   (λ(v1:a10) ->
                   (λ(old2:<{r4 |}>) ->
                   (λ(cur2:<{r4 |}>) ->
                   (λ(x2:ref(r4,a10)) ->
                   (!! [a10|r4|{r4 |}] x2 cur2) =[a10||] v1))))
     in
     let combine [||e1 e2]= logic <{|e1 }> -> <{|e2 }> -> <{|e1 e2 }> in
     let restrict [||e11 e21]= logic <{|e11 }> -> <{|e21 }> in
     let empty = logic <{|}> in type kmap =  in type key =  in
     let kcombine [||e12 e22]= logic (kmap) -> (kmap) -> kmap in
     let krestrict [||e13 e23]= logic (kmap) -> kmap in
     let kset [a11||]= logic (key) -> a11 -> (kmap) -> kmap in
     let kget [a12|r5|]= logic ref(r5,a12) -> (kmap) -> a12 in
     let kempty = logic kmap in
     let pre [a13 b3||]= (λ(x3:a13 * b3) -> fst [a13,b3||] x3) in
     let post [a14 b4||]= (λ(x4:a14 * b4) -> snd [a14,b4||] x4) in end
      let
      forto [||e1]=
                   (λ(inv:int -> <{|e1 }> -> Prop) ->
                   (λ(start:int) ->
                   (λ(end_:int) ->
                   (λ(f:(int -> <{|e1 }> -> Prop) * (int -> <{|e1 }> ->
                   <{|e1 }> -> unit -> Prop)) ->
                   (λ(cur3:<{|e1 }>) ->
                   (inv start cur3) /\
                   (forall (i:int),
                    ((start <= i) /\ (i <= end_)) ->
                    (forall (m:<{|e1 }>),
                     (inv i m) ->
                     ((pre [int -> <{|e1 }> -> Prop,int -> <{|e1 }> -> <{|e1
                       }> -> unit -> Prop||] f i m)
                      /\
                      (forall (n:<{|e1 }>),
                       (post [int -> <{|e1 }> -> Prop,int -> <{|e1 }> ->
                        <{|e1 }> -> unit -> Prop||] f i m n tt)
                       -> (inv (i + 1) n)))))))
                   ,[((int -> <{|e1 }> -> Prop) * (int -> <{|e1 }> -> <{|e1
                   }> -> unit -> Prop)) -> <{|e1 }> -> Prop,((int -> <{|e1
                   }> -> Prop) * (int -> <{|e1 }> -> <{|e1 }> -> unit ->
                   Prop)) -> <{|e1 }> -> <{|e1 }> -> unit -> Prop||]
                   (λ(f:(int -> <{|e1 }> -> Prop) * (int -> <{|e1 }> ->
                   <{|e1 }> -> unit -> Prop)) ->
                   (λ(old3:<{|e1 }>) ->
                   (λ(cur4:<{|e1 }>) ->
                   (λ(anon1:unit) -> inv (max start (end_ + 1)) cur4)))))))
      in
      let
      fordownto [||e2]=
                       (λ(inv1:int -> <{|e2 }> -> Prop) ->
                       (λ(start1:int) ->
                       (λ(end_1:int) ->
                       (λ(f1:(int -> <{|e2 }> -> Prop) * (int -> <{|e2 }> ->
                       <{|e2 }> -> unit -> Prop)) ->
                       (λ(cur5:<{|e2 }>) ->
                       (inv1 start1 cur5) /\
                       (forall (i1:int),
                        ((end_1 <= i1) /\ (i1 <= start1)) ->
                        (forall (m1:<{|e2 }>),
                         (inv1 i1 m1) ->
                         ((pre [int -> <{|e2 }> -> Prop,int -> <{|e2 }> ->
                           <{|e2 }> -> unit -> Prop||] f1 i1 m1)
                          /\
                          (forall (n1:<{|e2 }>),
                           (post [int -> <{|e2 }> -> Prop,int -> <{|e2 }> ->
                            <{|e2 }> -> unit -> Prop||] f1 i1 m1 n1 tt)
                           -> (inv1 (i1 - 1) n1)))))))
                       ,[((int -> <{|e2 }> -> Prop) * (int -> <{|e2 }> ->
                       <{|e2 }> -> unit -> Prop)) -> <{|e2 }> ->
                       Prop,((int -> <{|e2 }> -> Prop) * (int -> <{|e2 }> ->
                       <{|e2 }> -> unit -> Prop)) -> <{|e2 }> -> <{|e2 }> ->
                       unit -> Prop||]
                       (λ(f1:(int -> <{|e2 }> -> Prop) * (int -> <{|e2 }> ->
                       <{|e2 }> -> unit -> Prop)) ->
                       (λ(old4:<{|e2 }>) ->
                       (λ(cur6:<{|e2 }>) ->
                       (λ(anon2:unit) -> inv1 (min start1 (end_1 - 1)) cur6)))))))
      in
      section Array Coq WhoArray type array[a15||] =  in
      let get [a16||]= logic int -> (array[a16||]) -> a16 in
      let set [a17||]= logic int -> a17 -> (array[a17||]) -> array[a17||] in
      let len [a18||]= logic (array[a18||]) -> int in
      let create [a19||]= logic int -> a19 -> array[a19||] in
      let
      update_length [a20||]=
                            axiom forall (t:array[a20||]),
                                  forall (i2:int),
                                  forall (z:a20),
                                  (len [a20||] t) =[int||]
                                  (len [a20||] (set [a20||] i2 z t))
      in
      let
      get_set_eq [a21||]=
                         axiom forall (t1:array[a21||]),
                               forall (i3:int),
                               forall (z1:a21),
                               (i3 < (len [a21||] t1)) ->
                               ((get [a21||] i3 (set [a21||] i3 z1 t1))
                                =[a21||] z1)
      in
      let
      get_set_neq [a22||]=
                          axiom forall (t2:array[a22||]),
                                forall (i4:int),
                                forall (j:int),
                                forall (z2:a22),
                                (i4 < (len [a22||] t2)) ->
                                ((j < (len [a22||] t2)) ->
                                 ((i4 <>[int||] j) ->
                                  ((get [a22||] i4 (set [a22||] j z2 t2))
                                   =[a22||] (get [a22||] i4 t2))))
      in
      let
      length_nonnegative [a23||]=
                                 axiom forall (t3:array[a23||]),
                                       0 <= (len [a23||] t3)
      in
      let
      length_create [a24||]=
                            axiom forall (l:int),
                                  forall (v2:a24),
                                  (0 <= l) ->
                                  ((len [a24||] (create [a24||] l v2))
                                   =[int||] l)
      in
      let
      length_access [a25||]=
                            axiom forall (i5:int),
                                  forall (l1:int),
                                  forall (v3:a25),
                                  (0 <= i5) ->
                                  ((i5 <= l1) ->
                                   ((get [a25||] i5 (create [a25||] l1 v3))
                                    =[a25||] v3))
      in end
       section List Coq WhoList type list[a26||] =  in
       let nil [a27||]= logic list[a27||] in
       let cons [a28||]= logic a28 -> (list[a28||]) -> list[a28||] in
       let is_nil [a29||]= logic (list[a29||]) -> bool in
       let l_in [a30||]= logic a30 -> (list[a30||]) -> Prop in end
        (forall [a31 b5 c||e14
        e24], forall (f2:(a31 -> <{|e14 }> -> Prop) * (a31 -> <{|e14 }> ->
              <{|e14 }> -> b5 -> Prop)),
              forall (g:(b5 -> <{|e24 }> -> Prop) * (b5 -> <{|e24 }> ->
              <{|e24 }> -> c -> Prop)),
              forall (s4:<{|e14 e24 }>),
              forall (x5:a31),
              (fst [a31 -> <{|e14 }> -> Prop,a31 -> <{|e14 }> -> <{|e14 }> ->
               b5 -> Prop||] f2 x5 (restrict [||{|e14 e24 },{|e14 }] s4))
              /\
              (forall (s5:<{|e14 }>),
               forall (anon3:b5),
               (snd [a31 -> <{|e14 }> -> Prop,a31 -> <{|e14 }> -> <{|e14
                }> -> b5 -> Prop||] f2 x5
                (restrict [||{|e14 e24 },{|e14 }] s4) s5 anon3)
               ->
               ((λ(s6:<{|e14 }>) ->
                (λ(s7:<{|e14 e24 }>) ->
                (λ(anf:b5) ->
                (fst [b5 -> <{|e24 }> -> Prop,b5 -> <{|e24 }> -> <{|e24 }> ->
                 c -> Prop||] g anf (restrict [||{|e14 e24 },{|e24 }] s7))
                /\
                (forall (s8:<{|e24 }>),
                 forall (anon4:c),
                 (snd [b5 -> <{|e24 }> -> Prop,b5 -> <{|e24 }> -> <{|e24
                  }> -> c -> Prop||] g anf
                  (restrict [||{|e14 e24 },{|e24 }] s7) s8 anon4)
                 ->
                 ((λ(s9:<{|e24 }>) ->
                  (λ(s10:<{|e14 e24 }>) -> (λ(r6:c) -> True))
                  (combine [||{|e14 e24 },{|e24 }] s7 s9)) s8 anon4))))
                (combine [||{|e14 e24 },{|e14 }] s4 s6)) s5 anon3)))
        /\
        (let seq [a31 b5 c||e14
         e24]=
              (λ(f2:(a31 -> <{|e14 }> -> Prop) * (a31 -> <{|e14 }> -> <{|e14
              }> -> b5 -> Prop)) ->
              (λ(g:(b5 -> <{|e24 }> -> Prop) * (b5 -> <{|e24 }> -> <{|e24
              }> -> c -> Prop)) ->
              (λ(x5:a31) -> (λ(s11:<{|e14 e24 }>) -> True)) ,[a31 -> <{|e14
              e24 }> -> Prop,a31 -> <{|e14 e24 }> -> <{|e14 e24 }> -> c ->
              Prop||]
              (λ(x5:a31) ->
              (λ(s12:<{|e14 e24 }>) ->
              (λ(s13:<{|e14 e24 }>) -> (λ(r7:c) -> True))))))
         in
         (forall [|r1
         r2|], forall (x6:ref(r1,int)),
               forall (s14:<{|}>),
               forall (y:ref(r2,int)),
               ((λ(s15:<{|}>) ->
                (λ(r8:(int -> <{r1 r2 |}> -> Prop) * (int -> <{r1 r2 |}> ->
                <{r1 r2 |}> -> int -> Prop)) -> True)) s14
                (seq [int,int,int||{r1 |},{r2 |}]
                 ((λ(z3:int) -> (λ(s16:<{r1 |}>) -> True)) ,[int -> <{r1
                  |}> -> Prop,int -> <{r1 |}> -> <{r1 |}> -> int -> Prop||]
                  (λ(z3:int) ->
                  (λ(s17:<{r1 |}>) ->
                  (λ(s18:<{r1 |}>) -> (λ(r9:int) -> True)))))
                 ((λ(z4:int) -> (λ(s19:<{r2 |}>) -> True)) ,[int -> <{r2
                  |}> -> Prop,int -> <{r2 |}> -> <{r2 |}> -> int -> Prop||]
                  (λ(z4:int) ->
                  (λ(s20:<{r2 |}>) ->
                  (λ(s21:<{r2 |}>) -> (λ(r10:int) -> True)))))))
               /\
               ((forall (s22:<{r1 |}>),
                 forall (z3:int),
                 (fst [ref(r1,int) -> <{r1 |}> -> Prop,ref(r1,int) -> <{r1
                  |}> -> <{r1 |}> -> int -> Prop||] ! [int|r1|] x6 s22)
                 /\
                 (forall (s23:<{r1 |}>),
                  forall (anon5:int),
                  (snd [ref(r1,int) -> <{r1 |}> -> Prop,ref(r1,int) -> <{r1
                   |}> -> <{r1 |}> -> int -> Prop||] ! [int|r1|] x6 s22 s23
                   anon5)
                  -> ((λ(s24:<{r1 |}>) -> (λ(r11:int) -> True)) s23 anon5)))
                /\
                (forall (s25:<{r2 |}>),
                 forall (z4:int),
                 (fst [ref(r2,int) -> <{r2 |}> -> Prop,ref(r2,int) -> <{r2
                  |}> -> <{r2 |}> -> int -> Prop||] ! [int|r2|] y s25)
                 /\
                 (forall (s26:<{r2 |}>),
                  forall (anon6:int),
                  (snd [ref(r2,int) -> <{r2 |}> -> Prop,ref(r2,int) -> <{r2
                   |}> -> <{r2 |}> -> int -> Prop||] ! [int|r2|] y s25 s26
                   anon6)
                  -> ((λ(s27:<{r2 |}>) -> (λ(r12:int) -> True)) s26 anon6)))))
         /\
         (let h [|r1
          r2|]=
               (λ(x6:ref(r1,int)) ->
               (λ(y:ref(r2,int)) -> (λ(s28:<{|}>) -> True))
               ,[ref(r2,int) -> <{|}> -> Prop,ref(r2,int) -> <{|}> ->
               <{|}> -> ((int -> <{r1 r2 |}> -> Prop) * (int -> <{r1 r2
               |}> -> <{r1 r2 |}> -> int -> Prop)) -> Prop||]
               (λ(y:ref(r2,int)) ->
               (λ(s29:<{|}>) ->
               (λ(s30:<{|}>) ->
               (λ(r13:(int -> <{r1 r2 |}> -> Prop) * (int -> <{r1 r2 |}> ->
               <{r1 r2 |}> -> int -> Prop)) -> True)))))
          in (λ(s31:<{|}>) -> (λ(r14:unit) -> True)) s tt))     
