type bool
logic true : bool
logic false : bool
type unit
logic mk_2tuple ['a 'b||] : 'a -> 'b -> 'a * 'b
logic tt : unit
section basiclogic coq predefined
  pangoline predefined
   logic /\  : prop -> prop -> prop
  logic \/  : prop -> prop -> prop
  logic ->  : prop -> prop -> prop
  logic ~  : prop -> prop
  logic = ['a||] : 'a -> 'a -> prop
  logic <> ['a1||] : 'a1 -> 'a1 -> prop
  logic fst ['a2 'b||] : ('a2 * 'b) -> 'a2
  logic snd ['a3 'b1||] : ('a3 * 'b1) -> 'b1
section arith coq "WhoArith"
  pangoline predefined
   logic +  : int -> int -> int
  logic -  : int -> int -> int
  logic *  : int -> int -> int
  logic <  : int -> int -> prop
  logic <=  : int -> int -> prop
  logic >  : int -> int -> prop
  logic >=  : int -> int -> prop
  logic <<  : int -> int -> bool
  logic <<=  : int -> int -> bool
  logic >>  : int -> int -> bool
  logic >>=  : int -> int -> bool
  logic max  : int -> int -> int
  logic min  : int -> int -> int
  logic mod  : int -> int -> int
  logic band  : bool -> bool -> bool
  logic bor  : bool -> bool -> bool end
logic == ['a5||] : 'a5 -> 'a5 -> bool
logic != ['a6||] : 'a6 -> 'a6 -> bool
section Whoref coq "WhoMap"
  pangoline predefined
   logic !! ['a7|r|'e] : ref(r,'a7) -> < 'e > -> 'a7
  let
    ! ['a8|r1|] = (fun (x:ref(r1,'a8)) -> {(fun (cur:<r1  >) -> True)}
                  parameter('a8,{r1  })
                  {(fun (old:<r1  >) ->
                   (fun (cur1:<r1  >) ->
                   (fun (r2:'a8) ->
                   ((!! ['a8| r1| {r1  }] x cur1) =['a8||] r2) /\
                   ((!! ['a8| r1| {r1  }] x old) =['a8||]
                    (!! ['a8| r1| {r1  }] x cur1)))))}) 
  let
    := ['a9|r3|] = (fun (x1:ref(r3,'a9)) ->
                   (fun (v:'a9) -> {(fun (cur2:<r3  >) -> True)}
                   parameter(unit,{r3  })
                   {(fun (old1:<r3  >) ->
                    (fun (cur3:<r3  >) ->
                    (fun (anon:unit) ->
                    (!! ['a9| r3| {r3  }] x1 cur3) =['a9||] v)))})) 
  let
    ref ['a10|r4|] = (fun (v1:'a10) ->allocates r4 {(fun (cur4:<r4  >) -> True)}
                     parameter(ref(r4,'a10),{r4  })
                     {(fun (old2:<r4  >) ->
                      (fun (cur5:<r4  >) ->
                      (fun (x2:ref(r4,'a10)) ->
                      (!! ['a10| r4| {r4  }] x2 cur5) =['a10||] v1)))}) 
  logic combine [||'e1 'e2 'e3] : < 'e1 'e2 > -> < 'e2 'e3 > -> < 'e1 'e2 'e3
    >
  logic restrict [||'e11 'e21] : < 'e11 'e21 > -> < 'e21 >
  logic empty  : < >
  let pre ['a11 'b3||] = (fun (x3:'a11 * 'b3) -> fst ['a11,'b3||] x3) 
  let post ['a12 'b4||] = (fun (x4:'a12 * 'b4) -> snd ['a12,'b4||] x4)  end
let
  forto [||'e1] = (fun (inv:int -> < 'e1 > -> prop) ->
                  (fun (start:int) ->
                  (fun (end_:int) ->
                  (fun (f:int ->{ 'e1 } unit) ->
                  {(fun (cur6:< 'e1 >) ->
                   (inv start cur6) /\
                   (forall (i:int).
                    ((start <= i) /\ (i <= end_)) ->
                    (forall (m:< 'e1 >).
                     (inv i m) ->
                     ((pre [int -> < 'e1 > -> prop,int -> < 'e1 > -> < 'e1
                       > -> unit -> prop||] f i m)
                      /\
                      (forall (n:< 'e1 >).
                       (post [int -> < 'e1 > -> prop,int -> < 'e1 > -> < 'e1
                        > -> unit -> prop||] f i m n tt)
                       -> (inv (i + 1) n))))))}
                  parameter(unit,{ 'e1 })
                  {(fun (old3:< 'e1 >) ->
                   (fun (cur7:< 'e1 >) ->
                   (fun (anon1:unit) -> inv (max start (end_ + 1)) cur7)))})))) 
let
  fordownto [||'e2] = (fun (inv1:int -> < 'e2 > -> prop) ->
                      (fun (start1:int) ->
                      (fun (end_1:int) ->
                      (fun (f1:int ->{ 'e2 } unit) ->
                      {(fun (cur8:< 'e2 >) ->
                       (inv1 start1 cur8) /\
                       (forall (i1:int).
                        ((end_1 <= i1) /\ (i1 <= start1)) ->
                        (forall (m1:< 'e2 >).
                         (inv1 i1 m1) ->
                         ((pre [int -> < 'e2 > -> prop,int -> < 'e2 > ->
                           < 'e2 > -> unit -> prop||] f1 i1 m1)
                          /\
                          (forall (n1:< 'e2 >).
                           (post [int -> < 'e2 > -> prop,int -> < 'e2 > ->
                            < 'e2 > -> unit -> prop||] f1 i1 m1 n1 tt)
                           -> (inv1 (i1 - 1) n1))))))}
                      parameter(unit,{ 'e2 })
                      {(fun (old4:< 'e2 >) ->
                       (fun (cur9:< 'e2 >) ->
                       (fun (anon2:unit) ->
                       inv1 (min start1 (end_1 - 1)) cur9)))})))) 
section Array coq "WhoArray"
  pangoline takeover
   type array['a13||]
  logic ar_empty ['a14||] : array['a14||]
  logic get ['a15||] : int -> (array['a15||]) -> 'a15
  logic set ['a16||] : int -> 'a16 -> (array['a16||]) -> array['a16||]
  logic len ['a17||] : (array['a17||]) -> int
  logic create ['a18||] : int -> 'a18 -> array['a18||]
  axiom update_length : forall ['a19||]. forall (t:array['a19||]).
                                         forall (i2:int).
                                         forall (z:'a19).
                                         (len ['a19||] t) =[int||]
                                         (len ['a19||] (set ['a19||] i2 z t))
  axiom get_set_eq : forall ['a20||]. forall (t1:array['a20||]).
                                      forall (i3:int).
                                      forall (z1:'a20).
                                      (i3 < (len ['a20||] t1)) ->
                                      ((get ['a20||] i3
                                        (set ['a20||] i3 z1 t1))
                                       =['a20||] z1)
  axiom length_empty : forall ['a21||]. (len ['a21||] ar_empty ['a21||])
                                        =[int||] 0
  axiom get_set_neq : forall ['a22||]. forall (t2:array['a22||]).
                                       forall (i4:int).
                                       forall (j:int).
                                       forall (z2:'a22).
                                       (i4 < (len ['a22||] t2)) ->
                                       ((j < (len ['a22||] t2)) ->
                                        ((i4 <>[int||] j) ->
                                         ((get ['a22||] i4
                                           (set ['a22||] j z2 t2))
                                          =['a22||] (get ['a22||] i4 t2))))
  axiom length_nonnegative : forall ['a23||]. forall (t3:array['a23||]).
                                              0 <= (len ['a23||] t3)
  axiom length_create : forall ['a24||]. forall (l:int).
                                         forall (v2:'a24).
                                         (0 <= l) ->
                                         ((len ['a24||]
                                           (create ['a24||] l v2))
                                          =[int||] l)
  axiom length_access : forall ['a25||]. forall (i5:int).
                                         forall (l1:int).
                                         forall (v3:'a25).
                                         (0 <= i5) ->
                                         ((i5 <= l1) ->
                                          ((get ['a25||] i5
                                            (create ['a25||] l1 v3))
                                           =['a25||] v3)) end
section List coq "WhoList"
  pangoline takeover
   type list['a26||]
  logic nil ['a27||] : list['a27||]
  logic cons ['a28||] : 'a28 -> (list['a28||]) -> list['a28||]
  logic is_nil ['a29||] : (list['a29||]) -> bool
  logic l_in ['a30||] : 'a30 -> (list['a30||]) -> prop end
let blit ['a31|r1 r2|] = 
  (fun (ar1:ref(r1,array['a31||])) ->
   (fun (ar2:ref(r2,array['a31||])) ->
   (fun (ofs1:int) ->
   (fun (ofs2:int) ->
   (fun (l2:int) ->
         {(fun (cur10:<r1 r2  >) ->
          ((((0 <= l2) /\ (0 <= ofs1)) /\ (0 <= ofs2)) /\
           (ofs1 <=
            ((len ['a31||] (!! [array['a31||]| r1| {r1 r2  }] ar1 cur10)) -
             l2)))
          /\
          (ofs2 <=
           ((len ['a31||] (!! [array['a31||]| r2| {r1 r2  }] ar2 cur10)) - l2)))}
         let a32 = ! [array['a31||]| r1|] ar1 in
         let anf = ! [array['a31||]| r2|] ar2 in
         let l2 = len ['a31||] anf in
         if ofs1 << ofs2 then
         let __start = l2 - 1 in
         let __end = 0 in
         fordownto [|| {r1 r2  }]
         (fun (i6:int) ->
         (fun (cur11:<r1 r2  >) ->
         (((!! [array['a31||]| r1| {r1 r2  }] ar1 cur11) =[array['a31||]||]
           a32)
          /\
          ((len ['a31||] (!! [array['a31||]| r2| {r1 r2  }] ar2 cur11))
           =[int||] l2))
         /\
         (forall (k:int).
          ((i6 < k) /\ (k <= (l2 - 1))) ->
          ((get ['a31||] (ofs2 + k)
            (!! [array['a31||]| r2| {r1 r2  }] ar2 cur11))
           =['a31||]
           (get ['a31||] (ofs1 + k)
            (!! [array['a31||]| r1| {r1 r2  }] ar1 cur11))))))
         __start __end
         (fun (i6:int) ->
         {(fun (cur11:<r1 r2  >) ->
          ((__end <= i6) /\ (i6 <= __start)) /\
          ((((!! [array['a31||]| r1| {r1 r2  }] ar1 cur11) =[array['a31||]||]
             a32)
            /\
            ((len ['a31||] (!! [array['a31||]| r2| {r1 r2  }] ar2 cur11))
             =[int||] l2))
           /\
           (forall (k1:int).
            (i6 < k1) ->
            ((k1 <= (l2 - 1)) ->
             ((get ['a31||] (ofs2 + k1)
               (!! [array['a31||]| r2| {r1 r2  }] ar2 cur11))
              =['a31||]
              (get ['a31||] (ofs1 + k1)
               (!! [array['a31||]| r1| {r1 r2  }] ar1 cur11)))))))}
         let anf1 = ! [array['a31||]| r1|] ar1 in
         let anf2 = ! [array['a31||]| r2|] ar2 in
         ar2 :=[array['a31||]| r2|]
         (set ['a31||] (ofs2 + i6) (get ['a31||] (ofs1 + i6) anf1) anf2)
         {(fun (anon3:<r1 r2  >) ->
          (fun (cur11:<r1 r2  >) ->
          (fun (anon4:unit) ->
          (((!! [array['a31||]| r1| {r1 r2  }] ar1 cur11) =[array['a31||]||]
            a32)
           /\
           ((len ['a31||] (!! [array['a31||]| r2| {r1 r2  }] ar2 cur11))
            =[int||] l2))
          /\
          (forall (k2:int).
           ((i6 - 1) < k2) ->
           ((k2 <= (l2 - 1)) ->
            ((get ['a31||] (ofs2 + k2)
              (!! [array['a31||]| r2| {r1 r2  }] ar2 cur11))
             =['a31||]
             (get ['a31||] (ofs1 + k2)
              (!! [array['a31||]| r1| {r1 r2  }] ar1 cur11))))))))}) else
         let __start1 = 0 in
         let __end1 = l2 - 1 in
         forto [|| {r1 r2  }]
         (fun (i7:int) ->
         (fun (cur12:<r1 r2  >) ->
         (((!! [array['a31||]| r1| {r1 r2  }] ar1 cur12) =[array['a31||]||]
           a32)
          /\
          ((len ['a31||] (!! [array['a31||]| r2| {r1 r2  }] ar2 cur12))
           =[int||] l2))
         /\
         (forall (k3:int).
          ((0 <= k3) /\ (k3 < i7)) ->
          ((get ['a31||] (ofs2 + k3)
            (!! [array['a31||]| r2| {r1 r2  }] ar2 cur12))
           =['a31||]
           (get ['a31||] (ofs1 + k3)
            (!! [array['a31||]| r1| {r1 r2  }] ar1 cur12))))))
         __start1 __end1
         (fun (i7:int) ->
         {(fun (cur12:<r1 r2  >) ->
          ((__start1 <= i7) /\ (i7 <= __end1)) /\
          ((((!! [array['a31||]| r1| {r1 r2  }] ar1 cur12) =[array['a31||]||]
             a32)
            /\
            ((len ['a31||] (!! [array['a31||]| r2| {r1 r2  }] ar2 cur12))
             =[int||] l2))
           /\
           (forall (k4:int).
            (0 <= k4) ->
            ((k4 < i7) ->
             ((get ['a31||] (ofs2 + k4)
               (!! [array['a31||]| r2| {r1 r2  }] ar2 cur12))
              =['a31||]
              (get ['a31||] (ofs1 + k4)
               (!! [array['a31||]| r1| {r1 r2  }] ar1 cur12)))))))}
         let anf3 = ! [array['a31||]| r1|] ar1 in
         let anf4 = ! [array['a31||]| r2|] ar2 in
         ar2 :=[array['a31||]| r2|]
         (set ['a31||] (ofs2 + i7) (get ['a31||] (ofs1 + i7) anf3) anf4)
         {(fun (anon5:<r1 r2  >) ->
          (fun (cur12:<r1 r2  >) ->
          (fun (anon6:unit) ->
          (((!! [array['a31||]| r1| {r1 r2  }] ar1 cur12) =[array['a31||]||]
            a32)
           /\
           ((len ['a31||] (!! [array['a31||]| r2| {r1 r2  }] ar2 cur12))
            =[int||] l2))
          /\
          (forall (k5:int).
           (0 <= k5) ->
           ((k5 < (i7 + 1)) ->
            ((get ['a31||] (ofs2 + k5)
              (!! [array['a31||]| r2| {r1 r2  }] ar2 cur12))
             =['a31||]
             (get ['a31||] (ofs1 + k5)
              (!! [array['a31||]| r1| {r1 r2  }] ar1 cur12))))))))})
         {(fun (old5:<r1 r2  >) ->
          (fun (cur13:<r1 r2  >) ->
          (fun (anon7:unit) ->
          (((!! [array['a31||]| r1| {r1 r2  }] ar1 old5) =[array['a31||]||]
            (!! [array['a31||]| r1| {r1 r2  }] ar1 cur13))
           /\
           ((len ['a31||] (!! [array['a31||]| r2| {r1 r2  }] ar2 cur13))
            =[int||]
            (len ['a31||] (!! [array['a31||]| r2| {r1 r2  }] ar2 old5))))
          /\
          (forall (k6:int).
           ((0 <= k6) /\ (k6 < l2)) ->
           ((get ['a31||] (ofs2 + k6)
             (!! [array['a31||]| r2| {r1 r2  }] ar2 cur13))
            =['a31||]
            (get ['a31||] (ofs1 + k6)
             (!! [array['a31||]| r1| {r1 r2  }] ar1 cur13)))))))}))))) 
             
             end
