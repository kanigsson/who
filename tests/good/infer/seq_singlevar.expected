section basiclogic Coq 
 let /\ = logic Prop -> Prop -> Prop in
 let \/ = logic Prop -> Prop -> Prop in
 let -> = logic Prop -> Prop -> Prop in
 let ~ = logic Prop -> Prop in
 let = [a||]= logic a -> a -> Prop in
 let <> [a1||]= logic a1 -> a1 -> Prop in
 let fst [a2 b||]= logic (a2 * b) -> a2 in
 let snd [a3 b1||]= logic (a3 * b1) -> b1 in
 let , [a4 b2||]= logic a4 -> b2 -> a4 * b2 in end
  section arith Coq WhoArith
   let + = logic int -> int -> int in
   let - = logic int -> int -> int in
   let * = logic int -> int -> int in
   let < = logic int -> int -> Prop in
   let <= = logic int -> int -> Prop in
   let > = logic int -> int -> Prop in
   let >= = logic int -> int -> Prop in
   let << = logic int -> int -> bool in
   let <<= = logic int -> int -> bool in
   let >> = logic int -> int -> bool in
   let >>= = logic int -> int -> bool in
   let max = logic int -> int -> int in
   let min = logic int -> int -> int in
   let mod = logic int -> int -> int in end
    let == [a5||]= logic a5 -> a5 -> bool in
    let != [a6||]= logic a6 -> a6 -> bool in
    section Whoref Coq WhoMap
     let !! [a7|r|e]= logic ref(r,a7) -> <{|e }> -> a7 in
     let
     ! [a8|r1|]=
                (λ(x:ref(r1,a8)) ->{}  param(a8,{r1 |})
                {(fun (old:<{r1 |}>) ->
                 (fun (cur:<{r1 |}>) ->
                 (fun (r2:a8) ->
                 ((!! [a8|r1|{r1|}] x cur) =[a8||] r2) /\
                 ((!! [a8|r1|{r1|}] x old) =[a8||] (!! [a8|r1|{r1|}] x cur)))))})
     in
     let
     := [a9|r3|]=
                 (fun (x1:ref(r3,a9)) ->
                 (λ(v:a9) ->{}  param(unit,{r3 |})
                 {(fun (old1:<{r3 |}>) ->
                  (fun (cur1:<{r3 |}>) ->
                  (fun (anon:unit) -> (!! [a9|r3|{r3|}] x1 cur1) =[a9||] v)))}))
     in
     let
     ref [a10|r4|]=
                   (λ(v1:a10) ->{r4}  param(ref(r4,a10),{r4 |})
                   {(fun (old2:<{r4 |}>) ->
                    (fun (cur2:<{r4 |}>) ->
                    (fun (x2:ref(r4,a10)) ->
                    (!! [a10|r4|{r4|}] x2 cur2) =[a10||] v1)))})
     in
     let combine [||e1 e2]= logic <{|e1 }> -> <{|e2 }> -> <{|e1 e2 }> in
     let restrict [||e11 e21]= logic <{|e11 }> -> <{|e21 }> in
     let empty = logic <{|}> in type kmap =  in type key =  in
     let kcombine [||e12 e22]= logic (kmap) -> (kmap) -> kmap in
     let krestrict [||e13 e23]= logic (kmap) -> kmap in
     let kset [a11||]= logic (key) -> a11 -> (kmap) -> kmap in
     let kget [a12|r5|]= logic ref(r5,a12) -> (kmap) -> a12 in
     let kempty = logic kmap in
     let pre [a13 b3||]= (fun (x3:a13 * b3) -> fst [a13,b3||] x3) in
     let post [a14 b4||]= (fun (x4:a14 * b4) -> snd [a14,b4||] x4) in end
      let
      forto [||e1]=
                   (fun (inv:int -> <{|e1 }> -> Prop) ->
                   (fun (start:int) ->
                   (fun (end_:int) ->
                   (λ(f:int ->{|e1 }{{}} unit) ->{}
                   {(fun (cur3:<{|e1 }>) ->
                    (inv start cur3) /\
                    (forall (i:int).
                     ((start <= i) /\ (i <= end_)) ->
                     (forall (m:<{|e1 }>).
                      (inv i m) ->
                      ((pre [int -> <e1> -> Prop,int -> <e1> -> <e1> ->
                        unit -> Prop||] f i m)
                       /\
                       (forall (n:<{|e1 }>).
                        (post [int -> <e1> -> Prop,int -> <e1> -> <e1> ->
                         unit -> Prop||] f i m n tt)
                        -> (inv (i + 1) n))))))}
                   param(unit,{|e1 })
                   {(fun (old3:<{|e1 }>) ->
                    (fun (cur4:<{|e1 }>) ->
                    (fun (anon1:unit) -> inv (max start (end_ + 1)) cur4)))}))))
      in
      let
      fordownto [||e2]=
                       (fun (inv1:int -> <{|e2 }> -> Prop) ->
                       (fun (start1:int) ->
                       (fun (end_1:int) ->
                       (λ(f1:int ->{|e2 }{{}} unit) ->{}
                       {(fun (cur5:<{|e2 }>) ->
                        (inv1 start1 cur5) /\
                        (forall (i1:int).
                         ((end_1 <= i1) /\ (i1 <= start1)) ->
                         (forall (m1:<{|e2 }>).
                          (inv1 i1 m1) ->
                          ((pre [int -> <e2> -> Prop,int -> <e2> -> <e2> ->
                            unit -> Prop||] f1 i1 m1)
                           /\
                           (forall (n1:<{|e2 }>).
                            (post [int -> <e2> -> Prop,int -> <e2> -> <e2> ->
                             unit -> Prop||] f1 i1 m1 n1 tt)
                            -> (inv1 (i1 - 1) n1))))))}
                       param(unit,{|e2 })
                       {(fun (old4:<{|e2 }>) ->
                        (fun (cur6:<{|e2 }>) ->
                        (fun (anon2:unit) ->
                        inv1 (min start1 (end_1 - 1)) cur6)))}))))
      in
      section Array Coq WhoArray type array[a15||] =  in
      let get [a16||]= logic int -> (array[a16||]) -> a16 in
      let set [a17||]= logic int -> a17 -> (array[a17||]) -> array[a17||] in
      let len [a18||]= logic (array[a18||]) -> int in
      let create [a19||]= logic int -> a19 -> array[a19||] in
      let
      update_length [a20||]=
                            axiom forall (t:array[a20||]).
                                  forall (i2:int).
                                  forall (z:a20).
                                  (len [a20||] t) =[int||]
                                  (len [a20||] (set [a20||] i2 z t))
      in
      let
      get_set_eq [a21||]=
                         axiom forall (t1:array[a21||]).
                               forall (i3:int).
                               forall (z1:a21).
                               (i3 < (len [a21||] t1)) ->
                               ((get [a21||] i3 (set [a21||] i3 z1 t1))
                                =[a21||] z1)
      in
      let
      get_set_neq [a22||]=
                          axiom forall (t2:array[a22||]).
                                forall (i4:int).
                                forall (j:int).
                                forall (z2:a22).
                                (i4 < (len [a22||] t2)) ->
                                ((j < (len [a22||] t2)) ->
                                 ((i4 <>[int||] j) ->
                                  ((get [a22||] i4 (set [a22||] j z2 t2))
                                   =[a22||] (get [a22||] i4 t2))))
      in
      let
      length_nonnegative [a23||]=
                                 axiom forall (t3:array[a23||]).
                                       0 <= (len [a23||] t3)
      in
      let
      length_create [a24||]=
                            axiom forall (l:int).
                                  forall (v2:a24).
                                  (0 <= l) ->
                                  ((len [a24||] (create [a24||] l v2))
                                   =[int||] l)
      in
      let
      length_access [a25||]=
                            axiom forall (i5:int).
                                  forall (l1:int).
                                  forall (v3:a25).
                                  (0 <= i5) ->
                                  ((i5 <= l1) ->
                                   ((get [a25||] i5 (create [a25||] l1 v3))
                                    =[a25||] v3))
      in end
       section List Coq WhoList type list[a26||] =  in
       let nil [a27||]= logic list[a27||] in
       let cons [a28||]= logic a28 -> (list[a28||]) -> list[a28||] in
       let is_nil [a29||]= logic (list[a29||]) -> bool in
       let l_in [a30||]= logic a30 -> (list[a30||]) -> Prop in end
        let
        seq [||e3]=
                   (fun (f2:unit ->{|e3 }{{}} unit) ->
                   (λ(g:unit ->{|e3 }{{}} unit) ->{}
                   {(fun (cur7:<{|e3 }>) ->
                    (fst [unit -> <e3> -> Prop,unit -> <e3> -> <e3> ->
                     unit -> Prop||] f2 tt cur7)
                    /\
                    (forall (i6:<{|e3 }>).
                     (True /\
                      (snd [unit -> <e3> -> Prop,unit -> <e3> -> <e3> ->
                       unit -> Prop||] f2 tt cur7 i6 tt))
                     ->
                     (fst [unit -> <e3> -> Prop,unit -> <e3> -> <e3> ->
                      unit -> Prop||] g tt i6)))}
                   let x5 = f2 tt in g tt
                   {(fun (old5:<{|e3 }>) ->
                    (fun (cur8:<{|e3 }>) ->
                    (fun (anon3:unit) ->
                    exists i7:<{|e3 }>.
                    (snd [unit -> <e3> -> Prop,unit -> <e3> -> <e3> ->
                     unit -> Prop||] f2 tt old5 i7 tt)
                    /\
                    (snd [unit -> <e3> -> Prop,unit -> <e3> -> <e3> ->
                     unit -> Prop||] g tt i7 cur8 tt))))}))
        in
        let
        z3 [|r6|]=
                  (λ(x6:ref(r6,int)) ->{} 
                  seq [||{r6 r6 r6 r6|{r6|} {|2079 2087 2090} 2092 {r6|}
                  {|2000 2008 2011} 2013}]
                  (λ(z4:unit) ->{}  x6 :=[int|r6|] 0
                  {(fun (old6:<{r6 |}>) ->
                   (fun (cur9:<{r6 |}>) ->
                   (fun (anon4:unit) ->
                   (!! [int|r6|{r6|}] x6 cur9) =[int||] 0)))})
                  (λ(z5:unit) ->{}  x6 :=[int|r6|] 1
                  {(fun (old7:<{r6 |}>) ->
                   (fun (cur10:<{r6 |}>) ->
                   (fun (anon5:unit) ->
                   (!! [int|r6|{r6|}] x6 cur10) =[int||] 1)))})
                  {(fun (old8:<{r6 |}>) ->
                   (fun (cur11:<{r6 |}>) ->
                   (fun (anon6:unit) ->
                   (!! [int|r6|{r6|}] x6 cur11) =[int||] 1)))})
        in tt     
