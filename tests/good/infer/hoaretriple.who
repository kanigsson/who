type unit
logic tt : unit
logic = ['a||] : 'a -> 'a -> prop
logic /\ : prop -> prop -> prop
logic ~ : prop -> prop
logic -> : prop -> prop -> prop
logic fst ['a 'b||] : 'a * 'b -> 'a
logic snd ['a 'b||] : 'a * 'b -> 'b
logic !! ['a|r|'e] : ref(r,'a) -> <r 'e > -> 'a
parameter ! ['a|r|] (x : ref(r,'a)) : 'a, {r} =
  {}
  {r : !!x = r /\ !!x|old = !!x}
logic combine [||'e1 'e2 'e3] : <'e1 'e2> -> <'e2 'e3> -> <'e1 'e2 'e3>
let pre ['a 'b||] (x : 'a * 'b) = fst x
let post ['a 'b||] (x : 'a * 'b) = snd x
logic <= : int -> int -> prop
  logic < : int -> int -> prop
logic + : int -> int -> int
logic - : int -> int -> int
logic int_max : int -> int -> int
type array ['a||]
logic len ['a||] :  'a array -> int
logic get ['a||] : int -> 'a array -> 'a

parameter forto [||'e] (inv : int -> <'e> -> prop) (start end_ : int)
  (f : int ->{'e} unit) : unit, {'e} =
    { inv start cur /\
          forall (i : int). start <= i /\ i <= end_ ->
          forall (m : <'e>) . inv i m -> pre f i m /\
          forall (n : <'e>). post f i m n () -> inv (i+1) n
    }
    { inv (int_max start (end_ + 1)) cur}


let iter ['a|t|'e]
  (inv : <t 'e> -> int ->  prop)
  (ar : ref(t, 'a array)) (f : 'a ->{t 'e} unit)  =
  { inv cur 0 /\
    forall (i:int). 0 <= i /\ i < len (!!ar) ->
    [[ inv cur i]] f (get i !ar) [[inv cur (i+1)]]
    }
  for i = 0 to len !ar - 1 do
    { inv cur i }
    f (get i !ar)
  done
  {inv cur (len !!ar|old) }
