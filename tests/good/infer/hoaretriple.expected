type unit
logic tt  : unit
logic = ['a||] : a -> a -> prop
logic /\  : prop -> prop -> prop
logic ~  : prop -> prop
logic ->  : prop -> prop -> prop
logic fst ['a 'b||] : (a * b) -> a
logic snd ['a 'b||] : (a * b) -> b
logic !! ['a|r|'e] : ref(r,a) -> <r 'e> -> a
let
  ! ['a|r|] = (fun (x:ref(r,a)) -> {(fun (cur:<r >) -> True)}
              parameter(a,{r } + {r })
              {(fun (old:<r >) ->
               (fun (cur:<r >) ->
               (fun (r1:a) ->
               ((!! [a| r| { }] x cur) =[a||] r1) /\
               ((!! [a| r| { }] x old) =[a||] (!! [a| r| { }] x cur)))))}) 
logic combine [||'e 'e1 'e2] : < 'e 'e1> -> < 'e1 'e2> -> < 'e 'e1 'e2>
let pre ['a 'b||] = (fun (x:a * b) -> fst [a,b||] x) 
let post ['a 'b||] = (fun (x:a * b) -> snd [a,b||] x) 
logic <=  : int -> int -> prop
logic <  : int -> int -> prop
logic +  : int -> int -> int
logic -  : int -> int -> int
logic int_max  : int -> int -> int
type array['a||]
logic len ['a||] : array[a] -> int
logic get ['a||] : int -> array[a] -> a
let
  forto [||'e] = (fun (inv:int -> < 'e> -> prop) ->
                 (fun (start:int) ->
                 (fun (end_:int) ->
                 (fun (f:int ->{{ 'e} + { 'e}} unit) ->
                 {(fun (cur:< 'e>) ->
                  (inv start cur) /\
                  (forall (i:int).
                   ((start <= i) /\ (i <= end_)) ->
                   (forall (m:< 'e>).
                    (inv i m) ->
                    ((pre [int -> < 'e> -> prop,int -> < 'e> -> < 'e> ->
                      unit -> prop||] f i m)
                     /\
                     (forall (n:< 'e>).
                      (post [int -> < 'e> -> prop,int -> < 'e> -> < 'e> ->
                       unit -> prop||] f i m n tt)
                      -> (inv (i + 1) n))))))}
                 parameter(unit,{ 'e} + { 'e})
                 {(fun (old:< 'e>) ->
                  (fun (cur:< 'e>) ->
                  (fun (anon:unit) -> inv (int_max start (end_ + 1)) cur)))})))) 
let
  iter ['a|t|'e] = (fun (inv:<t 'e> -> int -> prop) ->
                   (fun (ar:ref(t,array[a])) ->
                   (fun (f:a ->{{t 'e} + {t 'e}} unit) ->
                   {(fun (cur:<t 'e>) ->
                    (inv cur 0) /\
                    (forall (i:int).
                     ((0 <= i) /\
                      (i < (len [a||] (!! [array[a]| t| { 'e}] ar cur))))
                     ->
                     ([[(fun (cur1:<t 'e>) -> inv cur1 i)]]f
                                                           (get [a||] i
                                                            (! [array[a]| t|]
                                                             ar))[[(fun (old:<t 'e>)
                                                                   ->
                                                                   (fun (cur1:<t 'e>)
                                                                   ->
                                                                   (fun (anon:unit)
                                                                   ->
                                                                   inv cur1
                                                                   (i + 1))))]])))}
                   let __start = 0 in
                   let __end = (len [a||] (! [array[a]| t|] ar)) - 1 in
                   forto [|| {t 'e}]
                   (fun (i:int) -> (fun (cur:<t 'e>) -> inv cur i)) __start
                   __end
                   (fun (i:int) ->
                   {(fun (cur:<t 'e>) ->
                    ((__start <= i) /\ (i <= __end)) /\ (inv cur i))}
                   f (get [a||] i (! [array[a]| t|] ar))
                   {(fun (anon:<t 'e>) ->
                    (fun (cur:<t 'e>) ->
                    (fun (anon1:unit) -> inv cur (i + 1))))})
                   {(fun (old:<t 'e>) ->
                    (fun (cur:<t 'e>) ->
                    (fun (anon:unit) ->
                    inv cur (len [a||] (!! [array[a]| t| { 'e}] ar old)))))}))) 
