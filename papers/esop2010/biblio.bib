@inproceedings{KanigFilliatre09wml,
  author = {Johannes Kanig and Jean-Christophe Filli\^atre},
  title = {{Who: A Verifier for Effectful Higher-order Programs}},
  booktitle = {ACM SIGPLAN Workshop on ML},
  topics = {team, lri},
  type_publi = {icolcomlec},
  type_digiteo = {conf_isbn},
  year = 2009,
  month = aug,
  address = {Edinburgh, Scotland, UK},
  abstract = {We present Who, a tool for verifying effectful higher-order
  functions. It features Effect polymorphism, higher-order logic
  and the possibility to reason about state in the logic, which enable
  highly modular specifications of generic code. Several small
  examples and a larger case study demonstrate its usefulness. The
  Who tool is intended to be used as an intermediate language for
  verification tools targeting ML-like programming languages.},
  url = {http://www.lri.fr/~kanig/publis/wml09.pdf}
}

@MISC{RanTin-SMTLIB,
  author =	 {Silvio Ranise and Cesare Tinelli},
  title =	 {{The Satisfiability Modulo Theories Library (SMT-LIB)}},
  howpublished = {{\tt http://www.smtcomp.org}},
  year =	 2006,
}

@ARTICLE{pottier-gauthier-hosc,
  author = {François Pottier and Nadji Gauthier},
  title = {Polymorphic Typed Defunctionalization and
                 Concretization},
  journal = {Higher-Order and Symbolic Computation},
  month = MAR,
  year = {2006},
  volume = {19},
  pages = {125--162},
  url = {http://gallium.inria.fr/~fpottier/publis/fpottier-gauthier-hosc.ps.gz},
  pdf = {http://gallium.inria.fr/~fpottier/publis/fpottier-gauthier-hosc.pdf},
  off = {http://dx.doi.org/10.1007/s10990-006-8611-7},
  abstract = {\emph{Defunctionalization} is a program transformation
                 that eliminates functions as first-class values. We
                 show that defunctionalization can be viewed as a
                 \emph{type-preserving} transformation of an extension
                 of \f with \emph{guarded algebraic data types} into
                 itself. We also suggest that defunctionalization is an
                 instance of \emph{concretization}, a more general
                 technique that allows eliminating constructs other than
                 functions. We illustrate this point by presenting two
                 new type-preserving transformations that can be viewed
                 as instances of concretization. One eliminates
                 Rémy-style polymorphic records; the other eliminates
                 the dictionary records introduced by the standard
                 compilation scheme for Haskell's type classes.}
}

@INPROCEEDINGS{regis-gianas-pottier-08,
  author = {Yann Régis-Gianas and François Pottier},
  title = {A {Hoare} Logic for Call-by-Value Functional
                 Programs},
  booktitle = {Proceedings of the Ninth International Conference on
                 Mathematics of Program Construction (MPC'08)},
  month = JUL,
  year = {2008},
  pages = {305--335},
  abstract = {We present a Hoare logic for a call-by-value
                 programming language equipped with recursive,
                 higher-order functions, algebraic data types, and a
                 polymorphic type system in the style of Hindley and
                 Milner. It is the theoretical basis for a tool that
                 extracts proof obligations out of programs annotated
                 with logical assertions. These proof obligations,
                 expressed in a typed, higher-order logic, are
                 discharged using off-the-shelf automated or interactive
                 theorem provers. Although the technical apparatus that
                 we exploit is by now standard, its application to
                 functional programming languages appears to be new, and
                 (we claim) deserves attention. As a sample application,
                 we check the partial correctness of a balanced binary
                 search tree implementation.}
}

