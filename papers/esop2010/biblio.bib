@inproceedings{KanigFilliatre09wml,
  author = {Johannes Kanig and Jean-Christophe Filli\^atre},
  title = {{Who: A Verifier for Effectful Higher-order Programs}},
  booktitle = {ACM SIGPLAN Workshop on ML},
  topics = {team, lri},
  type_publi = {icolcomlec},
  type_digiteo = {conf_isbn},
  year = 2009,
  month = aug,
  address = {Edinburgh, Scotland, UK},
  abstract = {We present Who, a tool for verifying effectful higher-order
  functions. It features Effect polymorphism, higher-order logic
  and the possibility to reason about state in the logic, which enable
  highly modular specifications of generic code. Several small
  examples and a larger case study demonstrate its usefulness. The
  Who tool is intended to be used as an intermediate language for
  verification tools targeting ML-like programming languages.},
  url = {http://www.lri.fr/~kanig/publis/wml09.pdf}
}

@MISC{RanTin-SMTLIB,
  author =	 {Silvio Ranise and Cesare Tinelli},
  title =	 {{The Satisfiability Modulo Theories Library (SMT-LIB)}},
  howpublished = {{\tt http://www.smtcomp.org}},
  year =	 2006,
}

@ARTICLE{pottier-gauthier-hosc,
  author = {François Pottier and Nadji Gauthier},
  title = {Polymorphic Typed Defunctionalization and
                 Concretization},
  journal = {Higher-Order and Symbolic Computation},
  month = MAR,
  year = {2006},
  volume = {19},
  pages = {125--162},
  url = {http://gallium.inria.fr/~fpottier/publis/fpottier-gauthier-hosc.ps.gz},
  pdf = {http://gallium.inria.fr/~fpottier/publis/fpottier-gauthier-hosc.pdf},
  off = {http://dx.doi.org/10.1007/s10990-006-8611-7},
  abstract = {\emph{Defunctionalization} is a program transformation
                 that eliminates functions as first-class values. We
                 show that defunctionalization can be viewed as a
                 \emph{type-preserving} transformation of an extension
                 of \f with \emph{guarded algebraic data types} into
                 itself. We also suggest that defunctionalization is an
                 instance of \emph{concretization}, a more general
                 technique that allows eliminating constructs other than
                 functions. We illustrate this point by presenting two
                 new type-preserving transformations that can be viewed
                 as instances of concretization. One eliminates
                 Rémy-style polymorphic records; the other eliminates
                 the dictionary records introduced by the standard
                 compilation scheme for Haskell's type classes.}
}

@INPROCEEDINGS{regis-gianas-pottier-08,
  author = {Yann Régis-Gianas and François Pottier},
  title = {A {Hoare} Logic for Call-by-Value Functional
                 Programs},
  booktitle = {Proceedings of the Ninth International Conference on
                 Mathematics of Program Construction (MPC'08)},
  month = JUL,
  year = {2008},
  pages = {305--335},
  abstract = {We present a Hoare logic for a call-by-value
                 programming language equipped with recursive,
                 higher-order functions, algebraic data types, and a
                 polymorphic type system in the style of Hindley and
                 Milner. It is the theoretical basis for a tool that
                 extracts proof obligations out of programs annotated
                 with logical assertions. These proof obligations,
                 expressed in a typed, higher-order logic, are
                 discharged using off-the-shelf automated or interactive
                 theorem provers. Although the technical apparatus that
                 we exploit is by now standard, its application to
                 functional programming languages appears to be new, and
                 (we claim) deserves attention. As a sample application,
                 we check the partial correctness of a balanced binary
                 search tree implementation.}
}

@article{tofte97ic,
 author = {Mads Tofte and Jean-Pierre Talpin},
 title = {Region-based memory management},
 journal = {Inf. Comput.},
 volume = {132},
 number = {2},
 year = {1997},
 pages = {109--176},
 publisher = {Academic Press, Inc.},
 address = {Duluth, MN, USA},
 mycomments = { seems to me as the application of \cite{talpin94taed} to
   memory management},
 toread = {yes}
 }

@INPROCEEDINGS{Honda05anobservationally,
    author = {Kohei Honda and Nobuko Yoshida and Martin Berger},
    title = {An observationally complete program logic for imperative higher-order functions},
    booktitle = {In Proc. LICS’05},
    year = {2005},
    pages = {270--279}
}

@inproceedings{BergerHondaYoshida05aliasing,
 author = {Berger,, Martin and Honda,, Kohei and Yoshida,, Nobuko},
 title = {A logical analysis of aliasing in imperative higher-order functions},
 booktitle = {ICFP '05: Proceedings of the tenth ACM SIGPLAN international conference on Functional programming},
 year = {2005},
 pages = {280--293},
 location = {Tallinn, Estonia},
 publisher = {ACM},
 address = {New York, NY, USA},
 }

@Manual{CoqManualV81,
  author = {{The {Coq} Development Team}},
  title  = {{The Coq Proof Assistant Reference Manual -- Version V8.1}},
  year   = 2006,
  month  = jul,
  note   = {\url{http://coq.inria.fr}},
  topics = "team,lri",
  type_publi = "manuel",
  x-equipes = {demons PROVAL EXT},
  x-type = {manuel},
  x-support = {diffusion}
}

@inproceedings{sozeau07icfp,
  author = {Matthieu Sozeau},
  title = {{P}rogram-ing Finger Trees in {C}oq},
  pages = {13--24},
  x-pdf={http://www.lri.fr/~sozeau/research/publications/Program-ing_Finger_Trees_in_Coq.pdf},
  x-slides = {http://www.lri.fr/~sozeau/research/publications/Program-ing_Finger_Trees_in_Coq-icfp07-011007.pdf},
  copyright = {ACM, 2007. This is the author's version of the work. It is posted here by permission of ACM for your personal use. Not for redistribution. The definitive version was published in
   ICFP'07, http://doi.acm.org/10.1145/1291151.1291156},
  abstract = {Finger Trees (Hinze & Paterson, JFP 2006) are a general purpose persistent
data structure with good performance. Their genericity permits developing
a wealth of structures like ordered sequences or interval trees
on top of a single implementation. However, the type systems
used by current functional languages do not guarantee the coherent
parameterization and specialization of Finger Trees, let alone the
correctness of their implementation.
We present a certified implementation of Finger Trees solving
these problems using the {P}rogram extension of {C}oq. 
We not only implement the structure but also prove its
invariants along the way, which permit building certified
structures on top of Finger Trees in an elegant way.},
  crossref = {icfp07},
  type_digiteo = {conf_isbn}, 
  type_publi = {icolcomlec},
  topics = {team},
  x-equipes = {demons PROVAL},
  x-type = {article},
  x-support = {actes},
  x-cle-support = {ICFP}
}
@proceedings{icfp07,
  editor    = {Ralf Hinze and Norman Ramsey},
  title     = {Proceedings of the 12th ACM SIGPLAN International Conference
               on Functional Programming, ICFP 2007},
  booktitle = {12th ACM SIGPLAN International Conference
               on Functional Programming, ICFP 2007},
  address = {Freiburg, Germany},
  publisher = ACM,
  year      = {2007},
}

@inproceedings{Nanevski08Awkward,
  author = {Aleksandar Nanevski and Greg Morrisett and Avraham Shinnar and Paul Govereau and Lars Birkedal},
  title = {Ynot: Reasoning with the Awkward Squad},
  booktitle = {ICFP '08: Proceedings of the 13th ACM SIGPLAN International Conference on Functional Programming},
  month = {September},
  year = {2008},
}

@ARTICLE{ohearn-reynolds-00,
  author = {Peter W. O'Hearn and John C. Reynolds},
  title = {From {Algol} to polymorphic linear lambda-calculus},
  journal = {Journal of the {ACM}},
  volume = {47},
  number = {1},
  year = {2000},
  pages = {167--223},
}

@INPROCEEDINGS{chargueraud-pottier-08,
  author = {Arthur Charguéraud and François Pottier},
  title = {Functional Translation of a Calculus of Capabilities},
  booktitle = {ACM International Conference on Functional Programming
                 (ICFP)},
  month = SEP,
  year = {2008},
  pages = {213--224},
}

@article{Filliatre00a,
  author = {Jean-Christophe Filli\^atre},
  title = {{Verification of Non-Functional Programs 
                   using Interpretations in Type Theory}},
  journal = {Journal of Functional Programming},
  volume = 13,
  number = 4,
  pages = {709--745},
  month = {July},
  year = 2003,
  abstract = {We study the problem of certifying programs combining imperative and
  functional features within the general framework of type theory.
  
  Type theory constitutes a powerful specification language, which is
  naturally suited for the proof of purely functional programs. To
  deal with imperative programs, we propose a logical interpretation
  of an annotated program as a partial proof of its specification. The
  construction of the corresponding partial proof term is based on a
  static analysis of the effects of the program, and on the use of
  monads. The usual notion of monads is refined in order to account
  for the notion of effect. The missing subterms in the partial proof
  term are seen as proof obligations, whose actual proofs are left to
  the user. We show that the validity of those proof obligations
  implies the total correctness of the program.
  We also establish a result of partial completeness.
  
  This work has been implemented in the Coq proof assistant.
  It appears as a tactic taking an annotated program as argument and
  generating a set of proof obligations. Several nontrivial
  algorithms have been certified using this tactic.}
}

@InProceedings{BarnettLS04,
  author = 	 {Mike Barnett and K. Rustan M. Leino   and Wolfram Schulte},
  title = 	 {{The Spec\# Programming System: An Overview}},
  booktitle = {Construction and Analysis of Safe, Secure, and Interoperable Smart Devices (CASSIS'04)},
  pages = 	 {49--69},
  year = 	 {2004},
  volume = 	 {3362},
  publisher =	 sv,
  series =	 lncs
}

@Article{FilliatrePottier02,
  author = 	 {J.-C. Filli{\^a}tre and F. Pottier},
  title = 	 {{Producing All Ideals of a Forest, Functionally}},
  journal = 	 {Journal of Functional Programming},
  volume =       13,
  number =       5,
  pages =        {945--956},
  month =	 {September},
  year =	 2003
}

@Article{KodaRuskey93,
  author = 	 {Yasunori Koda and Frank Ruskey},
  title = 	 {A {Gray} Code for the Ideals of a Forest Poset},
  journal = 	 {Journal of Algorithms},
  month =        sep,
  year = 	 1993,
  volume =	 15,
  number =       2,
  pages =	 {324--340},
  note =         "\url{http://csr.csc.uvic.ca/home/fruskey/Publications/ForestIdeals.ps}",
}

@Book{andrews86,
  author	= "Peter B. Andrews",
  title		= "An Introduction to Mathematical Logic and Type Theory: to
    Truth through Proof",
  publisher	= "Academic Press",
  year		= 1986
}

@INPROCEEDINGS{chlipalaicfp09,
AUTHOR  = {Adam Chlipala and Gregory Malecha and Greg Morrisett and Avraham
  Shinnar and Ryan Wisnesky},
TITLE   = {Effective Interactive Proofs for Higher-Order Imperative Programs} ,
EDITOR  = {Andrew Tolmach},
BOOKTITLE = {14th International Conference on Functional Programming,
             Edinburgh, Scotland, Proceedings},
MONTH   = SEP,
YEAR    = 2009,
PUBLISHER = {ACM Press},
}

@inproceedings{paulintlca93,
  author = {Christine Paulin-Mohring},
  booktitle = {Proceedings of the conference Typed Lambda Calculi and Applications},
  editor = {M. Bezem and J.-F. Groote},
  number = 664,
  series = {Lecture Notes in Computer Science},
  title = {{Inductive Definitions in the System {Coq} - Rules and Properties}},
  year = 1993,
  topics = {team}
}

@inproceedings{Krishnaswami06,
 author = {Krishnaswami,, Neelakantan R.},
 title = {Reasoning about iterators with separation logic},
 booktitle = {SAVCBS '06: Proceedings of the 2006 conference on Specification and verification of component-based systems},
 year = {2006},
 pages = {83--86},
 location = {Portland, Oregon},
 publisher = {ACM},
 address = {New York, NY, USA},
 }

@inproceedings{reynolds78popl,
author = "Reynolds, John C.",
title = "Syntactic Control of Interference",
booktitle = "Conference Record of the Fifth Annual ACM Symposium on Principles of Programming Languages",
publisher = "ACM",
address = "New York",
place = "Tucson, Arizona",
dates = "January 23--25",
year = "1978",
pages = "39--46",
reprint = "Reprinted in \authorcite{O'Hearn and Tennent} \crosscite[vol.~1, pages~273--286]{OHEARN97}",
filename = "syncontrol",
abstract = "In programming languages which permit both assignment and procedures,
distinct identifiers can represent data structures which share storage or
procedures with interfering side effects. In addition to being a direct
source of programming errors, this phenomenon, which we call interference,
can impact type structure and parallelism. We show how to eliminate these
difficulties by imposing syntactic restrictions, without prohibiting the
kind of constructive interference which occurs with higher-order procedures
or Simula classes. The basic idea is to prohibit interference between
identifiers, but to permit interference among components of collections
named by single identifiers.",
checked = "17 June 1988",
updated = "10 May 1997"}

@article{talpin94taed,
 author = {Jean-Pierre Talpin and Pierre Jouvelot},
 title = {The type and effect discipline},
 journal = {Inf. Comput.},
 volume = {111},
 number = {2},
 year = {1994},
 pages = {245--296},
 publisher = {Academic Press, Inc.},
 address = {Duluth, MN, USA},
 mycomments = {
    Effect analysis of ML programs with references.
    Instead of variable names, they keep track of variables using regions:
    τ ref -> τ ref_ρ
    Regions represent may-alias information
    Effects additionally may be effect variables, to permit higher order
    To be able to type any ML program, they introduce region and effect
    polymorphism (just like type polymorphism)
    Originally invented to determine possible parallelism and to
    conservatively type references in ML (other than the imperative and
        applicative type variables of Tofte)
    an inference algorithm that uses standard robinson unification is also
    given.
 }
}

@InProceedings{filliatre07cav,
  author = 	 {Jean-Christophe Filli\^atre and Claude March\'e},
  title = 	 {The {Why/Krakatoa/Caduceus} Platform for Deductive Program
  Verification},
  crossref = {cav07},
  pages = {173--177},
  topics = {team, lri},
  type_digiteo = {conf_isbn},
  type_publi = {icolcomlec},
  x-pdf = {http://www.lri.fr/~filliatr/ftp/publis/cav07.pdf},
  x-equipes = {demons PROVAL EXT},
  x-type = {articlecourt},
  x-support = {actes},
  x-cle-support = {CAV}
}

@inproceedings{bornat00mpc,
    author = "Richard Bornat",
    title = "Proving Pointer Programs in {H}oare Logic",
    booktitle = "Mathematics of Program Construction",
    pages = "102--126",
    year = "2000"}

@proceedings{cav07,
  editor    = {Werner Damm and Holger Hermanns},
  title     = {Computer Aided Verification},
  booktitle = {19th International Conference on Computer Aided Verification},
  publisher = SV,
  series    = lncs,
  volume = 4590,
  address   = {Berlin, Germany},
  month = jul,
  year      = {2007}
}

@misc{appendixesop2010,
  author = {Johannes Kanig and Jean-Christophe Filliâtre},
  title = {Technical Appendix},
  url = {http://www.lri.fr/~kanig/files/esop2010-appendix.pdf},
  year = {2009}
}

